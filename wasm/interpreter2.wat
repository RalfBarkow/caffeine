(module;; (JSProperty) property: vmVersion -> 'SqueakJS 0.9.5';; (JSProperty) property: vmDate -> '2016-11-08';; (JSProperty) property: vmBuild -> 'unknown';; (JSProperty) property: vmPath -> '/';; (JSProperty) property: vmFile -> 'vm.js';; (JSProperty) property: platformName -> 'Web';; (JSProperty) property: platformSubtype -> 'unknown';; (JSProperty) property: osVersion -> navigator.userAge...;; (JSProperty) property: windowSystem -> 'HTML';; (JSProperty) property: HeaderTypeMask -> 3;; (JSProperty) property: HeaderTypeSizeAndClass -> 0;; (JSProperty) property: HeaderTypeClass -> 1;; (JSProperty) property: HeaderTypeFree -> 2;; (JSProperty) property: HeaderTypeShort -> 3;; (JSProperty) property: splOb_NilObject -> 0;; (JSProperty) property: splOb_FalseObject -> 1;; (JSProperty) property: splOb_TrueObject -> 2;; (JSProperty) property: splOb_SchedulerAssociation -> ...;; (JSProperty) property: splOb_ClassBitmap -> 4;; (JSProperty) property: splOb_ClassInteger -> 5;; (JSProperty) property: splOb_ClassString -> 6;; (JSProperty) property: splOb_ClassArray -> 7;; (JSProperty) property: splOb_SmalltalkDictionary -> 8;; (JSProperty) property: splOb_ClassFloat -> 9;; (JSProperty) property: splOb_ClassMethodContext -> 10;; (JSProperty) property: splOb_ClassBlockContext -> 11;; (JSProperty) property: splOb_ClassPoint -> 12;; (JSProperty) property: splOb_ClassLargePositiveIntege...;; (JSProperty) property: splOb_TheDisplay -> 14;; (JSProperty) property: splOb_ClassMessage -> 15;; (JSProperty) property: splOb_ClassCompiledMethod -> 1...;; (JSProperty) property: splOb_TheLowSpaceSemaphore -> ...;; (JSProperty) property: splOb_ClassSemaphore -> 18;; (JSProperty) property: splOb_ClassCharacter -> 19;; (JSProperty) property: splOb_SelectorDoesNotUnderstan...;; (JSProperty) property: splOb_SelectorCannotReturn -> ...;; (JSProperty) property: splOb_TheInputSemaphore -> 22;; (JSProperty) property: splOb_SpecialSelectors -> 23;; (JSProperty) property: splOb_CharacterTable -> 24;; (JSProperty) property: splOb_SelectorMustBeBoolean ->...;; (JSProperty) property: splOb_ClassByteArray -> 26;; (JSProperty) property: splOb_ClassProcess -> 27;; (JSProperty) property: splOb_CompactClasses -> 28;; (JSProperty) property: splOb_TheTimerSemaphore -> 29;; (JSProperty) property: splOb_TheInterruptSemaphore ->...;; (JSProperty) property: splOb_FloatProto -> 31;; (JSProperty) property: splOb_SelectorCannotInterpret ...;; (JSProperty) property: splOb_MethodContextProto -> 35;; (JSProperty) property: splOb_ClassBlockClosure -> 36;; (JSProperty) property: splOb_BlockContextProto -> 37;; (JSProperty) property: splOb_ExternalObjectsArray -> ...;; (JSProperty) property: splOb_ClassPseudoContext -> 39;; (JSProperty) property: splOb_ClassTranslatedMethod ->...;; (JSProperty) property: splOb_TheFinalizationSemaphore...;; (JSProperty) property: splOb_ClassLargeNegativeIntege...;; (JSProperty) property: splOb_ClassExternalAddress -> ...;; (JSProperty) property: splOb_ClassExternalStructure -...;; (JSProperty) property: splOb_ClassExternalData -> 45;; (JSProperty) property: splOb_ClassExternalFunction ->...;; (JSProperty) property: splOb_ClassExternalLibrary -> ...;; (JSProperty) property: splOb_SelectorAboutToReturn ->...;; (JSProperty) property: splOb_SelectorRunWithIn -> 49;; (JSProperty) property: splOb_SelectorAttemptToAssign ...;; (JSProperty) property: splOb_PrimErrTableIndex -> 51;; (JSProperty) property: splOb_ClassAlien -> 52;; (JSProperty) property: splOb_InvokeCallbackSelector -...;; (JSProperty) property: splOb_ClassUnsafeAlien -> 54;; (JSProperty) property: splOb_ClassWeakFinalizer -> 55;; (JSProperty) property: splOb_ClassProxy -> 107;; (JSProperty) property: splOb_SelectorForward -> 108;; (JSProperty) property: splOb_SelectorInitProxy -> 109;; (JSProperty) property: splOb_SelectorRecyclingHash ->...;; (JSProperty) property: splOb_SelectorCounterpart -> 1...;; (JSProperty) property: splOb_SelectorIsNil -> 112;; (JSProperty) property: splOb_SelectorNextInstance -> ...;; (JSProperty) property: splOb_SelectorStoreOnTether ->...;; (JSProperty) property: splOb_SelectorStartReportingSe...;; (JSProperty) property: splOb_ActiveMethodID -> 116;; (JSProperty) property: splOb_ReportedSendAvailable ->...;; (JSProperty) property: splOb_SelectorStopReportingSen...;; (JSProperty) property: splOb_SelectorUnreportedWait -...;; (JSProperty) property: splOb_SelectorUnreportedSignal...;; (JSProperty) property: splOb_SelectorTether -> 121;; (JSProperty) property: splOb_ReloadingMethod -> 122;; (JSProperty) property: splOb_JSProxyClass -> 123;; (JSProperty) property: Class_superclass -> 0;; (JSProperty) property: Class_mdict -> 1;; (JSProperty) property: Class_format -> 2;; (JSProperty) property: Class_instVars -> nil;; (JSProperty) property: Class_name -> 6;; (JSProperty) property: Context_sender -> 0;; (JSProperty) property: Context_instructionPointer -> ...;; (JSProperty) property: Context_stackPointer -> 2;; (JSProperty) property: Context_method -> 3;; (JSProperty) property: Context_closure -> 4;; (JSProperty) property: Context_receiver -> 5;; (JSProperty) property: Context_tempFrameStart -> 6;; (JSProperty) property: Context_smallFrameSize -> 16;; (JSProperty) property: Context_largeFrameSize -> 56;; (JSProperty) property: BlockContext_caller -> 0;; (JSProperty) property: BlockContext_argumentCount -> ...;; (JSProperty) property: BlockContext_initialIP -> 4;; (JSProperty) property: BlockContext_home -> 5;; (JSProperty) property: Closure_outerContext -> 0;; (JSProperty) property: Closure_startpc -> 1;; (JSProperty) property: Closure_numArgs -> 2;; (JSProperty) property: Closure_firstCopiedValue -> 3;; (JSProperty) property: Stream_array -> 0;; (JSProperty) property: Stream_position -> 1;; (JSProperty) property: Stream_limit -> 2;; (JSProperty) property: ProcSched_processLists -> 0;; (JSProperty) property: ProcSched_activeProcess -> 1;; (JSProperty) property: Link_nextLink -> 0;; (JSProperty) property: LinkedList_firstLink -> 0;; (JSProperty) property: LinkedList_lastLink -> 1;; (JSProperty) property: Semaphore_excessSignals -> 2;; (JSProperty) property: Mutex_owner -> 2;; (JSProperty) property: Proc_suspendedContext -> 1;; (JSProperty) property: Proc_priority -> 2;; (JSProperty) property: Proc_myList -> 3;; (JSProperty) property: Assn_key -> 0;; (JSProperty) property: Assn_value -> 1;; (JSProperty) property: MethodDict_array -> 1;; (JSProperty) property: MethodDict_selectorStart -> 2;; (JSProperty) property: Message_selector -> 0;; (JSProperty) property: Message_arguments -> 1;; (JSProperty) property: Message_lookupClass -> 2;; (JSProperty) property: Point_x -> 0;; (JSProperty) property: Point_y -> 1;; (JSProperty) property: LargeInteger_bytes -> 0;; (JSProperty) property: LargeInteger_neg -> 1;; (JSProperty) property: BitBlt_dest -> 0;; (JSProperty) property: BitBlt_source -> 1;; (JSProperty) property: BitBlt_halftone -> 2;; (JSProperty) property: BitBlt_combinationRule -> 3;; (JSProperty) property: BitBlt_destX -> 4;; (JSProperty) property: BitBlt_destY -> 5;; (JSProperty) property: BitBlt_width -> 6;; (JSProperty) property: BitBlt_height -> 7;; (JSProperty) property: BitBlt_sourceX -> 8;; (JSProperty) property: BitBlt_sourceY -> 9;; (JSProperty) property: BitBlt_clipX -> 10;; (JSProperty) property: BitBlt_clipY -> 11;; (JSProperty) property: BitBlt_clipW -> 12;; (JSProperty) property: BitBlt_clipH -> 13;; (JSProperty) property: BitBlt_colorMap -> 14;; (JSProperty) property: BitBlt_warpBase -> 15;; (JSProperty) property: Form_bits -> 0;; (JSProperty) property: Form_width -> 1;; (JSProperty) property: Form_height -> 2;; (JSProperty) property: Form_depth -> 3;; (JSProperty) property: Form_offset -> 4;; (JSProperty) property: WeakFinalizationList_first -> ...;; (JSProperty) property: WeakFinalizerItem_list -> 0;; (JSProperty) property: WeakFinalizerItem_next -> 1;; (JSProperty) property: ExtLibFunc_handle -> 0;; (JSProperty) property: ExtLibFunc_flags -> 1;; (JSProperty) property: ExtLibFunc_argTypes -> 2;; (JSProperty) property: ExtLibFunc_name -> 3;; (JSProperty) property: ExtLibFunc_module -> 4;; (JSProperty) property: ExtLibFunc_errorCodeName -> 5;; (JSProperty) property: Mouse_Blue -> 1;; (JSProperty) property: Mouse_Yellow -> 2;; (JSProperty) property: Mouse_Red -> 4;; (JSProperty) property: Keyboard_Shift -> 8;; (JSProperty) property: Keyboard_Ctrl -> 16;; (JSProperty) property: Keyboard_Alt -> 32;; (JSProperty) property: Keyboard_Cmd -> 64;; (JSProperty) property: Mouse_All -> 1 + 2 + 4;; (JSProperty) property: Keyboard_All -> 8 + 16 + 32 + ...;; (JSProperty) property: EventTypeNone -> 0;; (JSProperty) property: EventTypeMouse -> 1;; (JSProperty) property: EventTypeKeyboard -> 2;; (JSProperty) property: EventTypeDragDropFiles -> 3;; (JSProperty) property: EventKeyChar -> 0;; (JSProperty) property: EventKeyDown -> 1;; (JSProperty) property: EventKeyUp -> 2;; (JSProperty) property: EventDragEnter -> 1;; (JSProperty) property: EventDragMove -> 2;; (JSProperty) property: EventDragLeave -> 3;; (JSProperty) property: EventDragDrop -> 4;; (JSProperty) property: MinSmallInt -> -1073741824;; (JSProperty) property: MaxSmallInt -> 1073741823;; (JSProperty) property: NonSmallInt -> -1342177280;; (JSProperty) property: MillisecondClockMask -> 536870...;; (JSProperty) property: PrimNoErr -> 0;; (JSProperty) property: PrimErrGenericFailure -> 1;; (JSProperty) property: PrimErrBadReceiver -> 2;; (JSProperty) property: PrimErrBadArgument -> 3;; (JSProperty) property: PrimErrBadIndex -> 4;; (JSProperty) property: PrimErrBadNumArgs -> 5;; (JSProperty) property: PrimErrInappropriate -> 6;; (JSProperty) property: PrimErrUnsupported -> 7;; (JSProperty) property: PrimErrNoModification -> 8;; (JSProperty) property: PrimErrNoMemory -> 9;; (JSProperty) property: PrimErrNoCMemory -> 10;; (JSProperty) property: PrimErrNotFound -> 11;; (JSProperty) property: PrimErrBadMethod -> 12;; (JSProperty) property: PrimErrNamedInternal -> 13;; (JSProperty) property: PrimErrObjectMayMove -> 14;; (JSProperty) property: PrimErrLimitExceeded -> 15;; (JSProperty) property: PrimErrObjectIsPinned -> 16;; (JSProperty) property: PrimErrWritePastObject -> 17;; (JSProperty) property: externalModules -> Squeak.exte...;; (JSProperty) property: registerExternalModule -> func...;; (FunctionExpression) function(name, module) { 	this.externalM...(func $registerExternalModule						(local $name i32)						(local $module i32)						(local $temp i32)						;; (ExpressionStatement) this.externalModules[name] = module;; (AssignmentExpression) this.externalModules[name] = module						local.get $this;; (JSIdentifier) name						local.get $name;; (JSIdentifier) module						local.get $module						call $atPut);; (JSProperty) property: fsck -> function(whenDone, dir...;; (FunctionExpression) function(whenDone, dir, files, stats) { ...(func $fsck						(local $whenDone i32)						(local $temp i32)						(local $stats i32)						(local $dir i32)						(local $path i32)						(local $total i32)						(local $name i32)						(local $key i32)						(local $match i32)						(local $entries i32)						(local $files i32)						(local $isDir i32)						(local $exists i32)						(local $orphaned i32)												;; unwritable: (ExpressionStatement) dir = dir || '';; (ExpressionStatement) stats = stats || {property: dirs -> 0, p...;; (AssignmentExpression) stats = stats || {property: dirs -> 0, p...;; (BinaryExpression) stats || {property: dirs -> 0, property:...;; (JSIdentifier) stats						local.get $stats;; (ObjectExpression) {property: dirs -> 0, property: files ->...						i32.or						local.set $stats						;; unwritable: (IfStatement) if (!files) {files = {} an active ForInS;; (ForInStatement) an active ForInStatement with properties...						;; unwritable: (IfStatement) if (dir === '') {console.log('squeak fsc);; (JSProperty) property: dbTransaction -> function(mode...;; (FunctionExpression) function(mode, description, transactionF...(func $dbTransaction						(local $completionFunc i32)						(local $fileStore i32)						(local $mode i32)						(local $trans i32)						(local $description i32)						(local $openReq i32)						(local $temp i32)						(local $transactionFunc i32);; (FunctionDeclaration) function fakeTransaction() {transactionF...;; (FunctionExpression) function() { 	transactionFunc(Squeak.dbF...(func $fakeTransaction	(local $temp i32)		;; unwritable: (ExpressionStatement) transactionFunc(Squeak.dbFake());; (IfStatement) if (completionFunc) {completionFunc()};; (JSIdentifier) completionFunc						local.get $completionFunc						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) completionFunc();; (CallExpression) completionFunc()						call $completionFunc)));; (FunctionDeclaration) function startTransaction() {var trans =...;; (FunctionExpression) function() { 	var trans = SqueakDB.trans...(func $startTransaction	(local $temp i32)	(local $trans i32)	(local $fileStore i32)	;; (ExpressionStatement) trans.oncomplete = function(e) { 	if (co...;; (AssignmentExpression) trans.oncomplete = function(e) { 	if (co...;; (FunctionExpression) function(e) { 	if (completionFunc) {comp...(func $nil						(local $temp i32)						(local $e i32)						;; (IfStatement) if (completionFunc) {completionFunc()};; (JSIdentifier) completionFunc						local.get $completionFunc						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) completionFunc();; (CallExpression) completionFunc()						call $completionFunc)))						local.set $oncomplete;; (ExpressionStatement) trans.onerror = function(e) { 	console.e...;; (AssignmentExpression) trans.onerror = function(e) { 	console.e...;; (FunctionExpression) function(e) { 	console.error(e.target.er...(func $nil						(local $temp i32)						(local $e i32)												;; unwritable: (ExpressionStatement) console.error(e.target.error.name + ': ')						local.set $onerror;; (ExpressionStatement) trans.onabort = function(e) { 	console.e...;; (AssignmentExpression) trans.onabort = function(e) { 	console.e...;; (FunctionExpression) function(e) { 	console.error(e.target.er...(func $nil						(local $temp i32)						(local $e i32)												;; unwritable: (ExpressionStatement) console.error(e.target.error.name + ': a						;; unwritable: (ExpressionStatement) transactionFunc(Squeak.dbFake());; (IfStatement) if (completionFunc) {completionFunc()};; (JSIdentifier) completionFunc						local.get $completionFunc						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) completionFunc();; (CallExpression) completionFunc()						call $completionFunc)))						local.set $onabort;; (ExpressionStatement) transactionFunc(fileStore);; (CallExpression) transactionFunc(fileStore);; (JSIdentifier) fileStore						local.get $fileStore						call $transactionFunc)												;; unwritable: (IfStatement) if (typeof indexedDB == 'undefined') {re;; (EmptyStatement) ;; (IfStatement) if (self.SqueakDB) {return startTransact...;; (StaticMemberExpression) self.SqueakDB;; (JSIdentifier) SqueakDB						local.get $SqueakDB						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return startTransaction();; (CallExpression) startTransaction()						call $startTransaction						return));; (IfStatement) if (!openReq) {return fakeTransaction() ...;; (UnaryExpression) !openReq;; (JSIdentifier) openReq						local.get $openReq						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) return fakeTransaction() ;; (ReturnStatement) return fakeTransaction();; (CallExpression) fakeTransaction()						call $fakeTransaction						return));; (ExpressionStatement) openReq.onsuccess = function(e) { 	conso...;; (AssignmentExpression) openReq.onsuccess = function(e) { 	conso...;; (FunctionExpression) function(e) { 	console.log('Opened files...(func $nil						(local $temp i32)						(local $e i32)												;; unwritable: (ExpressionStatement) console.log('Opened files database.')						;; unwritable: (ExpressionStatement) self.SqueakDB = this.result						;; unwritable: (ExpressionStatement) SqueakDB.onversionchange = function(e) {						;; unwritable: (ExpressionStatement) SqueakDB.onerror = function(e) { 	consol;; (ExpressionStatement) startTransaction();; (CallExpression) startTransaction()						call $startTransaction)						local.set $onsuccess;; (ExpressionStatement) openReq.onupgradeneeded = function(e) { ...;; (AssignmentExpression) openReq.onupgradeneeded = function(e) { ...;; (FunctionExpression) function(e) { 	console.log('Creating fil...(func $nil						(local $temp i32)						(local $db i32)						(local $e i32)												;; unwritable: (ExpressionStatement) console.log('Creating files database')						;; unwritable: (ExpressionStatement) db.createObjectStore('files'))						local.set $onupgradeneeded;; (ExpressionStatement) openReq.onerror = function(e) { 	console...;; (AssignmentExpression) openReq.onerror = function(e) { 	console...;; (FunctionExpression) function(e) { 	console.error(e.target.er...(func $nil						(local $temp i32)						(local $e i32)												;; unwritable: (ExpressionStatement) console.error(e.target.error.message + '						;; unwritable: (ExpressionStatement) console.warn('Falling back to local stor;; (ExpressionStatement) fakeTransaction();; (CallExpression) fakeTransaction()						call $fakeTransaction)						local.set $onerror;; (ExpressionStatement) openReq.onblocked = function(e) { 	conso...;; (AssignmentExpression) openReq.onblocked = function(e) { 	conso...;; (FunctionExpression) function(e) { 	console.log('Database upg...(func $nil						(local $temp i32)						(local $e i32)												;; unwritable: (ExpressionStatement) console.log('Database upgrade needed, bu						;; unwritable: (ExpressionStatement) console.warn('Falling back to local stor;; (ExpressionStatement) fakeTransaction();; (CallExpression) fakeTransaction()						call $fakeTransaction)						local.set $onblocked);; (JSProperty) property: dbFake -> function() { 	if (ty...;; (FunctionExpression) function() { 	if (typeof SqueakDBFake ==...(func $dbFake						(local $temp i32)												;; unwritable: (IfStatement) if (typeof SqueakDBFake == 'undefined') ;; (ReturnStatement) return SqueakDBFake;; (JSIdentifier) SqueakDBFake						local.get $SqueakDBFake						return);; (JSProperty) property: fileGet -> function(filepath, ...;; (FunctionExpression) function(filepath, thenDo, errorDo) { 	i...(func $fileGet						(local $errorDo i32)						(local $path i32)						(local $temp i32)						(local $thenDo i32)						(local $filepath i32)						;; (IfStatement) if (!errorDo) {errorDo = function(err) {...;; (UnaryExpression) !errorDo;; (JSIdentifier) errorDo						local.get $errorDo						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) errorDo = function(err) { 	console.log(e...;; (AssignmentExpression) errorDo = function(err) { 	console.log(e...;; (FunctionExpression) function(err) { 	console.log(err) }(func $nil						(local $err i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) console.log(err))						local.set $errorDo))						;; unwritable: (IfStatement) if (!path.basename) {return errorDo('Inv;; (IfStatement) if (self.SqueakDBFake && SqueakDBFake.bi...;; (BinaryExpression) self.SqueakDBFake && SqueakDBFake.bigFil...;; (StaticMemberExpression) self.SqueakDBFake;; (JSIdentifier) SqueakDBFake						local.get $SqueakDBFake;; (ComputedMemberExpression) SqueakDBFake.bigFiles[path.fullname];; (StaticMemberExpression) SqueakDBFake.bigFiles;; (JSIdentifier) bigFiles						local.get $bigFiles;; (StaticMemberExpression) path.fullname;; (JSIdentifier) fullname						local.get $fullname						i32.const 4						i32.mul						i32.add						i32.and						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return thenDo(SqueakDBFake.bigFiles[path...;; (CallExpression) thenDo(SqueakDBFake.bigFiles[path.fullna...;; (ComputedMemberExpression) SqueakDBFake.bigFiles[path.fullname];; (StaticMemberExpression) SqueakDBFake.bigFiles;; (JSIdentifier) bigFiles						local.get $bigFiles;; (StaticMemberExpression) path.fullname;; (JSIdentifier) fullname						local.get $fullname						i32.const 4						i32.mul						i32.add						call $thenDo						return))						;; unwritable: (ExpressionStatement) this.dbTransaction('readonly', 'get ' + );; (JSProperty) property: filePut -> function(filepath, ...;; (FunctionExpression) function(filepath, contents, optSuccess)...(func $filePut						(local $temp i32)						(local $optSuccess i32)						(local $now i32)						(local $path i32)						(local $directory i32)						(local $contents i32)						(local $entry i32)						(local $filepath i32)						;; (IfStatement) if (!path.basename) {return nil};; (UnaryExpression) !path.basename;; (StaticMemberExpression) path.basename;; (JSIdentifier) basename						local.get $basename						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return));; (IfStatement) if (!directory) {return nil};; (UnaryExpression) !directory;; (JSIdentifier) directory						local.get $directory						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return))						;; unwritable: (IfStatement) if (!entry) {entry = [path.basename, now;; (ExpressionStatement) entry[2] = now;; (AssignmentExpression) entry[2] = now						local.get $'entry';; (JSLiteral) 2						i32.const 2;; (JSIdentifier) now						local.get $now						call $atPut;; (ExpressionStatement) entry[4] = contents.byteLength || conten...;; (AssignmentExpression) entry[4] = contents.byteLength || conten...						local.get $'entry';; (JSLiteral) 4						i32.const 4;; (BinaryExpression) contents.byteLength || contents.length |...;; (BinaryExpression) contents.byteLength || contents.length;; (StaticMemberExpression) contents.byteLength;; (JSIdentifier) byteLength						local.get $byteLength;; (StaticMemberExpression) contents.length;; (JSIdentifier) length						local.get $length						i32.or;; (JSLiteral) 0						i32.const 0						i32.or						call $atPut						;; unwritable: (ExpressionStatement) localStorage['squeak:' + path.dirname] =						;; unwritable: (ExpressionStatement) this.dbTransaction('readwrite', 'put ' +;; (ReturnStatement) return entry;; (JSIdentifier) entry						local.get $entry						return);; (JSProperty) property: fileDelete -> function(filepat...;; (FunctionExpression) function(filepath, entryOnly) { 	var pat...(func $fileDelete						(local $entryOnly i32)						(local $path i32)						(local $directory i32)						(local $temp i32)						(local $entry i32)						(local $filepath i32)						;; (IfStatement) if (!path.basename) {return false};; (UnaryExpression) !path.basename;; (StaticMemberExpression) path.basename;; (JSIdentifier) basename						local.get $basename						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!directory) {return false};; (UnaryExpression) !directory;; (JSIdentifier) directory						local.get $directory						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!entry || entry[3]) {return false};; (BinaryExpression) !entry || entry[3];; (UnaryExpression) !entry;; (JSIdentifier) entry						local.get $entry						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (ComputedMemberExpression) entry[3];; (JSIdentifier) entry						local.get $entry;; (JSLiteral) 3						i32.const 3						i32.const 4						i32.mul						i32.add						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (ExpressionStatement) delete directory[path.basename]						;; unwritable: (ExpressionStatement) localStorage['squeak:' + path.dirname] =;; (IfStatement) if (entryOnly) {return true};; (JSIdentifier) entryOnly						local.get $entryOnly						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return))						;; unwritable: (ExpressionStatement) this.dbTransaction('readwrite', 'delete ;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: fileRename -> function(from, t...;; (FunctionExpression) function(from, to) { 	var oldpath = this...(func $fileRename						(local $samedir i32)						(local $temp i32)						(local $newdir i32)						(local $to i32)						(local $olddir i32)						(local $from i32)						(local $newpath i32)						(local $entry i32)						(local $oldpath i32)						;; (IfStatement) if (!oldpath.basename) {return false};; (UnaryExpression) !oldpath.basename;; (StaticMemberExpression) oldpath.basename;; (JSIdentifier) basename						local.get $basename						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!newpath.basename) {return false};; (UnaryExpression) !newpath.basename;; (StaticMemberExpression) newpath.basename;; (JSIdentifier) basename						local.get $basename						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!olddir) {return false};; (UnaryExpression) !olddir;; (JSIdentifier) olddir						local.get $olddir						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!entry || entry[3]) {return false};; (BinaryExpression) !entry || entry[3];; (UnaryExpression) !entry;; (JSIdentifier) entry						local.get $entry						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (ComputedMemberExpression) entry[3];; (JSIdentifier) entry						local.get $entry;; (JSLiteral) 3						i32.const 3						i32.const 4						i32.mul						i32.add						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!newdir) {return false};; (UnaryExpression) !newdir;; (JSIdentifier) newdir						local.get $newdir						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (newdir[newpath.basename]) {return fa...;; (ComputedMemberExpression) newdir[newpath.basename];; (JSIdentifier) newdir						local.get $newdir;; (StaticMemberExpression) newpath.basename;; (JSIdentifier) basename						local.get $basename						i32.const 4						i32.mul						i32.add						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (ExpressionStatement) delete olddir[oldpath.basename];; (ExpressionStatement) entry[0] = newpath.basename;; (AssignmentExpression) entry[0] = newpath.basename						local.get $'entry';; (JSLiteral) 0						i32.const 0;; (StaticMemberExpression) newpath.basename;; (JSIdentifier) basename						local.get $basename						call $atPut;; (ExpressionStatement) newdir[newpath.basename] = entry;; (AssignmentExpression) newdir[newpath.basename] = entry						local.get $'newdir';; (StaticMemberExpression) newpath.basename;; (JSIdentifier) basename						local.get $basename;; (JSIdentifier) entry						local.get $entry						call $atPut						;; unwritable: (ExpressionStatement) localStorage['squeak:' + newpath.dirname						;; unwritable: (IfStatement) if (!samedir) {localStorage['squeak:' + 						;; unwritable: (ExpressionStatement) this.fileGet(oldpath.fullname, function(;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: fileExists -> function(filepat...;; (FunctionExpression) function(filepath) { 	var path = this.sp...(func $fileExists						(local $path i32)						(local $directory i32)						(local $temp i32)						(local $entry i32)						(local $filepath i32)						;; (IfStatement) if (!path.basename) {return false};; (UnaryExpression) !path.basename;; (StaticMemberExpression) path.basename;; (JSIdentifier) basename						local.get $basename						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!directory) {return false};; (UnaryExpression) !directory;; (JSIdentifier) directory						local.get $directory						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!entry || entry[3]) {return false};; (BinaryExpression) !entry || entry[3];; (UnaryExpression) !entry;; (JSIdentifier) entry						local.get $entry						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (ComputedMemberExpression) entry[3];; (JSIdentifier) entry						local.get $entry;; (JSLiteral) 3						i32.const 3						i32.const 4						i32.mul						i32.add						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: dirCreate -> function(dirpath,...;; (FunctionExpression) function(dirpath, withParents) { 	var pa...(func $dirCreate						(local $temp i32)						(local $now i32)						(local $path i32)						(local $directory i32)						(local $withParents i32)						(local $entry i32)						(local $dirpath i32)						;; (IfStatement) if (!path.basename) {return false};; (UnaryExpression) !path.basename;; (StaticMemberExpression) path.basename;; (JSIdentifier) basename						local.get $basename						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (IfStatement) if (withParents && !localStorage['squeak;; (IfStatement) if (!directory) {return false};; (UnaryExpression) !directory;; (JSIdentifier) directory						local.get $directory						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (directory[path.basename]) {return fa...;; (ComputedMemberExpression) directory[path.basename];; (JSIdentifier) directory						local.get $directory;; (StaticMemberExpression) path.basename;; (JSIdentifier) basename						local.get $basename						i32.const 4						i32.mul						i32.add						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) directory[path.basename] = entry;; (AssignmentExpression) directory[path.basename] = entry						local.get $'directory';; (StaticMemberExpression) path.basename;; (JSIdentifier) basename						local.get $basename;; (JSIdentifier) entry						local.get $entry						call $atPut						;; unwritable: (ExpressionStatement) localStorage['squeak:' + path.fullname] 						;; unwritable: (ExpressionStatement) localStorage['squeak:' + path.dirname] =;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: dirDelete -> function(dirpath)...;; (FunctionExpression) function(dirpath) { 	var path = this.spl...(func $dirDelete						(local $child i32)						(local $children i32)						(local $path i32)						(local $directory i32)						(local $temp i32)						(local $dirpath i32)						;; (IfStatement) if (!path.basename) {return false};; (UnaryExpression) !path.basename;; (StaticMemberExpression) path.basename;; (JSIdentifier) basename						local.get $basename						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!directory) {return false};; (UnaryExpression) !directory;; (JSIdentifier) directory						local.get $directory						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!directory[path.basename]) {return f...;; (UnaryExpression) !directory[path.basename];; (ComputedMemberExpression) directory[path.basename];; (JSIdentifier) directory						local.get $directory;; (StaticMemberExpression) path.basename;; (JSIdentifier) basename						local.get $basename						i32.const 4						i32.mul						i32.add						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!children) {return false};; (UnaryExpression) !children;; (JSIdentifier) children						local.get $children						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ForInStatement) an active ForInStatement with properties...						;; unwritable: (ExpressionStatement) delete directory[path.basename]						;; unwritable: (ExpressionStatement) localStorage['squeak:' + path.dirname] =						;; unwritable: (ExpressionStatement) delete localStorage['squeak:' + path.ful;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: dirList -> function(dirpath, i...;; (FunctionExpression) function(dirpath, includeTemplates) { 	v...(func $dirList						(local $temp i32)						(local $dir i32)						(local $path i32)						(local $localEntries i32)						(local $template i32)						(local $includeTemplates i32)						(local $key i32)						(local $dirpath i32)						(local $entry i32);; (FunctionDeclaration) function addEntries(dir, entries) {an ac...;; (FunctionExpression) function(dir, entries) { 	an active ForI...(func $addEntries	(local $key i32)	(local $dir i32)	(local $temp i32)	(local $entry i32)	(local $entries i32)	;; (ForInStatement) an active ForInStatement with properties...)												;; unwritable: (IfStatement) if (localEntries || template) {var dir =						;; unwritable: (IfStatement) if (path.fullname == '/') {return {}};; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return);; (JSProperty) property: splitFilePath -> function(file...;; (FunctionExpression) function(filepath) { 	if (filepath[0] !=...(func $splitFilePath						(local $dirname i32)						(local $matches i32)						(local $temp i32)						(local $basename i32)						(local $filepath i32)												;; unwritable: (IfStatement) if (filepath[0] !== '/') {filepath = '/'						;; unwritable: (ExpressionStatement) filepath = filepath.replace(/\/\//g, '/';; (ReturnStatement) return {property: fullname -> filepath, ...;; (ObjectExpression) {property: fullname -> filepath, propert...						return);; (JSProperty) property: splitUrl -> function(url, base...;; (FunctionExpression) function(url, base) { 	var matches = url...(func $splitUrl						(local $uptoslash i32)						(local $filename i32)						(local $url i32)						(local $matches i32)						(local $base i32)						(local $temp i32)												;; unwritable: (IfStatement) if (!uptoslash.match(/^[a-z]+:\/\//)) {i;; (ReturnStatement) return {property: full -> url, property:...;; (ObjectExpression) {property: full -> url, property: uptosl...						return);; (JSProperty) property: flushFile -> function(file) { ...;; (FunctionExpression) function(file) { 	if (file.modified) {va...(func $flushFile						(local $temp i32)						(local $buffer i32)						(local $file i32)												;; unwritable: (IfStatement) if (file.modified) {var buffer = file.co);; (JSProperty) property: flushAllFiles -> function() { ...;; (FunctionExpression) function() { 	if (typeof SqueakFiles == ...(func $flushAllFiles						(local $name i32)						(local $temp i32)												;; unwritable: (IfStatement) if (typeof SqueakFiles == 'undefined') {;; (ForInStatement) an active ForInStatement with properties...);; (JSProperty) property: closeAllFiles -> function() { ...;; (FunctionExpression) function() { 	Squeak.flushAllFiles() del...(func $closeAllFiles						(local $temp i32)												;; unwritable: (ExpressionStatement) Squeak.flushAllFiles()						;; unwritable: (ExpressionStatement) delete self.SqueakFiles);; (JSProperty) property: fetchTemplateDir -> function(p...;; (FunctionExpression) function(path, url) { 	path = Squeak.spl...(func $fetchTemplateDir						(local $temp i32)						(local $url i32)						(local $path i32)						(local $rq i32)						(local $now i32)						(local $template i32)						(local $index i32)						(local $key i32)						(local $entry i32);; (FunctionDeclaration) function ensureTemplateParent(template) ...;; (FunctionExpression) function(template) { 	var path = Squeak....(func $ensureTemplateParent	(local $now i32)	(local $temp i32)	(local $template i32)	(local $path i32)		;; unwritable: (IfStatement) if (path.dirname !== '/') {ensureTemplat	;; unwritable: (IfStatement) if (!template.entries[path.basename]) {v);; (FunctionDeclaration) function checkSubTemplates(path, url) {v...;; (FunctionExpression) function(path, url) { 	var template = JS...(func $checkSubTemplates	(local $key i32)	(local $url i32)	(local $path i32)	(local $template i32)	(local $temp i32)	(local $entry i32)	;; (ForInStatement) an active ForInStatement with properties...;; (EmptyStatement) )												;; unwritable: (ExpressionStatement) path = Squeak.splitFilePath(path).fullna						;; unwritable: (IfStatement) if (localStorage['squeak-template:' + pa);; (JSProperty) property: fetchTemplateFile -> function(...;; (FunctionExpression) function(path, ifFound, ifNotFound) { 	p...(func $fetchTemplateFile						(local $rq i32)						(local $ifFound i32)						(local $ifNotFound i32)						(local $path i32)						(local $template i32)						(local $url i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) path = Squeak.splitFilePath(path);; (IfStatement) if (!template) {return ifNotFound()};; (UnaryExpression) !template;; (JSIdentifier) template						local.get $template						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return ifNotFound();; (CallExpression) ifNotFound()						call $ifNotFound						return));; (IfStatement) if (!url) {return ifNotFound()};; (UnaryExpression) !url;; (JSIdentifier) url						local.get $url						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return ifNotFound();; (CallExpression) ifNotFound()						call $ifNotFound						return))						;; unwritable: (ExpressionStatement) url += '/' + path.basename						;; unwritable: (ExpressionStatement) rq.open('get', url, true)						;; unwritable: (ExpressionStatement) rq.responseType = 'arraybuffer';; (ExpressionStatement) rq.timeout = 30000;; (AssignmentExpression) rq.timeout = 30000;; (JSLiteral) 30000						i32.const 30000						local.set $timeout;; (ExpressionStatement) rq.onreadystatechange = function() { 	if...;; (AssignmentExpression) rq.onreadystatechange = function() { 	if...;; (FunctionExpression) function() { 	if (this.readyState != thi...(func $nil						(local $buffer i32)						(local $temp i32)						;; (IfStatement) if (this.readyState != this.DONE) {retur...;; (BinaryExpression) this.readyState != this.DONE;; (StaticMemberExpression) this.readyState;; (JSIdentifier) readyState						local.get $readyState;; (StaticMemberExpression) this.DONE;; (JSIdentifier) DONE						local.get $DONE						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 						return))						;; unwritable: (IfStatement) if (this.status == 200) {var buffer = th)						local.set $onreadystatechange						;; unwritable: (ExpressionStatement) console.log('Fetching ' + url);; (ExpressionStatement) rq.send();; (CallExpression) rq.send()						local.get $rq						call $send);; (JSProperty) property: startAudioOut -> function() { ...;; (FunctionExpression) function() { 	if (!this.audioOutContext)...(func $startAudioOut						(local $ctxProto i32)						(local $temp i32)						;; (IfStatement) if (!this.audioOutContext) {var ctxProto...;; (UnaryExpression) !this.audioOutContext;; (StaticMemberExpression) this.audioOutContext;; (JSIdentifier) audioOutContext						local.get $audioOutContext						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) var ctxProto = self.AudioContext || self...;; (VariableDeclaration) var ctxProto = self.AudioContext || self...;; (VariableDeclarator) ctxProto = self.AudioContext || self.web...;; (BinaryExpression) self.AudioContext || self.webkitAudioCon...;; (BinaryExpression) self.AudioContext || self.webkitAudioCon...;; (BinaryExpression) self.AudioContext || self.webkitAudioCon...;; (StaticMemberExpression) self.AudioContext;; (JSIdentifier) AudioContext						local.get $AudioContext;; (StaticMemberExpression) self.webkitAudioContext;; (JSIdentifier) webkitAudioContext						local.get $webkitAudioContext						i32.or;; (StaticMemberExpression) self.mozAudioContext;; (JSIdentifier) mozAudioContext						local.get $mozAudioContext						i32.or;; (StaticMemberExpression) self.msAudioContext;; (JSIdentifier) msAudioContext						local.get $msAudioContext						i32.or						local.set $ctxProto;; (ExpressionStatement) this.audioOutContext = ctxProto && new c...;; (AssignmentExpression) this.audioOutContext = ctxProto && new c...;; (BinaryExpression) ctxProto && new ctxProto();; (JSIdentifier) ctxProto						local.get $ctxProto;; (NewExpression) new ctxProto()						unreachable						i32.and						local.set $audioOutContext));; (ReturnStatement) return this.audioOutContext;; (StaticMemberExpression) this.audioOutContext;; (JSIdentifier) audioOutContext						local.get $audioOutContext						return);; (JSProperty) property: startAudioIn -> function(thenD...;; (FunctionExpression) function(thenDo, errorDo) { 	if (this.au...(func $startAudioIn						(local $thenDo i32)						(local $errorDo i32)						(local $temp i32)						;; (IfStatement) if (this.audioInContext) {this.audioInSo...;; (StaticMemberExpression) this.audioInContext;; (JSIdentifier) audioInContext						local.get $audioInContext						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.audioInSource.disconnect() return t...;; (ExpressionStatement) this.audioInSource.disconnect();; (CallExpression) this.audioInSource.disconnect()						local.get $audioInSource						call $disconnect;; (ReturnStatement) return thenDo(this.audioInContext, this....;; (CallExpression) thenDo(this.audioInContext, this.audioIn...;; (StaticMemberExpression) this.audioInContext;; (JSIdentifier) audioInContext						local.get $audioInContext;; (StaticMemberExpression) this.audioInSource;; (JSIdentifier) audioInSource						local.get $audioInSource						call $thenDo						return))						;; unwritable: (ExpressionStatement) navigator.getUserMedia = navigator.getUs						;; unwritable: (IfStatement) if (!navigator.getUserMedia) {return err						;; unwritable: (ExpressionStatement) navigator.getUserMedia({property: audio );; (JSProperty) property: stopAudio -> function() { 	if ...;; (FunctionExpression) function() { 	if (this.audioInSource) {t...(func $stopAudio						(local $temp i32)						;; (IfStatement) if (this.audioInSource) {this.audioInSou...;; (StaticMemberExpression) this.audioInSource;; (JSIdentifier) audioInSource						local.get $audioInSource						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.audioInSource.disconnect();; (CallExpression) this.audioInSource.disconnect()						local.get $audioInSource						call $disconnect)));; (JSProperty) property: Epoch -> Date.UTC(1901, 0, 1) ...;; (JSProperty) property: EpochUTC -> Date.UTC(1901, 0, ...;; (JSProperty) property: totalSeconds -> function() { 	...;; (FunctionExpression) function() { 	return Math.floor(Date.now...(func $totalSeconds						(local $temp i32)												;; unwritable: (ReturnStatement) return Math.floor(Date.now() - Squeak.Ep);; (JSProperty) property: bytesAsString -> function(byte...;; (FunctionExpression) function(bytes) { 	var chars = [] for (v...(func $bytesAsString						(local $bytes i32)						(local $i i32)						(local $chars i32)						(local $temp i32)												;; unwritable: (ForStatement) for (var i = 0; i < bytes.length; i++) {						;; unwritable: (ReturnStatement) return chars.join(''));; (JSProperty) property: about -> function() { 	};; (FunctionExpression) function() { 	}(func $about						(local $temp i32)						);; (JSProperty) property: initialize -> function(name) {...;; (FunctionExpression) function(name) { 	this.topmostScope = se...(func $initialize						(local $name i32)						(local $temp i32)						;; (ExpressionStatement) this.topmostScope = self;; (AssignmentExpression) this.topmostScope = self;; (JSIdentifier) self						local.get $self						local.set $topmostScope;; (ExpressionStatement) this.totalMemory = 150000000;; (AssignmentExpression) this.totalMemory = 150000000;; (JSLiteral) 150000000						i32.const 150000000						local.set $totalMemory;; (ExpressionStatement) this.name = name;; (AssignmentExpression) this.name = name;; (JSIdentifier) name						local.get $name						local.set $name;; (ExpressionStatement) this.gcCount = 0;; (AssignmentExpression) this.gcCount = 0;; (JSLiteral) 0						i32.const 0						local.set $gcCount;; (ExpressionStatement) this.gcMilliseconds = 0;; (AssignmentExpression) this.gcMilliseconds = 0;; (JSLiteral) 0						i32.const 0						local.set $gcMilliseconds;; (ExpressionStatement) this.pgcCount = 0;; (AssignmentExpression) this.pgcCount = 0;; (JSLiteral) 0						i32.const 0						local.set $pgcCount;; (ExpressionStatement) this.pgcMilliseconds = 0;; (AssignmentExpression) this.pgcMilliseconds = 0;; (JSLiteral) 0						i32.const 0						local.set $pgcMilliseconds;; (ExpressionStatement) this.gcTenured = 0;; (AssignmentExpression) this.gcTenured = 0;; (JSLiteral) 0						i32.const 0						local.set $gcTenured;; (ExpressionStatement) this.allocationCount = 0;; (AssignmentExpression) this.allocationCount = 0;; (JSLiteral) 0						i32.const 0						local.set $allocationCount;; (ExpressionStatement) this.oldSpaceCount = 0;; (AssignmentExpression) this.oldSpaceCount = 0;; (JSLiteral) 0						i32.const 0						local.set $oldSpaceCount;; (ExpressionStatement) this.youngSpaceCount = 0;; (AssignmentExpression) this.youngSpaceCount = 0;; (JSLiteral) 0						i32.const 0						local.set $youngSpaceCount;; (ExpressionStatement) this.newSpaceCount = 0;; (AssignmentExpression) this.newSpaceCount = 0;; (JSLiteral) 0						i32.const 0						local.set $newSpaceCount;; (ExpressionStatement) this.hasNewInstances = {};; (AssignmentExpression) this.hasNewInstances = {};; (ObjectExpression) {}						local.set $hasNewInstances);; (JSProperty) property: readFromBuffer -> function(arr...;; (FunctionExpression) function(arraybuffer, thenDo, progressDo...(func $readFromBuffer						(local $deltaWordsHi i32)						(local $arraybuffer i32)						(local $_splObs i32)						(local $floatClass i32)						(local $oop i32)						(local $deltaBytes i32)						(local $size i32)						(local $objectMemorySize i32)						(local $firstSegSize i32)						(local $specialObjectsOopInt i32)						(local $progressDo i32)						(local $object i32)						(local $headerSize i32)						(local $cc i32)						(local $renamedObj i32)						(local $classID i32)						(local $segmentBytes i32)						(local $charClass i32)						(local $objPos i32)						(local $sizeAndHash i32)						(local $bits i32)						(local $imageHeaderSize i32)						(local $data i32)						(local $segmentEnd i32)						(local $format i32)						(local $splObs i32)						(local $readWord i32)						(local $thenDo i32)						(local $oldBaseAddr i32)						(local $header i32)						(local $fileHeaderSize i32)						(local $segmentBytesHi i32)						(local $obj i32)						(local $rawBits i32)						(local $i i32)						(local $freePageList i32)						(local $hash i32)						(local $addressOffset i32)						(local $stop i32)						(local $classPages i32)						(local $version i32)						(local $readBits i32)						(local $nWords i32)						(local $oopAdjust i32)						(local $temp i32)						(local $prevObj i32)						(local $formatAndClass i32)						(local $done i32)						(local $compactClasses i32)						(local $topmostScope i32)						(local $classInt i32)						(local $oopMap i32)						(local $self i32)						(local $pos i32)						(local $deltaWords i32)						(local $nativeFloats i32)						(local $littleEndian i32)						(local $versions i32)						(local $skippedBytes i32);; (FunctionDeclaration) function mapSomeObjects() {if (obj) {var...;; (FunctionExpression) function() { 	if (obj) {var stop = done ...(func $mapSomeObjects	(local $stop i32)	(local $temp i32)	;; (IfStatement) if (obj) {var stop = done + self.oldSpac...;; (JSIdentifier) obj						local.get $obj						i32.const 0						i32.ne						(if (then;; (BlockStatement) var stop = done + self.oldSpaceCount / 2...;; (VariableDeclaration) var stop = done + self.oldSpaceCount / 2...;; (VariableDeclarator) stop = done + self.oldSpaceCount / 20 | ...;; (BinaryExpression) done + self.oldSpaceCount / 20 | 0;; (JSIdentifier) done						local.get $done;; (BinaryExpression) self.oldSpaceCount / 20 | 0;; (BinaryExpression) self.oldSpaceCount / 20;; (StaticMemberExpression) self.oldSpaceCount;; (JSIdentifier) oldSpaceCount						local.get $oldSpaceCount;; (JSLiteral) 20						i32.const 20						i32.div_s;; (JSLiteral) 0						i32.const 0						i32.or						i32.add						local.set $stop;; (WhileStatement) while (obj && done < stop) {obj.installF...						(loop $loop_1;; (BlockStatement) obj.installFromImage(oopMap, rawBits, co...;; (ExpressionStatement) obj.installFromImage(oopMap, rawBits, co...;; (CallExpression) obj.installFromImage(oopMap, rawBits, co...						local.get $obj;; (JSIdentifier) oopMap						local.get $oopMap;; (JSIdentifier) rawBits						local.get $rawBits;; (JSIdentifier) compactClasses						local.get $compactClasses;; (JSIdentifier) floatClass						local.get $floatClass;; (JSIdentifier) littleEndian						local.get $littleEndian;; (JSIdentifier) nativeFloats						local.get $nativeFloats						call $installFromImage;; (ExpressionStatement) obj = obj.nextObject;; (AssignmentExpression) obj = obj.nextObject;; (StaticMemberExpression) obj.nextObject;; (JSIdentifier) nextObject						local.get $nextObject						local.set $obj;; (ExpressionStatement) done++;; (UpdateExpression) done++;; (JSIdentifier) done						local.get $done						i32.const 1						i32.add;; (BinaryExpression) obj && done < stop;; (JSIdentifier) obj						local.get $obj;; (BinaryExpression) done < stop;; (JSIdentifier) done						local.get $done;; (JSIdentifier) stop						local.get $stop						i32.lt_u						i32.and						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (IfStatement) if (progressDo) {progressDo(done / self....;; (JSIdentifier) progressDo						local.get $progressDo						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) progressDo(done / self.oldSpaceCount);; (CallExpression) progressDo(done / self.oldSpaceCount);; (BinaryExpression) done / self.oldSpaceCount;; (JSIdentifier) done						local.get $done;; (StaticMemberExpression) self.oldSpaceCount;; (JSIdentifier) oldSpaceCount						local.get $oldSpaceCount						i32.div_s						call $progressDo));; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return)						(else;; (BlockStatement) self.specialObjectsArray = splObs self.d...;; (ExpressionStatement) self.specialObjectsArray = splObs;; (AssignmentExpression) self.specialObjectsArray = splObs;; (JSIdentifier) splObs						local.get $splObs						local.set $specialObjectsArray;; (ExpressionStatement) self.decorateKnownObjects();; (CallExpression) self.decorateKnownObjects()						local.get $self						call $decorateKnownObjects;; (IfStatement) if (self.isSpur) {self.fixSkippedOops(oo...;; (StaticMemberExpression) self.isSpur;; (JSIdentifier) isSpur						local.get $isSpur						i32.const 0						i32.ne						(if (then;; (BlockStatement) self.fixSkippedOops(oopAdjust) ;; (ExpressionStatement) self.fixSkippedOops(oopAdjust);; (CallExpression) self.fixSkippedOops(oopAdjust)						local.get $self;; (JSIdentifier) oopAdjust						local.get $oopAdjust						call $fixSkippedOops)						(else;; (BlockStatement) self.fixCompiledMethods() self.fixCompac...;; (ExpressionStatement) self.fixCompiledMethods();; (CallExpression) self.fixCompiledMethods()						local.get $self						call $fixCompiledMethods;; (ExpressionStatement) self.fixCompactOops();; (CallExpression) self.fixCompactOops()						local.get $self						call $fixCompactOops));; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return)));; (FunctionDeclaration) function mapSomeObjectsAsync() {if (mapS...;; (FunctionExpression) function() { 	if (mapSomeObjects()) {thi...(func $mapSomeObjectsAsync	(local $temp i32)	;; (IfStatement) if (mapSomeObjects()) {this.setTimeout(m...;; (CallExpression) mapSomeObjects()						call $mapSomeObjects						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.setTimeout(mapSomeObjectsAsync, 0) ;; (ExpressionStatement) this.setTimeout(mapSomeObjectsAsync, 0);; (CallExpression) this.setTimeout(mapSomeObjectsAsync, 0)						local.get $this;; (JSIdentifier) mapSomeObjectsAsync						local.get $mapSomeObjectsAsync;; (JSLiteral) 0						i32.const 0						call $setTimeout)						(else;; (BlockStatement) if (thenDo) {thenDo()} ;; (IfStatement) if (thenDo) {thenDo()};; (JSIdentifier) thenDo						local.get $thenDo						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) thenDo();; (CallExpression) thenDo()						call $thenDo)))))												;; unwritable: (ExpressionStatement) console.log('squeak: reading ' + this.na						;; unwritable: (ExpressionStatement) this.startupTime = Date.now();; (WhileStatement) while (true) {littleEndian = !littleEndi...						(loop $loop_2;; (BlockStatement) littleEndian = !littleEndian pos = fileH...;; (ExpressionStatement) littleEndian = !littleEndian;; (AssignmentExpression) littleEndian = !littleEndian;; (UnaryExpression) !littleEndian;; (JSIdentifier) littleEndian						local.get $littleEndian						local.set $temp						i32.const -1						local.get $temp						i32.sub						local.set $littleEndian;; (ExpressionStatement) pos = fileHeaderSize;; (AssignmentExpression) pos = fileHeaderSize;; (JSIdentifier) fileHeaderSize						local.get $fileHeaderSize						local.set $pos;; (ExpressionStatement) version = readWord();; (AssignmentExpression) version = readWord();; (CallExpression) readWord()						call $readWord						local.set $version;; (IfStatement) if (versions.indexOf(version) >= 0) {bre...;; (BinaryExpression) versions.indexOf(version) >= 0;; (CallExpression) versions.indexOf(version)						local.get $versions;; (JSIdentifier) version						local.get $version						call $indexOf;; (JSLiteral) 0						i32.const 0						i32.ge_u						i32.const 0						i32.ne						(if (then;; (BreakStatement) break						br $loop_2_continue));; (JSLiteral) true						i32.const 1						i32.const 0						i32.eq						br_if $loop_2)						(block $loop_2_continue);; (EmptyStatement) ;; (ExpressionStatement) this.version = version;; (AssignmentExpression) this.version = version;; (JSIdentifier) version						local.get $version						local.set $version						;; unwritable: (ExpressionStatement) this.hasClosures = [6504, 6505, 6521, 68						;; unwritable: (ExpressionStatement) this.isSpur = [6521, 68021].indexOf(vers;; (IfStatement) if (version >= 68000) {throw Error('64 b...;; (BinaryExpression) version >= 68000;; (JSIdentifier) version						local.get $version;; (JSLiteral) 68000						i32.const 68000						i32.ge_u						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('64 bit images not supported...						unreachable));; (ExpressionStatement) this.lastHash = readWord();; (AssignmentExpression) this.lastHash = readWord();; (CallExpression) readWord()						call $readWord						local.set $lastHash						;; unwritable: (ExpressionStatement) this.savedHeaderWords = [];; (ForStatement) for (var i = 0; i < 6; i++) {this.savedH...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_3;; (ExpressionStatement) this.savedHeaderWords.push(readWord());; (CallExpression) this.savedHeaderWords.push(readWord())						local.get $savedHeaderWords;; (CallExpression) readWord()						call $readWord						call $push;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < 6;; (JSIdentifier) i						local.get $i;; (JSLiteral) 6						i32.const 6						i32.lt_u						i32.const 0						br_if $loop_3);; (ExpressionStatement) pos = headerSize;; (AssignmentExpression) pos = headerSize;; (JSIdentifier) headerSize						local.get $headerSize						local.set $pos;; (IfStatement) if (!this.isSpur) {while (pos < headerSi...;; (UnaryExpression) !this.isSpur;; (StaticMemberExpression) this.isSpur;; (JSIdentifier) isSpur						local.get $isSpur						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) while (pos < headerSize + objectMemorySi...;; (WhileStatement) while (pos < headerSize + objectMemorySi...						(loop $loop_4;; (BlockStatement) var nWords = 0 var classInt = 0 var head...;; (VariableDeclaration) var nWords = 0;; (VariableDeclarator) nWords = 0;; (JSLiteral) 0						i32.const 0						local.set $nWords;; (VariableDeclaration) var classInt = 0;; (VariableDeclarator) classInt = 0;; (JSLiteral) 0						i32.const 0						local.set $classInt;; (VariableDeclaration) var header = readWord();; (VariableDeclarator) header = readWord();; (CallExpression) readWord()						call $readWord						local.set $header;; (SwitchStatement) switch (header & Squeak.HeaderTypeMask) ...header & Squeak.HeaderTypeMask						local.set $temp;; (SwitchCase)  case Squeak.HeaderTypeSizeAndClass: nWo...						local.get $temp;; (StaticMemberExpression) Squeak.HeaderTypeSizeAndClass;; (JSIdentifier) HeaderTypeSizeAndClass						local.get $HeaderTypeSizeAndClass						i32.eq						(if (then ;; (ExpressionStatement) nWords = header >>> 2;; (AssignmentExpression) nWords = header >>> 2;; (BinaryExpression) header >>> 2;; (JSIdentifier) header						local.get $header;; (JSLiteral) 2						i32.const 2						i32.shr_u						local.set $nWords;; (ExpressionStatement) classInt = readWord();; (AssignmentExpression) classInt = readWord();; (CallExpression) readWord()						call $readWord						local.set $classInt;; (ExpressionStatement) header = readWord();; (AssignmentExpression) header = readWord();; (CallExpression) readWord()						call $readWord						local.set $header;; (BreakStatement) break						));; (SwitchCase)  case Squeak.HeaderTypeClass: classInt =...						local.get $temp;; (StaticMemberExpression) Squeak.HeaderTypeClass;; (JSIdentifier) HeaderTypeClass						local.get $HeaderTypeClass						i32.eq						(if (then ;; (ExpressionStatement) classInt = header - Squeak.HeaderTypeCla...;; (AssignmentExpression) classInt = header - Squeak.HeaderTypeCla...;; (BinaryExpression) header - Squeak.HeaderTypeClass;; (JSIdentifier) header						local.get $header;; (StaticMemberExpression) Squeak.HeaderTypeClass;; (JSIdentifier) HeaderTypeClass						local.get $HeaderTypeClass						i32.sub						local.set $classInt;; (ExpressionStatement) header = readWord();; (AssignmentExpression) header = readWord();; (CallExpression) readWord()						call $readWord						local.set $header;; (ExpressionStatement) nWords = header >>> 2 & 63;; (AssignmentExpression) nWords = header >>> 2 & 63;; (BinaryExpression) header >>> 2 & 63;; (BinaryExpression) header >>> 2;; (JSIdentifier) header						local.get $header;; (JSLiteral) 2						i32.const 2						i32.shr_u;; (JSLiteral) 63						i32.const 63						i32.and						local.set $nWords;; (BreakStatement) break						));; (SwitchCase)  case Squeak.HeaderTypeShort: nWords = h...						local.get $temp;; (StaticMemberExpression) Squeak.HeaderTypeShort;; (JSIdentifier) HeaderTypeShort						local.get $HeaderTypeShort						i32.eq						(if (then ;; (ExpressionStatement) nWords = header >>> 2 & 63;; (AssignmentExpression) nWords = header >>> 2 & 63;; (BinaryExpression) header >>> 2 & 63;; (BinaryExpression) header >>> 2;; (JSIdentifier) header						local.get $header;; (JSLiteral) 2						i32.const 2						i32.shr_u;; (JSLiteral) 63						i32.const 63						i32.and						local.set $nWords;; (ExpressionStatement) classInt = header >>> 12 & 31;; (AssignmentExpression) classInt = header >>> 12 & 31;; (BinaryExpression) header >>> 12 & 31;; (BinaryExpression) header >>> 12;; (JSIdentifier) header						local.get $header;; (JSLiteral) 12						i32.const 12						i32.shr_u;; (JSLiteral) 31						i32.const 31						i32.and						local.set $classInt;; (BreakStatement) break						));; (SwitchCase)  case Squeak.HeaderTypeFree: throw Error...						local.get $temp;; (StaticMemberExpression) Squeak.HeaderTypeFree;; (JSIdentifier) HeaderTypeFree						local.get $HeaderTypeFree						i32.eq						(if (then ;; (ThrowStatement) throw Error('Unexpected free block')						unreachable						));; (ExpressionStatement) nWords--;; (UpdateExpression) nWords--;; (JSIdentifier) nWords						local.get $nWords						i32.const 1						i32.sub;; (VariableDeclaration) var oop = pos - 4 - headerSize, format =...;; (VariableDeclarator) oop = pos - 4 - headerSize;; (BinaryExpression) pos - 4 - headerSize;; (BinaryExpression) pos - 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.sub;; (JSIdentifier) headerSize						local.get $headerSize						i32.sub						local.set $oop;; (VariableDeclarator) format = header >>> 8 & 15;; (BinaryExpression) header >>> 8 & 15;; (BinaryExpression) header >>> 8;; (JSIdentifier) header						local.get $header;; (JSLiteral) 8						i32.const 8						i32.shr_u;; (JSLiteral) 15						i32.const 15						i32.and						local.set $format;; (VariableDeclarator) hash = header >>> 17 & 4095;; (BinaryExpression) header >>> 17 & 4095;; (BinaryExpression) header >>> 17;; (JSIdentifier) header						local.get $header;; (JSLiteral) 17						i32.const 17						i32.shr_u;; (JSLiteral) 4095						i32.const 4095						i32.and						local.set $hash;; (VariableDeclarator) bits = readBits(nWords, format < 5);; (CallExpression) readBits(nWords, format < 5);; (JSIdentifier) nWords						local.get $nWords;; (BinaryExpression) format < 5;; (JSIdentifier) format						local.get $format;; (JSLiteral) 5						i32.const 5						i32.lt_u						call $readBits						local.set $bits;; (VariableDeclaration) var object = new Squeak.Object();; (VariableDeclarator) object = new Squeak.Object();; (NewExpression) new Squeak.Object()						unreachable						local.set $object;; (ExpressionStatement) object.initFromImage(oop, classInt, form...;; (CallExpression) object.initFromImage(oop, classInt, form...						local.get $object;; (JSIdentifier) oop						local.get $oop;; (JSIdentifier) classInt						local.get $classInt;; (JSIdentifier) format						local.get $format;; (JSIdentifier) hash						local.get $hash						call $initFromImage;; (IfStatement) if (classInt < 32) {object.hash |= 26843...;; (BinaryExpression) classInt < 32;; (JSIdentifier) classInt						local.get $classInt;; (JSLiteral) 32						i32.const 32						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) object.hash |= 268435456;; (AssignmentExpression) object.hash |= 268435456;; (StaticMemberExpression) object.hash;; (JSIdentifier) hash						local.get $hash;; (JSLiteral) 268435456						i32.const 268435456						i32.sub						local.set $hash));; (IfStatement) if (prevObj) {prevObj.nextObject = objec...;; (JSIdentifier) prevObj						local.get $prevObj						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) prevObj.nextObject = object;; (AssignmentExpression) prevObj.nextObject = object;; (JSIdentifier) object						local.get $object						local.set $nextObject));; (ExpressionStatement) this.oldSpaceCount++;; (UpdateExpression) this.oldSpaceCount++;; (StaticMemberExpression) this.oldSpaceCount;; (JSIdentifier) oldSpaceCount						local.get $oldSpaceCount						i32.const 1						i32.add;; (ExpressionStatement) prevObj = object;; (AssignmentExpression) prevObj = object;; (JSIdentifier) object						local.get $object						local.set $prevObj;; (ExpressionStatement) oopMap[oldBaseAddr + oop] = object;; (AssignmentExpression) oopMap[oldBaseAddr + oop] = object						local.get $'oopMap';; (BinaryExpression) oldBaseAddr + oop;; (JSIdentifier) oldBaseAddr						local.get $oldBaseAddr;; (JSIdentifier) oop						local.get $oop						i32.add;; (JSIdentifier) object						local.get $object						call $atPut;; (ExpressionStatement) rawBits[oop] = bits;; (AssignmentExpression) rawBits[oop] = bits						local.get $'rawBits';; (JSIdentifier) oop						local.get $oop;; (JSIdentifier) bits						local.get $bits						call $atPut;; (BinaryExpression) pos < headerSize + objectMemorySize;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) headerSize + objectMemorySize;; (JSIdentifier) headerSize						local.get $headerSize;; (JSIdentifier) objectMemorySize						local.get $objectMemorySize						i32.add						i32.lt_u						i32.const 0						i32.eq						br_if $loop_4)						(block $loop_4_continue);; (ExpressionStatement) this.firstOldObject = oopMap[oldBaseAddr...;; (AssignmentExpression) this.firstOldObject = oopMap[oldBaseAddr...;; (ComputedMemberExpression) oopMap[oldBaseAddr + 4];; (JSIdentifier) oopMap						local.get $oopMap;; (BinaryExpression) oldBaseAddr + 4;; (JSIdentifier) oldBaseAddr						local.get $oldBaseAddr;; (JSLiteral) 4						i32.const 4						i32.add						i32.const 4						i32.mul						i32.add						local.set $firstOldObject;; (ExpressionStatement) this.lastOldObject = object;; (AssignmentExpression) this.lastOldObject = object;; (JSIdentifier) object						local.get $object						local.set $lastOldObject;; (ExpressionStatement) this.oldSpaceBytes = objectMemorySize;; (AssignmentExpression) this.oldSpaceBytes = objectMemorySize;; (JSIdentifier) objectMemorySize						local.get $objectMemorySize						local.set $oldSpaceBytes)						(else;; (BlockStatement) this.oldSpaceBytes = firstSegSize - 16 v...;; (ExpressionStatement) this.oldSpaceBytes = firstSegSize - 16;; (AssignmentExpression) this.oldSpaceBytes = firstSegSize - 16;; (BinaryExpression) firstSegSize - 16;; (JSIdentifier) firstSegSize						local.get $firstSegSize;; (JSLiteral) 16						i32.const 16						i32.sub						local.set $oldSpaceBytes;; (VariableDeclaration) var segmentEnd = pos + firstSegSize, add...;; (VariableDeclarator) segmentEnd = pos + firstSegSize;; (BinaryExpression) pos + firstSegSize;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) firstSegSize						local.get $firstSegSize						i32.add						local.set $segmentEnd;; (VariableDeclarator) addressOffset = 0;; (JSLiteral) 0						i32.const 0						local.set $addressOffset;; (VariableDeclarator) freePageList = nil;; (JSLiteral) nil						i32.const 0						local.set $freePageList;; (VariableDeclarator) classPages = nil;; (JSLiteral) nil						i32.const 0						local.set $classPages;; (VariableDeclarator) skippedBytes = 0;; (JSLiteral) 0						i32.const 0						local.set $skippedBytes;; (VariableDeclarator) oopAdjust = {};; (ObjectExpression) {}						local.set $oopAdjust;; (WhileStatement) while (pos < segmentEnd) {while (pos < s...						(loop $loop_5;; (BlockStatement) while (pos < segmentEnd - 16) {var objPo...;; (WhileStatement) while (pos < segmentEnd - 16) {var objPo...						(loop $loop_6;; (BlockStatement) var objPos = pos, formatAndClass = readW...;; (VariableDeclaration) var objPos = pos, formatAndClass = readW...;; (VariableDeclarator) objPos = pos;; (JSIdentifier) pos						local.get $pos						local.set $objPos;; (VariableDeclarator) formatAndClass = readWord();; (CallExpression) readWord()						call $readWord						local.set $formatAndClass;; (VariableDeclarator) sizeAndHash = readWord();; (CallExpression) readWord()						call $readWord						local.set $sizeAndHash;; (VariableDeclarator) size = sizeAndHash >>> 24;; (BinaryExpression) sizeAndHash >>> 24;; (JSIdentifier) sizeAndHash						local.get $sizeAndHash;; (JSLiteral) 24						i32.const 24						i32.shr_u						local.set $size;; (IfStatement) if (size === 255) {size = formatAndClass...;; (BinaryExpression) size === 255;; (JSIdentifier) size						local.get $size;; (JSLiteral) 255						i32.const 255						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) size = formatAndClass formatAndClass = r...;; (ExpressionStatement) size = formatAndClass;; (AssignmentExpression) size = formatAndClass;; (JSIdentifier) formatAndClass						local.get $formatAndClass						local.set $size;; (ExpressionStatement) formatAndClass = readWord();; (AssignmentExpression) formatAndClass = readWord();; (CallExpression) readWord()						call $readWord						local.set $formatAndClass;; (ExpressionStatement) sizeAndHash = readWord();; (AssignmentExpression) sizeAndHash = readWord();; (CallExpression) readWord()						call $readWord						local.set $sizeAndHash));; (VariableDeclaration) var oop = addressOffset + pos - 8 - head...;; (VariableDeclarator) oop = addressOffset + pos - 8 - headerSi...;; (BinaryExpression) addressOffset + pos - 8 - headerSize;; (BinaryExpression) addressOffset + pos - 8;; (BinaryExpression) addressOffset + pos;; (JSIdentifier) addressOffset						local.get $addressOffset;; (JSIdentifier) pos						local.get $pos						i32.add;; (JSLiteral) 8						i32.const 8						i32.sub;; (JSIdentifier) headerSize						local.get $headerSize						i32.sub						local.set $oop;; (VariableDeclarator) format = formatAndClass >>> 24 & 31;; (BinaryExpression) formatAndClass >>> 24 & 31;; (BinaryExpression) formatAndClass >>> 24;; (JSIdentifier) formatAndClass						local.get $formatAndClass;; (JSLiteral) 24						i32.const 24						i32.shr_u;; (JSLiteral) 31						i32.const 31						i32.and						local.set $format;; (VariableDeclarator) classID = formatAndClass & 4194303;; (BinaryExpression) formatAndClass & 4194303;; (JSIdentifier) formatAndClass						local.get $formatAndClass;; (JSLiteral) 4194303						i32.const 4194303						i32.and						local.set $classID;; (VariableDeclarator) hash = sizeAndHash & 4194303;; (BinaryExpression) sizeAndHash & 4194303;; (JSIdentifier) sizeAndHash						local.get $sizeAndHash;; (JSLiteral) 4194303						i32.const 4194303						i32.and						local.set $hash;; (VariableDeclaration) var bits = readBits(size, format < 10 &&...;; (VariableDeclarator) bits = readBits(size, format < 10 && cla...;; (CallExpression) readBits(size, format < 10 && classID > ...;; (JSIdentifier) size						local.get $size;; (BinaryExpression) format < 10 && classID > 0;; (BinaryExpression) format < 10;; (JSIdentifier) format						local.get $format;; (JSLiteral) 10						i32.const 10						i32.lt_u;; (BinaryExpression) classID > 0;; (JSIdentifier) classID						local.get $classID;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.and						call $readBits						local.set $bits;; (ExpressionStatement) pos += size < 2 ? 2 - size : size & 1 * ...;; (AssignmentExpression) pos += size < 2 ? 2 - size : size & 1 * ...;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) size < 2 ? 2 - size : size & 1 * 4;; (ConditionalExpression) size < 2 ? 2 - size : size & 1;; (BinaryExpression) size < 2;; (JSIdentifier) size						local.get $size;; (JSLiteral) 2						i32.const 2						i32.lt_u						i32.const 1						i32.eq						(if (then;; (BinaryExpression) 2 - size;; (JSLiteral) 2						i32.const 2;; (JSIdentifier) size						local.get $size						i32.sub)						(else;; (BinaryExpression) size & 1;; (JSIdentifier) size						local.get $size;; (JSLiteral) 1						i32.const 1						i32.and						));; (JSLiteral) 4						i32.const 4						i32.mul						i32.add						local.set $pos;; (IfStatement) if (classID >= 32) {var object = new Squ...;; (BinaryExpression) classID >= 32;; (JSIdentifier) classID						local.get $classID;; (JSLiteral) 32						i32.const 32						i32.ge_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) var object = new Squeak.ObjectSpur() obj...;; (VariableDeclaration) var object = new Squeak.ObjectSpur();; (VariableDeclarator) object = new Squeak.ObjectSpur();; (NewExpression) new Squeak.ObjectSpur()						unreachable						local.set $object;; (ExpressionStatement) object.initFromImage(oop, classID, forma...;; (CallExpression) object.initFromImage(oop, classID, forma...						local.get $object;; (JSIdentifier) oop						local.get $oop;; (JSIdentifier) classID						local.get $classID;; (JSIdentifier) format						local.get $format;; (JSIdentifier) hash						local.get $hash						call $initFromImage;; (IfStatement) if (prevObj) {prevObj.nextObject = objec...;; (JSIdentifier) prevObj						local.get $prevObj						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) prevObj.nextObject = object;; (AssignmentExpression) prevObj.nextObject = object;; (JSIdentifier) object						local.get $object						local.set $nextObject));; (ExpressionStatement) this.oldSpaceCount++;; (UpdateExpression) this.oldSpaceCount++;; (StaticMemberExpression) this.oldSpaceCount;; (JSIdentifier) oldSpaceCount						local.get $oldSpaceCount						i32.const 1						i32.add;; (ExpressionStatement) prevObj = object;; (AssignmentExpression) prevObj = object;; (JSIdentifier) object						local.get $object						local.set $prevObj;; (ExpressionStatement) oopMap[oldBaseAddr + oop] = object;; (AssignmentExpression) oopMap[oldBaseAddr + oop] = object						local.get $'oopMap';; (BinaryExpression) oldBaseAddr + oop;; (JSIdentifier) oldBaseAddr						local.get $oldBaseAddr;; (JSIdentifier) oop						local.get $oop						i32.add;; (JSIdentifier) object						local.get $object						call $atPut;; (ExpressionStatement) rawBits[oop] = bits;; (AssignmentExpression) rawBits[oop] = bits						local.get $'rawBits';; (JSIdentifier) oop						local.get $oop;; (JSIdentifier) bits						local.get $bits						call $atPut;; (ExpressionStatement) oopAdjust[oop] = skippedBytes;; (AssignmentExpression) oopAdjust[oop] = skippedBytes						local.get $'oopAdjust';; (JSIdentifier) oop						local.get $oop;; (JSIdentifier) skippedBytes						local.get $skippedBytes						call $atPut)						(else;; (BlockStatement) skippedBytes += pos - objPos if (!freePa...;; (ExpressionStatement) skippedBytes += pos - objPos;; (AssignmentExpression) skippedBytes += pos - objPos;; (JSIdentifier) skippedBytes						local.get $skippedBytes;; (BinaryExpression) pos - objPos;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) objPos						local.get $objPos						i32.sub						i32.add						local.set $skippedBytes;; (IfStatement) if (!freePageList) {freePageList = bits}...;; (UnaryExpression) !freePageList;; (JSIdentifier) freePageList						local.get $freePageList						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) freePageList = bits;; (AssignmentExpression) freePageList = bits;; (JSIdentifier) bits						local.get $bits						local.set $freePageList)						(else;; (IfStatement) if (!classPages) {classPages = bits};; (UnaryExpression) !classPages;; (JSIdentifier) classPages						local.get $classPages						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) classPages = bits;; (AssignmentExpression) classPages = bits;; (JSIdentifier) bits						local.get $bits						local.set $classPages))));; (IfStatement) if (classID) {oopMap[oldBaseAddr + oop] ...;; (JSIdentifier) classID						local.get $classID						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) oopMap[oldBaseAddr + oop] = bits;; (AssignmentExpression) oopMap[oldBaseAddr + oop] = bits						local.get $'oopMap';; (BinaryExpression) oldBaseAddr + oop;; (JSIdentifier) oldBaseAddr						local.get $oldBaseAddr;; (JSIdentifier) oop						local.get $oop						i32.add;; (JSIdentifier) bits						local.get $bits						call $atPut))));; (BinaryExpression) pos < segmentEnd - 16;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) segmentEnd - 16;; (JSIdentifier) segmentEnd						local.get $segmentEnd;; (JSLiteral) 16						i32.const 16						i32.sub						i32.lt_u						i32.const 0						i32.eq						br_if $loop_6)						(block $loop_6_continue);; (IfStatement) if (pos !== segmentEnd - 16) {throw Erro...;; (BinaryExpression) pos !== segmentEnd - 16;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) segmentEnd - 16;; (JSIdentifier) segmentEnd						local.get $segmentEnd;; (JSLiteral) 16						i32.const 16						i32.sub						i32.ne						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('invalid segment')						unreachable));; (VariableDeclaration) var deltaWords = readWord(), deltaWordsH...;; (VariableDeclarator) deltaWords = readWord();; (CallExpression) readWord()						call $readWord						local.set $deltaWords;; (VariableDeclarator) deltaWordsHi = readWord();; (CallExpression) readWord()						call $readWord						local.set $deltaWordsHi;; (VariableDeclarator) segmentBytes = readWord();; (CallExpression) readWord()						call $readWord						local.set $segmentBytes;; (VariableDeclarator) segmentBytesHi = readWord();; (CallExpression) readWord()						call $readWord						local.set $segmentBytesHi;; (IfStatement) if (segmentBytes !== 0) {var deltaBytes ...;; (BinaryExpression) segmentBytes !== 0;; (JSIdentifier) segmentBytes						local.get $segmentBytes;; (JSLiteral) 0						i32.const 0						i32.ne						i32.const 0						i32.ne						(if (then;; (BlockStatement) var deltaBytes = deltaWordsHi & 4.278190...;; (VariableDeclaration) var deltaBytes = deltaWordsHi & 4.278190...;; (VariableDeclarator) deltaBytes = deltaWordsHi & 4.27819008e9...;; (ConditionalExpression) deltaWordsHi & 4.27819008e9 ? deltaWords...;; (BinaryExpression) deltaWordsHi & 4.27819008e9;; (JSIdentifier) deltaWordsHi						local.get $deltaWordsHi;; (JSLiteral) 4.27819008e9						i32.const 4278190080						i32.and						i32.const 1						i32.eq						(if (then;; (BinaryExpression) deltaWords & 16777215 * 4;; (BinaryExpression) deltaWords & 16777215;; (JSIdentifier) deltaWords						local.get $deltaWords;; (JSLiteral) 16777215						i32.const 16777215						i32.and;; (JSLiteral) 4						i32.const 4						i32.mul)						(else;; (JSLiteral) 0						i32.const 0						))						local.set $deltaBytes;; (ExpressionStatement) segmentEnd += segmentBytes;; (AssignmentExpression) segmentEnd += segmentBytes;; (JSIdentifier) segmentEnd						local.get $segmentEnd;; (JSIdentifier) segmentBytes						local.get $segmentBytes						i32.add						local.set $segmentEnd;; (ExpressionStatement) addressOffset += deltaBytes;; (AssignmentExpression) addressOffset += deltaBytes;; (JSIdentifier) addressOffset						local.get $addressOffset;; (JSIdentifier) deltaBytes						local.get $deltaBytes						i32.add						local.set $addressOffset;; (ExpressionStatement) skippedBytes += 16 + deltaBytes;; (AssignmentExpression) skippedBytes += 16 + deltaBytes;; (JSIdentifier) skippedBytes						local.get $skippedBytes;; (BinaryExpression) 16 + deltaBytes;; (JSLiteral) 16						i32.const 16;; (JSIdentifier) deltaBytes						local.get $deltaBytes						i32.add						i32.add						local.set $skippedBytes;; (ExpressionStatement) this.oldSpaceBytes += deltaBytes + segme...;; (AssignmentExpression) this.oldSpaceBytes += deltaBytes + segme...;; (StaticMemberExpression) this.oldSpaceBytes;; (JSIdentifier) oldSpaceBytes						local.get $oldSpaceBytes;; (BinaryExpression) deltaBytes + segmentBytes;; (JSIdentifier) deltaBytes						local.get $deltaBytes;; (JSIdentifier) segmentBytes						local.get $segmentBytes						i32.add						i32.add						local.set $oldSpaceBytes));; (BinaryExpression) pos < segmentEnd;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) segmentEnd						local.get $segmentEnd						i32.lt_u						i32.const 0						i32.eq						br_if $loop_5)						(block $loop_5_continue);; (ExpressionStatement) this.oldSpaceBytes -= skippedBytes;; (AssignmentExpression) this.oldSpaceBytes -= skippedBytes;; (StaticMemberExpression) this.oldSpaceBytes;; (JSIdentifier) oldSpaceBytes						local.get $oldSpaceBytes;; (JSIdentifier) skippedBytes						local.get $skippedBytes						i32.sub						local.set $oldSpaceBytes;; (ExpressionStatement) this.firstOldObject = oopMap[oldBaseAddr...;; (AssignmentExpression) this.firstOldObject = oopMap[oldBaseAddr...;; (ComputedMemberExpression) oopMap[oldBaseAddr];; (JSIdentifier) oopMap						local.get $oopMap;; (JSIdentifier) oldBaseAddr						local.get $oldBaseAddr						i32.const 4						i32.mul						i32.add						local.set $firstOldObject;; (ExpressionStatement) this.lastOldObject = object;; (AssignmentExpression) this.lastOldObject = object;; (JSIdentifier) object						local.get $object						local.set $lastOldObject));; (IfStatement) if (true) {var _splObs = oopMap[specialO...;; (JSLiteral) true						i32.const 1						i32.const 0						i32.ne						(if (then;; (BlockStatement) var _splObs = oopMap[specialObjectsOopIn...;; (VariableDeclaration) var _splObs = oopMap[specialObjectsOopIn...;; (VariableDeclarator) _splObs = oopMap[specialObjectsOopInt];; (ComputedMemberExpression) oopMap[specialObjectsOopInt];; (JSIdentifier) oopMap						local.get $oopMap;; (JSIdentifier) specialObjectsOopInt						local.get $specialObjectsOopInt						i32.const 4						i32.mul						i32.add						local.set $_splObs;; (VariableDeclarator) cc = this.isSpur ? this.spurClassTable(o...;; (ConditionalExpression) this.isSpur ? this.spurClassTable(oopMap...;; (StaticMemberExpression) this.isSpur;; (JSIdentifier) isSpur						local.get $isSpur						i32.const 1						i32.eq						(if (then;; (CallExpression) this.spurClassTable(oopMap, rawBits, cla...						local.get $this;; (JSIdentifier) oopMap						local.get $oopMap;; (JSIdentifier) rawBits						local.get $rawBits;; (JSIdentifier) classPages						local.get $classPages;; (JSIdentifier) _splObs						local.get $_splObs						call $spurClassTable)						(else;; (ComputedMemberExpression) rawBits[oopMap[rawBits[_splObs.oop][Sque...;; (JSIdentifier) rawBits						local.get $rawBits;; (StaticMemberExpression) oopMap[rawBits[_splObs.oop][Squeak.splOb...;; (JSIdentifier) oop						local.get $oop						i32.const 4						i32.mul						i32.add						))						local.set $cc;; (VariableDeclaration) var renamedObj = nil;; (VariableDeclarator) renamedObj = nil;; (JSLiteral) nil						i32.const 0						local.set $renamedObj;; (ExpressionStatement) object = this.firstOldObject;; (AssignmentExpression) object = this.firstOldObject;; (StaticMemberExpression) this.firstOldObject;; (JSIdentifier) firstOldObject						local.get $firstOldObject						local.set $object;; (ExpressionStatement) prevObj = nil;; (AssignmentExpression) prevObj = nil;; (JSLiteral) nil						i32.const 0						local.set $prevObj;; (WhileStatement) while (object) {prevObj = renamedObj ren...						(loop $loop_7;; (BlockStatement) prevObj = renamedObj renamedObj = object...;; (ExpressionStatement) prevObj = renamedObj;; (AssignmentExpression) prevObj = renamedObj;; (JSIdentifier) renamedObj						local.get $renamedObj						local.set $prevObj;; (ExpressionStatement) renamedObj = object.renameFromImage(oopM...;; (AssignmentExpression) renamedObj = object.renameFromImage(oopM...;; (CallExpression) object.renameFromImage(oopMap, rawBits, ...						local.get $object;; (JSIdentifier) oopMap						local.get $oopMap;; (JSIdentifier) rawBits						local.get $rawBits;; (JSIdentifier) cc						local.get $cc						call $renameFromImage						local.set $renamedObj;; (IfStatement) if (prevObj) {prevObj.nextObject = renam...;; (JSIdentifier) prevObj						local.get $prevObj						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) prevObj.nextObject = renamedObj;; (AssignmentExpression) prevObj.nextObject = renamedObj;; (JSIdentifier) renamedObj						local.get $renamedObj						local.set $nextObject)						(else;; (ExpressionStatement) this.firstOldObject = renamedObj;; (AssignmentExpression) this.firstOldObject = renamedObj;; (JSIdentifier) renamedObj						local.get $renamedObj						local.set $firstOldObject));; (ExpressionStatement) oopMap[oldBaseAddr + object.oop] = renam...;; (AssignmentExpression) oopMap[oldBaseAddr + object.oop] = renam...						local.get $'oopMap';; (BinaryExpression) oldBaseAddr + object.oop;; (JSIdentifier) oldBaseAddr						local.get $oldBaseAddr;; (StaticMemberExpression) object.oop;; (JSIdentifier) oop						local.get $oop						i32.add;; (JSIdentifier) renamedObj						local.get $renamedObj						call $atPut;; (ExpressionStatement) object = object.nextObject;; (AssignmentExpression) object = object.nextObject;; (StaticMemberExpression) object.nextObject;; (JSIdentifier) nextObject						local.get $nextObject						local.set $object;; (JSIdentifier) object						local.get $object						i32.const 0						i32.eq						br_if $loop_7)						(block $loop_7_continue);; (ExpressionStatement) this.lastOldObject = renamedObj;; (AssignmentExpression) this.lastOldObject = renamedObj;; (JSIdentifier) renamedObj						local.get $renamedObj						local.set $lastOldObject));; (IfStatement) if (this.isSpur) {var charClass = oopMap...;; (StaticMemberExpression) this.isSpur;; (JSIdentifier) isSpur						local.get $isSpur						i32.const 0						i32.ne						(if (then;; (BlockStatement) var charClass = oopMap[rawBits[splObs.oo...;; (VariableDeclaration) var charClass = oopMap[rawBits[splObs.oo...;; (VariableDeclarator) charClass = oopMap[rawBits[splObs.oop][S...;; (ComputedMemberExpression) oopMap[rawBits[splObs.oop][Squeak.splOb_...;; (JSIdentifier) oopMap						local.get $oopMap;; (ComputedMemberExpression) rawBits[splObs.oop][Squeak.splOb_ClassCh...;; (ComputedMemberExpression) rawBits[splObs.oop];; (JSIdentifier) rawBits						local.get $rawBits;; (StaticMemberExpression) splObs.oop;; (JSIdentifier) oop						local.get $oop						i32.const 4						i32.mul						i32.add;; (StaticMemberExpression) Squeak.splOb_ClassCharacter;; (JSIdentifier) splOb_ClassCharacter						local.get $splOb_ClassCharacter						i32.const 4						i32.mul						i32.add						i32.const 4						i32.mul						i32.add						local.set $charClass;; (ExpressionStatement) this.initCharacterTable(charClass);; (CallExpression) this.initCharacterTable(charClass)						local.get $this;; (JSIdentifier) charClass						local.get $charClass						call $initCharacterTable;; (ExpressionStatement) compactClasses = this.spurClassTable(oop...;; (AssignmentExpression) compactClasses = this.spurClassTable(oop...;; (CallExpression) this.spurClassTable(oopMap, rawBits, cla...						local.get $this;; (JSIdentifier) oopMap						local.get $oopMap;; (JSIdentifier) rawBits						local.get $rawBits;; (JSIdentifier) classPages						local.get $classPages;; (JSIdentifier) splObs						local.get $splObs						call $spurClassTable						local.set $compactClasses;; (ExpressionStatement) nativeFloats = this.getCharacter.bind(th...;; (AssignmentExpression) nativeFloats = this.getCharacter.bind(th...;; (CallExpression) this.getCharacter.bind(this)						local.get $getCharacter;; (ThisExpression) this						call $bind						local.set $nativeFloats;; (ExpressionStatement) this.initSpurOverrides();; (CallExpression) this.initSpurOverrides()						local.get $this						call $initSpurOverrides));; (EmptyStatement) ;; (EmptyStatement) ;; (IfStatement) if (!progressDo) {while (mapSomeObjects(...;; (UnaryExpression) !progressDo;; (JSIdentifier) progressDo						local.get $progressDo						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) while (mapSomeObjects()) {}  if (thenDo)...;; (WhileStatement) while (mapSomeObjects()) {}						(loop $loop_8;; (BlockStatement) ;; (CallExpression) mapSomeObjects()						call $mapSomeObjects						i32.const 0						i32.eq						br_if $loop_8)						(block $loop_8_continue);; (EmptyStatement) ;; (IfStatement) if (thenDo) {thenDo()};; (JSIdentifier) thenDo						local.get $thenDo						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) thenDo();; (CallExpression) thenDo()						call $thenDo)))						(else;; (BlockStatement) this.topmostScope.setTimeout(mapSomeObje...;; (ExpressionStatement) this.topmostScope.setTimeout(mapSomeObje...;; (CallExpression) this.topmostScope.setTimeout(mapSomeObje...						local.get $topmostScope;; (JSIdentifier) mapSomeObjectsAsync						local.get $mapSomeObjectsAsync;; (JSLiteral) 0						i32.const 0						call $setTimeout)));; (JSProperty) property: decorateKnownObjects -> functi...;; (FunctionExpression) function() { 	var splObjs = this.special...(func $decorateKnownObjects						(local $temp i32)						(local $splObjs i32)						(local $i i32)						;; (ExpressionStatement) splObjs[Squeak.splOb_NilObject].isNil = ...;; (AssignmentExpression) splObjs[Squeak.splOb_NilObject].isNil = ...						local.get $splObjs[Squeak.splOb_NilObject];; (JSIdentifier) isNil						local.get $isNil;; (JSLiteral) true						i32.const 1						call $atPut;; (ExpressionStatement) splObjs[Squeak.splOb_TrueObject].isTrue ...;; (AssignmentExpression) splObjs[Squeak.splOb_TrueObject].isTrue ...						local.get $splObjs[Squeak.splOb_TrueObject];; (JSIdentifier) isTrue						local.get $isTrue;; (JSLiteral) true						i32.const 1						call $atPut;; (ExpressionStatement) splObjs[Squeak.splOb_FalseObject].isFals...;; (AssignmentExpression) splObjs[Squeak.splOb_FalseObject].isFals...						local.get $splObjs[Squeak.splOb_FalseObject];; (JSIdentifier) isFalse						local.get $isFalse;; (JSLiteral) true						i32.const 1						call $atPut;; (ExpressionStatement) splObjs[Squeak.splOb_ClassFloat].isFloat...;; (AssignmentExpression) splObjs[Squeak.splOb_ClassFloat].isFloat...						local.get $splObjs[Squeak.splOb_ClassFloat];; (JSIdentifier) isFloatClass						local.get $isFloatClass;; (JSLiteral) true						i32.const 1						call $atPut;; (IfStatement) if (!this.isSpur) {this.compactClasses =...;; (UnaryExpression) !this.isSpur;; (StaticMemberExpression) this.isSpur;; (JSIdentifier) isSpur						local.get $isSpur						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.compactClasses = this.specialObject...;; (ExpressionStatement) this.compactClasses = this.specialObject...;; (AssignmentExpression) this.compactClasses = this.specialObject...;; (StaticMemberExpression) this.specialObjectsArray.pointers[Squeak...;; (JSIdentifier) pointers						local.get $pointers						local.set $compactClasses;; (ForStatement) for (var i = 0; i < this.compactClasses....;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (IfStatement) if (!this.compactClasses[i].isNil) {this...;; (UnaryExpression) !this.compactClasses[i].isNil;; (StaticMemberExpression) this.compactClasses[i].isNil;; (JSIdentifier) isNil						local.get $isNil						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.compactClasses[i].isCompact = true;; (AssignmentExpression) this.compactClasses[i].isCompact = true						local.get $this.compactClasses[i];; (JSIdentifier) isCompact						local.get $isCompact;; (JSLiteral) true						i32.const 1						call $atPut));; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < this.compactClasses.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) this.compactClasses.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_1)))						;; unwritable: (IfStatement) if (!Number.prototype.sqInstName) {Objec);; (JSProperty) property: fixCompactOops -> function() {...;; (FunctionExpression) function() { 	if (this.isSpur) {return }...(func $fixCompactOops						(local $adjust i32)						(local $mightBeCompact i32)						(local $temp i32)						(local $hadCompactHeader i32)						(local $obj i32)						(local $isCompact i32)						;; (IfStatement) if (this.isSpur) {return };; (StaticMemberExpression) this.isSpur;; (JSIdentifier) isSpur						local.get $isSpur						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 						return));; (WhileStatement) while (obj) {var hadCompactHeader = obj....						(loop $loop_1;; (BlockStatement) var hadCompactHeader = obj.hash > 268435...;; (VariableDeclaration) var hadCompactHeader = obj.hash > 268435...;; (VariableDeclarator) hadCompactHeader = obj.hash > 268435455;; (BinaryExpression) obj.hash > 268435455;; (StaticMemberExpression) obj.hash;; (JSIdentifier) hash						local.get $hash;; (JSLiteral) 268435455						i32.const 268435455						i32.gt_u						local.set $hadCompactHeader;; (VariableDeclarator) mightBeCompact = !!obj.sqClass.isCompact;; (UnaryExpression) !!obj.sqClass.isCompact;; (UnaryExpression) !obj.sqClass.isCompact;; (StaticMemberExpression) obj.sqClass.isCompact;; (JSIdentifier) isCompact						local.get $isCompact						local.set $temp						i32.const -1						local.get $temp						i32.sub						local.set $temp						i32.const -1						local.get $temp						i32.sub						local.set $mightBeCompact;; (IfStatement) if (hadCompactHeader !== mightBeCompact)...;; (BinaryExpression) hadCompactHeader !== mightBeCompact;; (JSIdentifier) hadCompactHeader						local.get $hadCompactHeader;; (JSIdentifier) mightBeCompact						local.get $mightBeCompact						i32.ne						i32.const 0						i32.ne						(if (then;; (BlockStatement) var isCompact = obj.snapshotSize().heade...;; (VariableDeclaration) var isCompact = obj.snapshotSize().heade...;; (VariableDeclarator) isCompact = obj.snapshotSize().header ==...;; (BinaryExpression) obj.snapshotSize().header === 0;; (StaticMemberExpression) obj.snapshotSize().header;; (JSIdentifier) header						local.get $header;; (JSLiteral) 0						i32.const 0						i32.eq						local.set $isCompact;; (IfStatement) if (hadCompactHeader !== isCompact) {adj...;; (BinaryExpression) hadCompactHeader !== isCompact;; (JSIdentifier) hadCompactHeader						local.get $hadCompactHeader;; (JSIdentifier) isCompact						local.get $isCompact						i32.ne						i32.const 0						i32.ne						(if (then;; (BlockStatement) adjust += isCompact ? -4 : 4 ;; (ExpressionStatement) adjust += isCompact ? -4 : 4;; (AssignmentExpression) adjust += isCompact ? -4 : 4;; (JSIdentifier) adjust						local.get $adjust;; (ConditionalExpression) isCompact ? -4 : 4;; (JSIdentifier) isCompact						local.get $isCompact						i32.const 1						i32.eq						(if (then;; (UnaryExpression) -4;; (JSLiteral) 4						i32.const 4						local.set $temp						i32.const 0						local.get $temp						i32.sub)						(else;; (JSLiteral) 4						i32.const 4						))						i32.add						local.set $adjust))));; (ExpressionStatement) obj.hash &= 268435455;; (AssignmentExpression) obj.hash &= 268435455;; (StaticMemberExpression) obj.hash;; (JSIdentifier) hash						local.get $hash;; (JSLiteral) 268435455						i32.const 268435455						i32.sub						local.set $hash;; (ExpressionStatement) obj.oop += adjust;; (AssignmentExpression) obj.oop += adjust;; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop;; (JSIdentifier) adjust						local.get $adjust						i32.add						local.set $oop;; (ExpressionStatement) obj = obj.nextObject;; (AssignmentExpression) obj = obj.nextObject;; (StaticMemberExpression) obj.nextObject;; (JSIdentifier) nextObject						local.get $nextObject						local.set $obj;; (JSIdentifier) obj						local.get $obj						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ExpressionStatement) this.oldSpaceBytes += adjust;; (AssignmentExpression) this.oldSpaceBytes += adjust;; (StaticMemberExpression) this.oldSpaceBytes;; (JSIdentifier) oldSpaceBytes						local.get $oldSpaceBytes;; (JSIdentifier) adjust						local.get $adjust						i32.add						local.set $oldSpaceBytes);; (JSProperty) property: fixCompiledMethods -> function...;; (FunctionExpression) function() { 	if (this.version >= 6502) ...(func $fixCompiledMethods						(local $obj i32)						(local $compiledMethodClass i32)						(local $temp i32)						;; (IfStatement) if (this.version >= 6502) {return };; (BinaryExpression) this.version >= 6502;; (StaticMemberExpression) this.version;; (JSIdentifier) version						local.get $version;; (JSLiteral) 6502						i32.const 6502						i32.ge_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 						return));; (WhileStatement) while (obj) {if (obj.isMethod()) {obj.sq...						(loop $loop_1;; (BlockStatement) if (obj.isMethod()) {obj.sqClass = compi...;; (IfStatement) if (obj.isMethod()) {obj.sqClass = compi...;; (CallExpression) obj.isMethod()						local.get $obj						call $isMethod						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) obj.sqClass = compiledMethodClass;; (AssignmentExpression) obj.sqClass = compiledMethodClass;; (JSIdentifier) compiledMethodClass						local.get $compiledMethodClass						local.set $sqClass));; (ExpressionStatement) obj = obj.nextObject;; (AssignmentExpression) obj = obj.nextObject;; (StaticMemberExpression) obj.nextObject;; (JSIdentifier) nextObject						local.get $nextObject						local.set $obj;; (JSIdentifier) obj						local.get $obj						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue));; (JSProperty) property: fixSkippedOops -> function(oop...;; (FunctionExpression) function(oopAdjust) { 	var obj = this.fi...(func $fixSkippedOops						(local $obj i32)						(local $oopAdjust i32)						(local $temp i32)						;; (WhileStatement) while (obj) {obj.oop -= oopAdjust[obj.oo...						(loop $loop_1;; (BlockStatement) obj.oop -= oopAdjust[obj.oop] obj = obj....;; (ExpressionStatement) obj.oop -= oopAdjust[obj.oop];; (AssignmentExpression) obj.oop -= oopAdjust[obj.oop];; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop;; (ComputedMemberExpression) oopAdjust[obj.oop];; (JSIdentifier) oopAdjust						local.get $oopAdjust;; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop						i32.const 4						i32.mul						i32.add						i32.sub						local.set $oop;; (ExpressionStatement) obj = obj.nextObject;; (AssignmentExpression) obj = obj.nextObject;; (StaticMemberExpression) obj.nextObject;; (JSIdentifier) nextObject						local.get $nextObject						local.set $obj;; (JSIdentifier) obj						local.get $obj						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ExpressionStatement) obj = this.lastOldObject;; (AssignmentExpression) obj = this.lastOldObject;; (StaticMemberExpression) this.lastOldObject;; (JSIdentifier) lastOldObject						local.get $lastOldObject						local.set $obj;; (IfStatement) if (obj.addr() + obj.totalBytes() !== th...;; (BinaryExpression) obj.addr() + obj.totalBytes() !== this.o...;; (BinaryExpression) obj.addr() + obj.totalBytes();; (CallExpression) obj.addr()						local.get $obj						call $addr;; (CallExpression) obj.totalBytes()						local.get $obj						call $totalBytes						i32.add;; (StaticMemberExpression) this.oldSpaceBytes;; (JSIdentifier) oldSpaceBytes						local.get $oldSpaceBytes						i32.ne						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('image size doesn''t match o...						unreachable)));; (JSProperty) property: fullGC -> function(reason) { 	...;; (FunctionExpression) function(reason) { 	this.vm.addMessage('...(func $fullGC						(local $newObjects i32)						(local $reason i32)						(local $temp i32)						(local $start i32)												;; unwritable: (ExpressionStatement) this.vm.addMessage('fullGC: ' + reason);; (ExpressionStatement) this.removeUnmarkedOldObjects();; (CallExpression) this.removeUnmarkedOldObjects()						local.get $this						call $removeUnmarkedOldObjects;; (ExpressionStatement) this.appendToOldObjects(newObjects);; (CallExpression) this.appendToOldObjects(newObjects)						local.get $this;; (JSIdentifier) newObjects						local.get $newObjects						call $appendToOldObjects;; (ExpressionStatement) this.finalizeWeakReferences();; (CallExpression) this.finalizeWeakReferences()						local.get $this						call $finalizeWeakReferences;; (ExpressionStatement) this.allocationCount += this.newSpaceCou...;; (AssignmentExpression) this.allocationCount += this.newSpaceCou...;; (StaticMemberExpression) this.allocationCount;; (JSIdentifier) allocationCount						local.get $allocationCount;; (StaticMemberExpression) this.newSpaceCount;; (JSIdentifier) newSpaceCount						local.get $newSpaceCount						i32.add						local.set $allocationCount;; (ExpressionStatement) this.newSpaceCount = 0;; (AssignmentExpression) this.newSpaceCount = 0;; (JSLiteral) 0						i32.const 0						local.set $newSpaceCount;; (ExpressionStatement) this.youngSpaceCount = 0;; (AssignmentExpression) this.youngSpaceCount = 0;; (JSLiteral) 0						i32.const 0						local.set $youngSpaceCount;; (ExpressionStatement) this.hasNewInstances = {};; (AssignmentExpression) this.hasNewInstances = {};; (ObjectExpression) {}						local.set $hasNewInstances;; (ExpressionStatement) this.gcCount++;; (UpdateExpression) this.gcCount++;; (StaticMemberExpression) this.gcCount;; (JSIdentifier) gcCount						local.get $gcCount						i32.const 1						i32.add						;; unwritable: (ExpressionStatement) this.gcMilliseconds += Date.now() - star						;; unwritable: (ExpressionStatement) console.log('Full GC (' + reason + '): ';; (ReturnStatement) return newObjects.length > 0 ? newObject...;; (ConditionalExpression) newObjects.length > 0 ? newObjects[0] : ...;; (BinaryExpression) newObjects.length > 0;; (StaticMemberExpression) newObjects.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 1						i32.eq						(if (then;; (ComputedMemberExpression) newObjects[0];; (JSIdentifier) newObjects						local.get $newObjects;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add)						(else;; (JSLiteral) nil						i32.const 0						))						return);; (JSProperty) property: fusedGC -> function(reason) { ...;; (FunctionExpression) function(reason) { 	this.vm.addMessage('...(func $fusedGC						(local $newObjects i32)						(local $reason i32)						(local $temp i32)						(local $start i32)												;; unwritable: (ExpressionStatement) this.vm.addMessage('fusedGC: ' + reason);; (ExpressionStatement) this.removeUnmarkedOldObjects();; (CallExpression) this.removeUnmarkedOldObjects()						local.get $this						call $removeUnmarkedOldObjects;; (ExpressionStatement) this.appendToOldObjects(newObjects);; (CallExpression) this.appendToOldObjects(newObjects)						local.get $this;; (JSIdentifier) newObjects						local.get $newObjects						call $appendToOldObjects;; (ExpressionStatement) this.finalizeWeakReferences();; (CallExpression) this.finalizeWeakReferences()						local.get $this						call $finalizeWeakReferences;; (ExpressionStatement) this.allocationCount += this.newSpaceCou...;; (AssignmentExpression) this.allocationCount += this.newSpaceCou...;; (StaticMemberExpression) this.allocationCount;; (JSIdentifier) allocationCount						local.get $allocationCount;; (StaticMemberExpression) this.newSpaceCount;; (JSIdentifier) newSpaceCount						local.get $newSpaceCount						i32.add						local.set $allocationCount;; (ExpressionStatement) this.newSpaceCount = 0;; (AssignmentExpression) this.newSpaceCount = 0;; (JSLiteral) 0						i32.const 0						local.set $newSpaceCount;; (ExpressionStatement) this.youngSpaceCount = 0;; (AssignmentExpression) this.youngSpaceCount = 0;; (JSLiteral) 0						i32.const 0						local.set $youngSpaceCount;; (ExpressionStatement) this.hasNewInstances = {};; (AssignmentExpression) this.hasNewInstances = {};; (ObjectExpression) {}						local.set $hasNewInstances;; (ExpressionStatement) this.gcCount++;; (UpdateExpression) this.gcCount++;; (StaticMemberExpression) this.gcCount;; (JSIdentifier) gcCount						local.get $gcCount						i32.const 1						i32.add						;; unwritable: (ExpressionStatement) this.gcMilliseconds += Date.now() - star						;; unwritable: (ExpressionStatement) console.log('Fused GC (' + reason + '): ;; (ReturnStatement) return newObjects.length > 0 ? newObject...;; (ConditionalExpression) newObjects.length > 0 ? newObjects[0] : ...;; (BinaryExpression) newObjects.length > 0;; (StaticMemberExpression) newObjects.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 1						i32.eq						(if (then;; (ComputedMemberExpression) newObjects[0];; (JSIdentifier) newObjects						local.get $newObjects;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add)						(else;; (JSLiteral) nil						i32.const 0						))						return);; (JSProperty) property: gcRoots -> function() { 	this....;; (FunctionExpression) function() { 	this.vm.storeContextRegist...(func $gcRoots						(local $temp i32)						;; (ExpressionStatement) this.vm.storeContextRegisters();; (CallExpression) this.vm.storeContextRegisters()						local.get $vm						call $storeContextRegisters						;; unwritable: (ReturnStatement) return [this.specialObjectsArray, this.v);; (JSProperty) property: markReachableObjects -> functi...;; (FunctionExpression) function() { 	var todo = this.gcRoots() ...(func $markReachableObjects						(local $newObjects i32)						(local $body i32)						(local $i i32)						(local $object i32)						(local $todo i32)						(local $n i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.weakObjects = []						;; unwritable: (WhileStatement) while (todo.length > 0) {var object = to;; (ReturnStatement) return this.isSpur ? newObjects : newObj...;; (ConditionalExpression) this.isSpur ? newObjects : newObjects.so...;; (StaticMemberExpression) this.isSpur;; (JSIdentifier) isSpur						local.get $isSpur						i32.const 1						i32.eq						(if (then;; (JSIdentifier) newObjects						local.get $newObjects)						(else;; (CallExpression) newObjects.sort(function(a, b) { 	return...						local.get $newObjects;; (FunctionExpression) function(a, b) { 	return b.oop - a.oop }(func $nil						(local $b i32)						(local $temp i32)						(local $a i32)						;; (ReturnStatement) return b.oop - a.oop;; (BinaryExpression) b.oop - a.oop;; (StaticMemberExpression) b.oop;; (JSIdentifier) oop						local.get $oop;; (StaticMemberExpression) a.oop;; (JSIdentifier) oop						local.get $oop						i32.sub						return)						call $sort						))						return);; (JSProperty) property: markFusedObjects -> function()...;; (FunctionExpression) function() { 	var todo = this.gcRoots() ...(func $markFusedObjects						(local $newObjects i32)						(local $body i32)						(local $i i32)						(local $object i32)						(local $todo i32)						(local $n i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.weakObjects = []						;; unwritable: (WhileStatement) while (todo.length > 0) {var object = to;; (ReturnStatement) return this.isSpur ? newObjects : newObj...;; (ConditionalExpression) this.isSpur ? newObjects : newObjects.so...;; (StaticMemberExpression) this.isSpur;; (JSIdentifier) isSpur						local.get $isSpur						i32.const 1						i32.eq						(if (then;; (JSIdentifier) newObjects						local.get $newObjects)						(else;; (CallExpression) newObjects.sort(function(a, b) { 	return...						local.get $newObjects;; (FunctionExpression) function(a, b) { 	return b.oop - a.oop }(func $nil						(local $b i32)						(local $temp i32)						(local $a i32)						;; (ReturnStatement) return b.oop - a.oop;; (BinaryExpression) b.oop - a.oop;; (StaticMemberExpression) b.oop;; (JSIdentifier) oop						local.get $oop;; (StaticMemberExpression) a.oop;; (JSIdentifier) oop						local.get $oop						i32.sub						return)						call $sort						))						return);; (JSProperty) property: removeUnmarkedOldObjects -> fu...;; (FunctionExpression) function() { 	var removedCount = 0, remo...(func $removeUnmarkedOldObjects						(local $corpse i32)						(local $next i32)						(local $removedBytes i32)						(local $removedCount i32)						(local $temp i32)						(local $obj i32)						;; (ExpressionStatement) obj.mark = false;; (AssignmentExpression) obj.mark = false;; (JSLiteral) false						i32.const 0						local.set $mark						;; unwritable: (WhileStatement) while (true) {var next = obj.nextObject );; (JSProperty) property: appendToOldObjects -> function...;; (FunctionExpression) function(newObjects) { 	var oldObj = thi...(func $appendToOldObjects						(local $newObjects i32)						(local $oldObj i32)						(local $i i32)						(local $newObj i32)						(local $temp i32)						;; (ForStatement) for (var i = 0; i < newObjects.length; i...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (BlockStatement) var newObj = newObjects[i] newObj.mark =...;; (VariableDeclaration) var newObj = newObjects[i];; (VariableDeclarator) newObj = newObjects[i];; (ComputedMemberExpression) newObjects[i];; (JSIdentifier) newObjects						local.get $newObjects;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						local.set $newObj;; (ExpressionStatement) newObj.mark = false;; (AssignmentExpression) newObj.mark = false;; (JSLiteral) false						i32.const 0						local.set $mark;; (ExpressionStatement) this.oldSpaceBytes = newObj.setAddr(this...;; (AssignmentExpression) this.oldSpaceBytes = newObj.setAddr(this...;; (CallExpression) newObj.setAddr(this.oldSpaceBytes)						local.get $newObj;; (StaticMemberExpression) this.oldSpaceBytes;; (JSIdentifier) oldSpaceBytes						local.get $oldSpaceBytes						call $setAddr						local.set $oldSpaceBytes;; (ExpressionStatement) oldObj.nextObject = newObj;; (AssignmentExpression) oldObj.nextObject = newObj;; (JSIdentifier) newObj						local.get $newObj						local.set $nextObject;; (ExpressionStatement) oldObj = newObj;; (AssignmentExpression) oldObj = newObj;; (JSIdentifier) newObj						local.get $newObj						local.set $oldObj;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < newObjects.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) newObjects.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_1);; (ExpressionStatement) oldObj.nextObject = nil;; (AssignmentExpression) oldObj.nextObject = nil;; (JSLiteral) nil						i32.const 0						local.set $nextObject;; (ExpressionStatement) this.lastOldObject = oldObj;; (AssignmentExpression) this.lastOldObject = oldObj;; (JSIdentifier) oldObj						local.get $oldObj						local.set $lastOldObject;; (ExpressionStatement) this.oldSpaceCount += newObjects.length;; (AssignmentExpression) this.oldSpaceCount += newObjects.length;; (StaticMemberExpression) this.oldSpaceCount;; (JSIdentifier) oldSpaceCount						local.get $oldSpaceCount;; (StaticMemberExpression) newObjects.length;; (JSIdentifier) length						local.get $length						i32.add						local.set $oldSpaceCount;; (ExpressionStatement) this.gcTenured += newObjects.length;; (AssignmentExpression) this.gcTenured += newObjects.length;; (StaticMemberExpression) this.gcTenured;; (JSIdentifier) gcTenured						local.get $gcTenured;; (StaticMemberExpression) newObjects.length;; (JSIdentifier) length						local.get $length						i32.add						local.set $gcTenured);; (JSProperty) property: tenureIfYoung -> function(obje...;; (FunctionExpression) function(object) { 	if (object.oop < 0) ...(func $tenureIfYoung						(local $object i32)						(local $temp i32)												;; unwritable: (IfStatement) if (object.oop < 0) {this.appendToOldObj);; (JSProperty) property: finalizeWeakReferences -> func...;; (FunctionExpression) function() { 	var weakObjects = this.wea...(func $finalizeWeakReferences						(local $list i32)						(local $temp i32)						(local $firstWeak i32)						(local $o i32)						(local $i i32)						(local $weakObjects i32)						(local $finalized i32)						(local $items i32)						(local $pointers i32)						(local $weakObj i32)						;; (ExpressionStatement) this.weakObjects = nil;; (AssignmentExpression) this.weakObjects = nil;; (JSLiteral) nil						i32.const 0						local.set $weakObjects;; (ForStatement) for (var o = 0; o < weakObjects.length; ...;; (VariableDeclaration) var o = 0;; (VariableDeclarator) o = 0;; (JSLiteral) 0						i32.const 0						local.set $o						(loop $loop_1;; (BlockStatement) var weakObj = weakObjects[o], pointers =...;; (VariableDeclaration) var weakObj = weakObjects[o], pointers =...;; (VariableDeclarator) weakObj = weakObjects[o];; (ComputedMemberExpression) weakObjects[o];; (JSIdentifier) weakObjects						local.get $weakObjects;; (JSIdentifier) o						local.get $o						i32.const 4						i32.mul						i32.add						local.set $weakObj;; (VariableDeclarator) pointers = weakObj.pointers;; (StaticMemberExpression) weakObj.pointers;; (JSIdentifier) pointers						local.get $pointers						local.set $pointers;; (VariableDeclarator) firstWeak = weakObj.sqClass.classInstSiz...;; (CallExpression) weakObj.sqClass.classInstSize()						local.get $weakObj.sqClass						call $classInstSize						local.set $firstWeak;; (VariableDeclarator) finalized = false;; (JSLiteral) false						i32.const 0						local.set $finalized;; (ForStatement) for (var i = firstWeak; i < pointers.len...;; (VariableDeclaration) var i = firstWeak;; (VariableDeclarator) i = firstWeak;; (JSIdentifier) firstWeak						local.get $firstWeak						local.set $i						(loop $loop_2;; (BlockStatement) if (pointers[i].oop < 0) {pointers[i] = ...;; (IfStatement) if (pointers[i].oop < 0) {pointers[i] = ...;; (BinaryExpression) pointers[i].oop < 0;; (StaticMemberExpression) pointers[i].oop;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 0						i32.const 0						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) pointers[i] = this.vm.nilObj finalized =...;; (ExpressionStatement) pointers[i] = this.vm.nilObj;; (AssignmentExpression) pointers[i] = this.vm.nilObj						local.get $'pointers';; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut;; (ExpressionStatement) finalized = true;; (AssignmentExpression) finalized = true;; (JSLiteral) true						i32.const 1						local.set $finalized));; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < pointers.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) pointers.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_2);; (IfStatement) if (finalized) {this.vm.pendingFinalizat...;; (JSIdentifier) finalized						local.get $finalized						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.vm.pendingFinalizationSignals++ if ...;; (ExpressionStatement) this.vm.pendingFinalizationSignals++;; (UpdateExpression) this.vm.pendingFinalizationSignals++;; (StaticMemberExpression) this.vm.pendingFinalizationSignals;; (JSIdentifier) pendingFinalizationSignals						local.get $pendingFinalizationSignals						i32.const 1						i32.add;; (IfStatement) if (firstWeak >= 2) {var list = weakObj....;; (BinaryExpression) firstWeak >= 2;; (JSIdentifier) firstWeak						local.get $firstWeak;; (JSLiteral) 2						i32.const 2						i32.ge_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) var list = weakObj.pointers[Squeak.WeakF...;; (VariableDeclaration) var list = weakObj.pointers[Squeak.WeakF...;; (VariableDeclarator) list = weakObj.pointers[Squeak.WeakFinal...;; (ComputedMemberExpression) weakObj.pointers[Squeak.WeakFinalizerIte...;; (StaticMemberExpression) weakObj.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.WeakFinalizerItem_list;; (JSIdentifier) WeakFinalizerItem_list						local.get $WeakFinalizerItem_list						i32.const 4						i32.mul						i32.add						local.set $list;; (IfStatement) if (list.sqClass == this.vm.specialObjec...;; (BinaryExpression) list.sqClass == this.vm.specialObjects[S...;; (StaticMemberExpression) list.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassWeakFinalizer;; (JSIdentifier) splOb_ClassWeakFinalizer						local.get $splOb_ClassWeakFinalizer						i32.const 4						i32.mul						i32.add						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) var items = list.pointers[Squeak.WeakFin...;; (VariableDeclaration) var items = list.pointers[Squeak.WeakFin...;; (VariableDeclarator) items = list.pointers[Squeak.WeakFinaliz...;; (ComputedMemberExpression) list.pointers[Squeak.WeakFinalizationLis...;; (StaticMemberExpression) list.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.WeakFinalizationList_first;; (JSIdentifier) WeakFinalizationList_first						local.get $WeakFinalizationList_first						i32.const 4						i32.mul						i32.add						local.set $items;; (ExpressionStatement) weakObj.pointers[Squeak.WeakFinalizerIte...;; (AssignmentExpression) weakObj.pointers[Squeak.WeakFinalizerIte...						local.get $weakObj;; (StaticMemberExpression) Squeak.WeakFinalizerItem_next;; (JSIdentifier) WeakFinalizerItem_next						local.get $WeakFinalizerItem_next;; (JSIdentifier) items						local.get $items						call $atPut;; (ExpressionStatement) list.pointers[Squeak.WeakFinalizationLis...;; (AssignmentExpression) list.pointers[Squeak.WeakFinalizationLis...						local.get $list;; (StaticMemberExpression) Squeak.WeakFinalizationList_first;; (JSIdentifier) WeakFinalizationList_first						local.get $WeakFinalizationList_first;; (JSIdentifier) weakObj						local.get $weakObj						call $atPut))))));; (UpdateExpression) o++;; (JSIdentifier) o						local.get $o						i32.const 1						i32.add;; (BinaryExpression) o < weakObjects.length;; (JSIdentifier) o						local.get $o;; (StaticMemberExpression) weakObjects.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_1);; (EmptyStatement) ;; (IfStatement) if (this.vm.pendingFinalizationSignals >...;; (BinaryExpression) this.vm.pendingFinalizationSignals > 0;; (StaticMemberExpression) this.vm.pendingFinalizationSignals;; (JSIdentifier) pendingFinalizationSignals						local.get $pendingFinalizationSignals;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.vm.forceInterruptCheck() ;; (ExpressionStatement) this.vm.forceInterruptCheck();; (CallExpression) this.vm.forceInterruptCheck()						local.get $vm						call $forceInterruptCheck)));; (JSProperty) property: partialGC -> function(reason) ...;; (FunctionExpression) function(reason) { 	this.vm.addMessage('...(func $partialGC						(local $reason i32)						(local $young i32)						(local $temp i32)						(local $start i32)												;; unwritable: (ExpressionStatement) this.vm.addMessage('partialGC: ' + reaso;; (ExpressionStatement) this.appendToYoungSpace(young);; (CallExpression) this.appendToYoungSpace(young)						local.get $this;; (JSIdentifier) young						local.get $young						call $appendToYoungSpace;; (ExpressionStatement) this.finalizeWeakReferences();; (CallExpression) this.finalizeWeakReferences()						local.get $this						call $finalizeWeakReferences;; (ExpressionStatement) this.cleanupYoungSpace(young);; (CallExpression) this.cleanupYoungSpace(young)						local.get $this;; (JSIdentifier) young						local.get $young						call $cleanupYoungSpace;; (ExpressionStatement) this.allocationCount += this.newSpaceCou...;; (AssignmentExpression) this.allocationCount += this.newSpaceCou...;; (StaticMemberExpression) this.allocationCount;; (JSIdentifier) allocationCount						local.get $allocationCount;; (BinaryExpression) this.newSpaceCount - young.length;; (StaticMemberExpression) this.newSpaceCount;; (JSIdentifier) newSpaceCount						local.get $newSpaceCount;; (StaticMemberExpression) young.length;; (JSIdentifier) length						local.get $length						i32.sub						i32.add						local.set $allocationCount;; (ExpressionStatement) this.youngSpaceCount = young.length;; (AssignmentExpression) this.youngSpaceCount = young.length;; (StaticMemberExpression) young.length;; (JSIdentifier) length						local.get $length						local.set $youngSpaceCount;; (ExpressionStatement) this.newSpaceCount = this.youngSpaceCoun...;; (AssignmentExpression) this.newSpaceCount = this.youngSpaceCoun...;; (StaticMemberExpression) this.youngSpaceCount;; (JSIdentifier) youngSpaceCount						local.get $youngSpaceCount						local.set $newSpaceCount;; (ExpressionStatement) this.pgcCount++;; (UpdateExpression) this.pgcCount++;; (StaticMemberExpression) this.pgcCount;; (JSIdentifier) pgcCount						local.get $pgcCount						i32.const 1						i32.add						;; unwritable: (ExpressionStatement) this.pgcMilliseconds += Date.now() - sta						;; unwritable: (ExpressionStatement) console.log('Partial GC (' + reason + ');; (ReturnStatement) return young[0];; (ComputedMemberExpression) young[0];; (JSIdentifier) young						local.get $young;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: youngRoots -> function() { 	va...;; (FunctionExpression) function() { 	var roots = this.gcRoots()...(func $youngRoots						(local $child i32)						(local $body i32)						(local $i i32)						(local $object i32)						(local $dirty i32)						(local $temp i32)						(local $roots i32)												;; unwritable: (WhileStatement) while (object) {if (object.dirty) {var b;; (ReturnStatement) return roots;; (JSIdentifier) roots						local.get $roots						return);; (JSProperty) property: findYoungObjects -> function()...;; (FunctionExpression) function() { 	var todo = this.youngRoots...(func $findYoungObjects						(local $child i32)						(local $newObjects i32)						(local $body i32)						(local $i i32)						(local $object i32)						(local $todo i32)						(local $n i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.weakObjects = []						;; unwritable: (WhileStatement) while (todo.length > 0) {var object = to;; (ReturnStatement) return this.isSpur ? newObjects : newObj...;; (ConditionalExpression) this.isSpur ? newObjects : newObjects.so...;; (StaticMemberExpression) this.isSpur;; (JSIdentifier) isSpur						local.get $isSpur						i32.const 1						i32.eq						(if (then;; (JSIdentifier) newObjects						local.get $newObjects)						(else;; (CallExpression) newObjects.sort(function(a, b) { 	return...						local.get $newObjects;; (FunctionExpression) function(a, b) { 	return b.oop - a.oop }(func $nil						(local $b i32)						(local $temp i32)						(local $a i32)						;; (ReturnStatement) return b.oop - a.oop;; (BinaryExpression) b.oop - a.oop;; (StaticMemberExpression) b.oop;; (JSIdentifier) oop						local.get $oop;; (StaticMemberExpression) a.oop;; (JSIdentifier) oop						local.get $oop						i32.sub						return)						call $sort						))						return);; (JSProperty) property: appendToYoungSpace -> function...;; (FunctionExpression) function(objects) { 	var tempOop = this....(func $appendToYoungSpace						(local $objects i32)						(local $tempOop i32)						(local $i i32)						(local $temp i32)						(local $obj i32)												;; unwritable: (ForStatement) for (var i = 0; i < objects.length; i++));; (JSProperty) property: cleanupYoungSpace -> function(...;; (FunctionExpression) function(objects) { 	var obj = objects[0...(func $cleanupYoungSpace						(local $objects i32)						(local $temp i32)						(local $youngOop i32)						(local $obj i32)												;; unwritable: (WhileStatement) while (obj) {if (this.hasNewInstances[ob);; (JSProperty) property: registerObject -> function(obj...;; (FunctionExpression) function(obj) { 	obj.oop = -++this.newSp...(func $registerObject						(local $obj i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) obj.oop = -++this.newSpaceCount;; (ExpressionStatement) this.lastHash = 13849 + 27181 * this.las...;; (AssignmentExpression) this.lastHash = 13849 + 27181 * this.las...;; (BinaryExpression) 13849 + 27181 * this.lastHash & 4.294967...;; (BinaryExpression) 13849 + 27181 * this.lastHash;; (JSLiteral) 13849						i32.const 13849;; (BinaryExpression) 27181 * this.lastHash;; (JSLiteral) 27181						i32.const 27181;; (StaticMemberExpression) this.lastHash;; (JSIdentifier) lastHash						local.get $lastHash						i32.mul						i32.add;; (JSLiteral) 4.294967295e9						i32.const 4294967295						i32.and						local.set $lastHash;; (ReturnStatement) return this.lastHash & 4095;; (BinaryExpression) this.lastHash & 4095;; (StaticMemberExpression) this.lastHash;; (JSIdentifier) lastHash						local.get $lastHash;; (JSLiteral) 4095						i32.const 4095						i32.and						return);; (JSProperty) property: registerObjectSpur -> function...;; (FunctionExpression) function(obj) { 	obj.oop = -++this.newSp...(func $registerObjectSpur						(local $obj i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) obj.oop = -++this.newSpaceCount;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return);; (JSProperty) property: instantiateClass -> function(a...;; (FunctionExpression) function(aClass, indexableSize, filler) ...(func $instantiateClass						(local $newObject i32)						(local $indexableSize i32)						(local $hash i32)						(local $aClass i32)						(local $temp i32)						(local $filler i32)						;; (ExpressionStatement) newObject.initInstanceOf(aClass, indexab...;; (CallExpression) newObject.initInstanceOf(aClass, indexab...						local.get $newObject;; (JSIdentifier) aClass						local.get $aClass;; (JSIdentifier) indexableSize						local.get $indexableSize;; (JSIdentifier) hash						local.get $hash;; (JSIdentifier) filler						local.get $filler						call $initInstanceOf;; (ExpressionStatement) this.hasNewInstances[aClass.oop] = true;; (AssignmentExpression) this.hasNewInstances[aClass.oop] = true						local.get $this;; (StaticMemberExpression) aClass.oop;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) true						i32.const 1						call $atPut;; (ReturnStatement) return newObject;; (JSIdentifier) newObject						local.get $newObject						return);; (JSProperty) property: clone -> function(object) { 	v...;; (FunctionExpression) function(object) { 	var newObject = new ...(func $clone						(local $newObject i32)						(local $hash i32)						(local $temp i32)						(local $object i32)						;; (ExpressionStatement) newObject.initAsClone(object, hash);; (CallExpression) newObject.initAsClone(object, hash)						local.get $newObject;; (JSIdentifier) object						local.get $object;; (JSIdentifier) hash						local.get $hash						call $initAsClone;; (ExpressionStatement) this.hasNewInstances[newObject.sqClass.o...;; (AssignmentExpression) this.hasNewInstances[newObject.sqClass.o...						local.get $this;; (StaticMemberExpression) newObject.sqClass.oop;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) true						i32.const 1						call $atPut;; (ReturnStatement) return newObject;; (JSIdentifier) newObject						local.get $newObject						return);; (JSProperty) property: bulkBecome -> function(fromArr...;; (FunctionExpression) function(fromArray, toArray, twoWay, cop...(func $bulkBecome						(local $temp i32)						(local $j i32)						(local $fromHash i32)						(local $mutations i32)						(local $twoWay i32)						(local $i i32)						(local $copyHash i32)						(local $obj i32)						(local $n i32)						(local $firstYoungObject i32)						(local $mut i32)						(local $body i32)						(local $toArray i32)						(local $fromArray i32)						;; (IfStatement) if (!fromArray) {return !toArray};; (UnaryExpression) !fromArray;; (JSIdentifier) fromArray						local.get $fromArray						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return !toArray;; (UnaryExpression) !toArray;; (JSIdentifier) toArray						local.get $toArray						local.set $temp						i32.const -1						local.get $temp						i32.sub						return));; (IfStatement) if (n !== toArray.length) {return false};; (BinaryExpression) n !== toArray.length;; (JSIdentifier) n						local.get $n;; (StaticMemberExpression) toArray.length;; (JSIdentifier) length						local.get $length						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (IfStatement) if (this.newSpaceCount > 0) {firstYoungO;; (ForStatement) for (var i = 0; i < n; i++) {var obj = f...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (BlockStatement) var obj = fromArray[i] if (!obj.sqClass)...;; (VariableDeclaration) var obj = fromArray[i];; (VariableDeclarator) obj = fromArray[i];; (ComputedMemberExpression) fromArray[i];; (JSIdentifier) fromArray						local.get $fromArray;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						local.set $obj;; (IfStatement) if (!obj.sqClass) {return false};; (UnaryExpression) !obj.sqClass;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (mutations[obj.oop]) {return false} e...;; (ComputedMemberExpression) mutations[obj.oop];; (JSIdentifier) mutations						local.get $mutations;; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop						i32.const 4						i32.mul						i32.add						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return)						(else;; (ExpressionStatement) mutations[obj.oop] = toArray[i];; (AssignmentExpression) mutations[obj.oop] = toArray[i]						local.get $'mutations';; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop;; (ComputedMemberExpression) toArray[i];; (JSIdentifier) toArray						local.get $toArray;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						call $atPut));; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < n;; (JSIdentifier) i						local.get $i;; (JSIdentifier) n						local.get $n						i32.lt_u						i32.const 0						br_if $loop_1);; (IfStatement) if (twoWay) {for (var i = 0; i < n; i++)...;; (JSIdentifier) twoWay						local.get $twoWay						i32.const 0						i32.ne						(if (then;; (ForStatement) for (var i = 0; i < n; i++) {var obj = t...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_2;; (BlockStatement) var obj = toArray[i] if (!obj.sqClass) {...;; (VariableDeclaration) var obj = toArray[i];; (VariableDeclarator) obj = toArray[i];; (ComputedMemberExpression) toArray[i];; (JSIdentifier) toArray						local.get $toArray;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						local.set $obj;; (IfStatement) if (!obj.sqClass) {return false};; (UnaryExpression) !obj.sqClass;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (mutations[obj.oop]) {return false} e...;; (ComputedMemberExpression) mutations[obj.oop];; (JSIdentifier) mutations						local.get $mutations;; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop						i32.const 4						i32.mul						i32.add						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return)						(else;; (ExpressionStatement) mutations[obj.oop] = fromArray[i];; (AssignmentExpression) mutations[obj.oop] = fromArray[i]						local.get $'mutations';; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop;; (ComputedMemberExpression) fromArray[i];; (JSIdentifier) fromArray						local.get $fromArray;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						call $atPut));; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < n;; (JSIdentifier) i						local.get $i;; (JSIdentifier) n						local.get $n						i32.lt_u						i32.const 0						br_if $loop_2)));; (IfStatement) if (copyHash) {for (var i = 0; i < n; i+...;; (JSIdentifier) copyHash						local.get $copyHash						i32.const 0						i32.ne						(if (then;; (ForStatement) for (var i = 0; i < n; i++) {if (!toArra...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_3;; (BlockStatement) if (!toArray[i].sqClass) {return false} ...;; (IfStatement) if (!toArray[i].sqClass) {return false};; (UnaryExpression) !toArray[i].sqClass;; (StaticMemberExpression) toArray[i].sqClass;; (JSIdentifier) sqClass						local.get $sqClass						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (VariableDeclaration) var fromHash = fromArray[i].hash;; (VariableDeclarator) fromHash = fromArray[i].hash;; (StaticMemberExpression) fromArray[i].hash;; (JSIdentifier) hash						local.get $hash						local.set $fromHash;; (ExpressionStatement) fromArray[i].hash = toArray[i].hash;; (AssignmentExpression) fromArray[i].hash = toArray[i].hash						local.get $fromArray[i];; (JSIdentifier) hash						local.get $hash;; (StaticMemberExpression) toArray[i].hash;; (JSIdentifier) hash						local.get $hash						call $atPut;; (ExpressionStatement) toArray[i].hash = fromHash;; (AssignmentExpression) toArray[i].hash = fromHash						local.get $toArray[i];; (JSIdentifier) hash						local.get $hash;; (JSIdentifier) fromHash						local.get $fromHash						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < n;; (JSIdentifier) i						local.get $i;; (JSIdentifier) n						local.get $n						i32.lt_u						i32.const 0						br_if $loop_3)));; (ExpressionStatement) this.lastOldObject.nextObject = firstYou...;; (AssignmentExpression) this.lastOldObject.nextObject = firstYou...;; (JSIdentifier) firstYoungObject						local.get $firstYoungObject						local.set $nextObject;; (WhileStatement) while (obj) {var mut = mutations[obj.sqC...						(loop $loop_4;; (BlockStatement) var mut = mutations[obj.sqClass.oop] if ...;; (VariableDeclaration) var mut = mutations[obj.sqClass.oop];; (VariableDeclarator) mut = mutations[obj.sqClass.oop];; (ComputedMemberExpression) mutations[obj.sqClass.oop];; (JSIdentifier) mutations						local.get $mutations;; (StaticMemberExpression) obj.sqClass.oop;; (JSIdentifier) oop						local.get $oop						i32.const 4						i32.mul						i32.add						local.set $mut;; (IfStatement) if (mut) {obj.sqClass = mut if (mut.oop ...;; (JSIdentifier) mut						local.get $mut						i32.const 0						i32.ne						(if (then;; (BlockStatement) obj.sqClass = mut if (mut.oop < 0) {obj....;; (ExpressionStatement) obj.sqClass = mut;; (AssignmentExpression) obj.sqClass = mut;; (JSIdentifier) mut						local.get $mut						local.set $sqClass;; (IfStatement) if (mut.oop < 0) {obj.dirty = true};; (BinaryExpression) mut.oop < 0;; (StaticMemberExpression) mut.oop;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 0						i32.const 0						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) obj.dirty = true;; (AssignmentExpression) obj.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty))));; (VariableDeclaration) var body = obj.pointers;; (VariableDeclarator) body = obj.pointers;; (StaticMemberExpression) obj.pointers;; (JSIdentifier) pointers						local.get $pointers						local.set $body;; (IfStatement) if (body) {for (var j = 0; j < body.leng...;; (JSIdentifier) body						local.get $body						i32.const 0						i32.ne						(if (then;; (ForStatement) for (var j = 0; j < body.length; j++) {m...;; (VariableDeclaration) var j = 0;; (VariableDeclarator) j = 0;; (JSLiteral) 0						i32.const 0						local.set $j						(loop $loop_5;; (BlockStatement) mut = mutations[body[j].oop] if (mut) {b...;; (ExpressionStatement) mut = mutations[body[j].oop];; (AssignmentExpression) mut = mutations[body[j].oop];; (ComputedMemberExpression) mutations[body[j].oop];; (JSIdentifier) mutations						local.get $mutations;; (StaticMemberExpression) body[j].oop;; (JSIdentifier) oop						local.get $oop						i32.const 4						i32.mul						i32.add						local.set $mut;; (IfStatement) if (mut) {body[j] = mut if (mut.oop < 0)...;; (JSIdentifier) mut						local.get $mut						i32.const 0						i32.ne						(if (then;; (BlockStatement) body[j] = mut if (mut.oop < 0) {obj.dirt...;; (ExpressionStatement) body[j] = mut;; (AssignmentExpression) body[j] = mut						local.get $'body';; (JSIdentifier) j						local.get $j;; (JSIdentifier) mut						local.get $mut						call $atPut;; (IfStatement) if (mut.oop < 0) {obj.dirty = true};; (BinaryExpression) mut.oop < 0;; (StaticMemberExpression) mut.oop;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 0						i32.const 0						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) obj.dirty = true;; (AssignmentExpression) obj.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty))));; (UpdateExpression) j++;; (JSIdentifier) j						local.get $j						i32.const 1						i32.add;; (BinaryExpression) j < body.length;; (JSIdentifier) j						local.get $j;; (StaticMemberExpression) body.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_5)));; (ExpressionStatement) obj = obj.nextObject;; (AssignmentExpression) obj = obj.nextObject;; (StaticMemberExpression) obj.nextObject;; (JSIdentifier) nextObject						local.get $nextObject						local.set $obj;; (JSIdentifier) obj						local.get $obj						i32.const 0						i32.eq						br_if $loop_4)						(block $loop_4_continue);; (ExpressionStatement) this.lastOldObject.nextObject = nil;; (AssignmentExpression) this.lastOldObject.nextObject = nil;; (JSLiteral) nil						i32.const 0						local.set $nextObject;; (ExpressionStatement) this.vm.flushMethodCacheAfterBecome(muta...;; (CallExpression) this.vm.flushMethodCacheAfterBecome(muta...						local.get $vm;; (JSIdentifier) mutations						local.get $mutations						call $flushMethodCacheAfterBecome;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: objectAfter -> function(obj) {...;; (FunctionExpression) function(obj) { 	return obj.nextObject |...(func $objectAfter						(local $obj i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return obj.nextObject || this.nextObject);; (JSProperty) property: someInstanceOf -> function(cls...;; (FunctionExpression) function(clsObj) { 	var obj = this.first...(func $someInstanceOf						(local $obj i32)						(local $clsObj i32)						(local $temp i32)						;; (WhileStatement) while (obj) {if (obj.sqClass === clsObj)...						(loop $loop_1;; (BlockStatement) if (obj.sqClass === clsObj) {return obj}...;; (IfStatement) if (obj.sqClass === clsObj) {return obj};; (BinaryExpression) obj.sqClass === clsObj;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (JSIdentifier) clsObj						local.get $clsObj						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return obj;; (JSIdentifier) obj						local.get $obj						return));; (ExpressionStatement) obj = obj.nextObject || this.nextObjectW...;; (AssignmentExpression) obj = obj.nextObject || this.nextObjectW...;; (BinaryExpression) obj.nextObject || this.nextObjectWithGCF...;; (StaticMemberExpression) obj.nextObject;; (JSIdentifier) nextObject						local.get $nextObject;; (CallExpression) this.nextObjectWithGCFor(obj, clsObj)						local.get $this;; (JSIdentifier) obj						local.get $obj;; (JSIdentifier) clsObj						local.get $clsObj						call $nextObjectWithGCFor						i32.or						local.set $obj;; (JSIdentifier) obj						local.get $obj						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return);; (JSProperty) property: nextInstanceAfter -> function(...;; (FunctionExpression) function(obj) { 	var clsObj = obj.sqClas...(func $nextInstanceAfter						(local $obj i32)						(local $clsObj i32)						(local $temp i32)						;; (WhileStatement) while (true) {obj = obj.nextObject || th...						(loop $loop_1;; (BlockStatement) obj = obj.nextObject || this.nextObjectW...;; (ExpressionStatement) obj = obj.nextObject || this.nextObjectW...;; (AssignmentExpression) obj = obj.nextObject || this.nextObjectW...;; (BinaryExpression) obj.nextObject || this.nextObjectWithGCF...;; (StaticMemberExpression) obj.nextObject;; (JSIdentifier) nextObject						local.get $nextObject;; (CallExpression) this.nextObjectWithGCFor(obj, clsObj)						local.get $this;; (JSIdentifier) obj						local.get $obj;; (JSIdentifier) clsObj						local.get $clsObj						call $nextObjectWithGCFor						i32.or						local.set $obj;; (IfStatement) if (!obj) {return nil};; (UnaryExpression) !obj;; (JSIdentifier) obj						local.get $obj						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return));; (IfStatement) if (obj.sqClass === clsObj) {return obj};; (BinaryExpression) obj.sqClass === clsObj;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (JSIdentifier) clsObj						local.get $clsObj						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return obj;; (JSIdentifier) obj						local.get $obj						return));; (JSLiteral) true						i32.const 1						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue));; (JSProperty) property: nextObjectWithGC -> function(r...;; (FunctionExpression) function(reason, obj) { 	var limit = obj...(func $nextObjectWithGC						(local $reason i32)						(local $temp i32)						(local $obj i32)						(local $limit i32)						;; (IfStatement) if (this.newSpaceCount <= limit) {return...;; (BinaryExpression) this.newSpaceCount <= limit;; (StaticMemberExpression) this.newSpaceCount;; (JSIdentifier) newSpaceCount						local.get $newSpaceCount;; (JSIdentifier) limit						local.get $limit						i32.le_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return));; (IfStatement) if (obj.oop < 0) {this.fullGC(reason)};; (BinaryExpression) obj.oop < 0;; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 0						i32.const 0						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.fullGC(reason);; (CallExpression) this.fullGC(reason)						local.get $this;; (JSIdentifier) reason						local.get $reason						call $fullGC));; (ReturnStatement) return this.partialGC(reason);; (CallExpression) this.partialGC(reason)						local.get $this;; (JSIdentifier) reason						local.get $reason						call $partialGC						return);; (JSProperty) property: nextObjectWithGCFor -> functio...;; (FunctionExpression) function(obj, clsObj) { 	if (!this.hasNe...(func $nextObjectWithGCFor						(local $obj i32)						(local $clsObj i32)						(local $temp i32)						;; (IfStatement) if (!this.hasNewInstances[clsObj.oop]) {...;; (UnaryExpression) !this.hasNewInstances[clsObj.oop];; (ComputedMemberExpression) this.hasNewInstances[clsObj.oop];; (StaticMemberExpression) this.hasNewInstances;; (JSIdentifier) hasNewInstances						local.get $hasNewInstances;; (StaticMemberExpression) clsObj.oop;; (JSIdentifier) oop						local.get $oop						i32.const 4						i32.mul						i32.add						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return))						;; unwritable: (ReturnStatement) return this.nextObjectWithGC('instance o);; (JSProperty) property: allInstancesOf -> function(cls...;; (FunctionExpression) function(clsObj) { 	var obj = this.first...(func $allInstancesOf						(local $clsObj i32)						(local $temp i32)						(local $obj i32)						(local $result i32)						;; (WhileStatement) while (obj) {if (obj.sqClass === clsObj)...						(loop $loop_1;; (BlockStatement) if (obj.sqClass === clsObj) {result.push...;; (IfStatement) if (obj.sqClass === clsObj) {result.push...;; (BinaryExpression) obj.sqClass === clsObj;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (JSIdentifier) clsObj						local.get $clsObj						i32.eq						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) result.push(obj);; (CallExpression) result.push(obj)						local.get $result;; (JSIdentifier) obj						local.get $obj						call $push));; (ExpressionStatement) obj = obj.nextObject || this.nextObjectW...;; (AssignmentExpression) obj = obj.nextObject || this.nextObjectW...;; (BinaryExpression) obj.nextObject || this.nextObjectWithGCF...;; (StaticMemberExpression) obj.nextObject;; (JSIdentifier) nextObject						local.get $nextObject;; (CallExpression) this.nextObjectWithGCFor(obj, clsObj)						local.get $this;; (JSIdentifier) obj						local.get $obj;; (JSIdentifier) clsObj						local.get $clsObj						call $nextObjectWithGCFor						i32.or						local.set $obj;; (JSIdentifier) obj						local.get $obj						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ReturnStatement) return result;; (JSIdentifier) result						local.get $result						return);; (JSProperty) property: writeToBuffer -> function() { ...;; (FunctionExpression) function() { 	var headerSize = 64, data ...(func $writeToBuffer						(local $data i32)						(local $writeWord i32)						(local $temp i32)						(local $n i32)						(local $pos i32)						(local $headerSize i32)						(local $obj i32)						;; (ExpressionStatement) writeWord(this.formatVersion());; (CallExpression) writeWord(this.formatVersion());; (CallExpression) this.formatVersion()						local.get $this						call $formatVersion						call $writeWord;; (ExpressionStatement) writeWord(headerSize);; (CallExpression) writeWord(headerSize);; (JSIdentifier) headerSize						local.get $headerSize						call $writeWord;; (ExpressionStatement) writeWord(this.oldSpaceBytes);; (CallExpression) writeWord(this.oldSpaceBytes);; (StaticMemberExpression) this.oldSpaceBytes;; (JSIdentifier) oldSpaceBytes						local.get $oldSpaceBytes						call $writeWord;; (ExpressionStatement) writeWord(this.firstOldObject.addr());; (CallExpression) writeWord(this.firstOldObject.addr());; (CallExpression) this.firstOldObject.addr()						local.get $firstOldObject						call $addr						call $writeWord;; (ExpressionStatement) writeWord(this.objectToOop(this.specialO...;; (CallExpression) writeWord(this.objectToOop(this.specialO...;; (CallExpression) this.objectToOop(this.specialObjectsArra...						local.get $this;; (StaticMemberExpression) this.specialObjectsArray;; (JSIdentifier) specialObjectsArray						local.get $specialObjectsArray						call $objectToOop						call $writeWord;; (ExpressionStatement) writeWord(this.lastHash);; (CallExpression) writeWord(this.lastHash);; (StaticMemberExpression) this.lastHash;; (JSIdentifier) lastHash						local.get $lastHash						call $writeWord;; (ExpressionStatement) writeWord(800 << 16 + 600);; (CallExpression) writeWord(800 << 16 + 600);; (BinaryExpression) 800 << 16 + 600;; (BinaryExpression) 800 << 16;; (JSLiteral) 800						i32.const 800;; (JSLiteral) 16						i32.const 16						i32.shl;; (JSLiteral) 600						i32.const 600						i32.add						call $writeWord;; (WhileStatement) while (pos < headerSize) {writeWord(0)}						(loop $loop_1;; (ExpressionStatement) writeWord(0);; (CallExpression) writeWord(0);; (JSLiteral) 0						i32.const 0						call $writeWord;; (BinaryExpression) pos < headerSize;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) headerSize						local.get $headerSize						i32.lt_u						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (WhileStatement) while (obj) {pos = obj.writeTo(data, pos...						(loop $loop_2;; (BlockStatement) pos = obj.writeTo(data, pos, this) obj =...;; (ExpressionStatement) pos = obj.writeTo(data, pos, this);; (AssignmentExpression) pos = obj.writeTo(data, pos, this);; (CallExpression) obj.writeTo(data, pos, this)						local.get $obj;; (JSIdentifier) data						local.get $data;; (JSIdentifier) pos						local.get $pos;; (ThisExpression) this						call $writeTo						local.set $pos;; (ExpressionStatement) obj = obj.nextObject;; (AssignmentExpression) obj = obj.nextObject;; (StaticMemberExpression) obj.nextObject;; (JSIdentifier) nextObject						local.get $nextObject						local.set $obj;; (ExpressionStatement) n++;; (UpdateExpression) n++;; (JSIdentifier) n						local.get $n						i32.const 1						i32.add;; (JSIdentifier) obj						local.get $obj						i32.const 0						i32.eq						br_if $loop_2)						(block $loop_2_continue);; (IfStatement) if (pos !== data.byteLength) {throw Erro...;; (BinaryExpression) pos !== data.byteLength;; (JSIdentifier) pos						local.get $pos;; (StaticMemberExpression) data.byteLength;; (JSIdentifier) byteLength						local.get $byteLength						i32.ne						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('wrong image size')						unreachable));; (IfStatement) if (n !== this.oldSpaceCount) {throw Err...;; (BinaryExpression) n !== this.oldSpaceCount;; (JSIdentifier) n						local.get $n;; (StaticMemberExpression) this.oldSpaceCount;; (JSIdentifier) oldSpaceCount						local.get $oldSpaceCount						i32.ne						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('wrong object count')						unreachable));; (ReturnStatement) return data.buffer;; (StaticMemberExpression) data.buffer;; (JSIdentifier) buffer						local.get $buffer						return);; (JSProperty) property: objectToOop -> function(obj) {...;; (FunctionExpression) function(obj) { 	if (typeof obj === 'num...(func $objectToOop						(local $obj i32)						(local $temp i32)												;; unwritable: (IfStatement) if (typeof obj === 'number') {return obj;; (IfStatement) if (obj.oop < 0) {an active DebuggerStat...;; (BinaryExpression) obj.oop < 0;; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 0						i32.const 0						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) an active DebuggerStatement with propert...;; (DebuggerStatement) an active DebuggerStatement with propert...;; (ThrowStatement) throw Error('temporary oop')						unreachable));; (ReturnStatement) return obj.oop;; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop						return);; (JSProperty) property: bytesLeft -> function() { 	ret...;; (FunctionExpression) function() { 	return this.totalMemory - ...(func $bytesLeft						(local $temp i32)						;; (ReturnStatement) return this.totalMemory - this.oldSpaceB...;; (BinaryExpression) this.totalMemory - this.oldSpaceBytes;; (StaticMemberExpression) this.totalMemory;; (JSIdentifier) totalMemory						local.get $totalMemory;; (StaticMemberExpression) this.oldSpaceBytes;; (JSIdentifier) oldSpaceBytes						local.get $oldSpaceBytes						i32.sub						return);; (JSProperty) property: formatVersion -> function() { ...;; (FunctionExpression) function() { 	return this.isSpur ? 6521 ...(func $formatVersion						(local $temp i32)						;; (ReturnStatement) return this.isSpur ? 6521 : this.hasClos...;; (ConditionalExpression) this.isSpur ? 6521 : this.hasClosures ? ...;; (StaticMemberExpression) this.isSpur;; (JSIdentifier) isSpur						local.get $isSpur						i32.const 1						i32.eq						(if (then;; (JSLiteral) 6521						i32.const 6521)						(else;; (ConditionalExpression) this.hasClosures ? 6504 : 6502;; (StaticMemberExpression) this.hasClosures;; (JSIdentifier) hasClosures						local.get $hasClosures						i32.const 1						i32.eq						(if (then;; (JSLiteral) 6504						i32.const 6504)						(else;; (JSLiteral) 6502						i32.const 6502						))						))						return);; (JSProperty) property: segmentVersion -> function() {...;; (FunctionExpression) function() { 	var dnu = this.specialObje...(func $segmentVersion						(local $dnu i32)						(local $wholeWord i32)						(local $temp i32)						;; (ReturnStatement) return this.formatVersion() | wholeWord[...;; (BinaryExpression) this.formatVersion() | wholeWord[0] & 4....;; (CallExpression) this.formatVersion()						local.get $this						call $formatVersion;; (BinaryExpression) wholeWord[0] & 4.27819008e9;; (ComputedMemberExpression) wholeWord[0];; (JSIdentifier) wholeWord						local.get $wholeWord;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add;; (JSLiteral) 4.27819008e9						i32.const 4278190080						i32.and						i32.or						return);; (JSProperty) property: loadImageSegment -> function(s...;; (FunctionExpression) function(segmentWordArray, outPointerArr...(func $loadImageSegment						(local $nativeFloats i32)						(local $fakeClsOop i32)						(local $bits i32)						(local $i i32)						(local $floatClass i32)						(local $hash i32)						(local $roots i32)						(local $temp i32)						(local $oop i32)						(local $oopMap i32)						(local $nWords i32)						(local $version i32)						(local $classInt i32)						(local $outPointerArray i32)						(local $readWord i32)						(local $rawBits i32)						(local $endMarker i32)						(local $oopOffset i32)						(local $segmentWordArray i32)						(local $header i32)						(local $prevObj i32)						(local $data i32)						(local $littleEndian i32)						(local $format i32)						(local $object i32)						(local $compactClassOops i32)						(local $pos i32)						(local $compactClasses i32)						(local $obj i32)						(local $readBits i32)												;; unwritable: (IfStatement) if (version & 65535 !== 6502) {littleEnd;; (ExpressionStatement) this.tenureIfYoung(segmentWordArray);; (CallExpression) this.tenureIfYoung(segmentWordArray)						local.get $this;; (JSIdentifier) segmentWordArray						local.get $segmentWordArray						call $tenureIfYoung;; (WhileStatement) while (pos < data.byteLength) {var nWord...						(loop $loop_1;; (BlockStatement) var nWords = 0, classInt = 0, header = r...;; (VariableDeclaration) var nWords = 0, classInt = 0, header = r...;; (VariableDeclarator) nWords = 0;; (JSLiteral) 0						i32.const 0						local.set $nWords;; (VariableDeclarator) classInt = 0;; (JSLiteral) 0						i32.const 0						local.set $classInt;; (VariableDeclarator) header = readWord();; (CallExpression) readWord()						call $readWord						local.set $header;; (SwitchStatement) switch (header & Squeak.HeaderTypeMask) ...header & Squeak.HeaderTypeMask						local.set $temp;; (SwitchCase)  case Squeak.HeaderTypeSizeAndClass: nWo...						local.get $temp;; (StaticMemberExpression) Squeak.HeaderTypeSizeAndClass;; (JSIdentifier) HeaderTypeSizeAndClass						local.get $HeaderTypeSizeAndClass						i32.eq						(if (then ;; (ExpressionStatement) nWords = header >>> 2;; (AssignmentExpression) nWords = header >>> 2;; (BinaryExpression) header >>> 2;; (JSIdentifier) header						local.get $header;; (JSLiteral) 2						i32.const 2						i32.shr_u						local.set $nWords;; (ExpressionStatement) classInt = readWord();; (AssignmentExpression) classInt = readWord();; (CallExpression) readWord()						call $readWord						local.set $classInt;; (ExpressionStatement) header = readWord();; (AssignmentExpression) header = readWord();; (CallExpression) readWord()						call $readWord						local.set $header;; (BreakStatement) break						));; (SwitchCase)  case Squeak.HeaderTypeClass: classInt =...						local.get $temp;; (StaticMemberExpression) Squeak.HeaderTypeClass;; (JSIdentifier) HeaderTypeClass						local.get $HeaderTypeClass						i32.eq						(if (then ;; (ExpressionStatement) classInt = header - Squeak.HeaderTypeCla...;; (AssignmentExpression) classInt = header - Squeak.HeaderTypeCla...;; (BinaryExpression) header - Squeak.HeaderTypeClass;; (JSIdentifier) header						local.get $header;; (StaticMemberExpression) Squeak.HeaderTypeClass;; (JSIdentifier) HeaderTypeClass						local.get $HeaderTypeClass						i32.sub						local.set $classInt;; (ExpressionStatement) header = readWord();; (AssignmentExpression) header = readWord();; (CallExpression) readWord()						call $readWord						local.set $header;; (ExpressionStatement) nWords = header >>> 2 & 63;; (AssignmentExpression) nWords = header >>> 2 & 63;; (BinaryExpression) header >>> 2 & 63;; (BinaryExpression) header >>> 2;; (JSIdentifier) header						local.get $header;; (JSLiteral) 2						i32.const 2						i32.shr_u;; (JSLiteral) 63						i32.const 63						i32.and						local.set $nWords;; (BreakStatement) break						));; (SwitchCase)  case Squeak.HeaderTypeShort: nWords = h...						local.get $temp;; (StaticMemberExpression) Squeak.HeaderTypeShort;; (JSIdentifier) HeaderTypeShort						local.get $HeaderTypeShort						i32.eq						(if (then ;; (ExpressionStatement) nWords = header >>> 2 & 63;; (AssignmentExpression) nWords = header >>> 2 & 63;; (BinaryExpression) header >>> 2 & 63;; (BinaryExpression) header >>> 2;; (JSIdentifier) header						local.get $header;; (JSLiteral) 2						i32.const 2						i32.shr_u;; (JSLiteral) 63						i32.const 63						i32.and						local.set $nWords;; (ExpressionStatement) classInt = header >>> 12 & 31;; (AssignmentExpression) classInt = header >>> 12 & 31;; (BinaryExpression) header >>> 12 & 31;; (BinaryExpression) header >>> 12;; (JSIdentifier) header						local.get $header;; (JSLiteral) 12						i32.const 12						i32.shr_u;; (JSLiteral) 31						i32.const 31						i32.and						local.set $classInt;; (BreakStatement) break						));; (SwitchCase)  case Squeak.HeaderTypeFree: throw Error...						local.get $temp;; (StaticMemberExpression) Squeak.HeaderTypeFree;; (JSIdentifier) HeaderTypeFree						local.get $HeaderTypeFree						i32.eq						(if (then ;; (ThrowStatement) throw Error('Unexpected free block')						unreachable						));; (ExpressionStatement) nWords--;; (UpdateExpression) nWords--;; (JSIdentifier) nWords						local.get $nWords						i32.const 1						i32.sub;; (VariableDeclaration) var oop = pos, format = header >>> 8 & 1...;; (VariableDeclarator) oop = pos;; (JSIdentifier) pos						local.get $pos						local.set $oop;; (VariableDeclarator) format = header >>> 8 & 15;; (BinaryExpression) header >>> 8 & 15;; (BinaryExpression) header >>> 8;; (JSIdentifier) header						local.get $header;; (JSLiteral) 8						i32.const 8						i32.shr_u;; (JSLiteral) 15						i32.const 15						i32.and						local.set $format;; (VariableDeclarator) hash = header >>> 17 & 4095;; (BinaryExpression) header >>> 17 & 4095;; (BinaryExpression) header >>> 17;; (JSIdentifier) header						local.get $header;; (JSLiteral) 17						i32.const 17						i32.shr_u;; (JSLiteral) 4095						i32.const 4095						i32.and						local.set $hash;; (VariableDeclarator) bits = readBits(nWords, format);; (CallExpression) readBits(nWords, format);; (JSIdentifier) nWords						local.get $nWords;; (JSIdentifier) format						local.get $format						call $readBits						local.set $bits;; (VariableDeclaration) var object = new Squeak.Object();; (VariableDeclarator) object = new Squeak.Object();; (NewExpression) new Squeak.Object()						unreachable						local.set $object;; (ExpressionStatement) object.initFromImage(oop + oopOffset, cl...;; (CallExpression) object.initFromImage(oop + oopOffset, cl...						local.get $object;; (BinaryExpression) oop + oopOffset;; (JSIdentifier) oop						local.get $oop;; (JSIdentifier) oopOffset						local.get $oopOffset						i32.add;; (JSIdentifier) classInt						local.get $classInt;; (JSIdentifier) format						local.get $format;; (JSIdentifier) hash						local.get $hash						call $initFromImage;; (ExpressionStatement) prevObj.nextObject = object;; (AssignmentExpression) prevObj.nextObject = object;; (JSIdentifier) object						local.get $object						local.set $nextObject;; (ExpressionStatement) this.oldSpaceCount++;; (UpdateExpression) this.oldSpaceCount++;; (StaticMemberExpression) this.oldSpaceCount;; (JSIdentifier) oldSpaceCount						local.get $oldSpaceCount						i32.const 1						i32.add;; (ExpressionStatement) prevObj = object;; (AssignmentExpression) prevObj = object;; (JSIdentifier) object						local.get $object						local.set $prevObj;; (ExpressionStatement) oopMap[oop] = object;; (AssignmentExpression) oopMap[oop] = object						local.get $'oopMap';; (JSIdentifier) oop						local.get $oop;; (JSIdentifier) object						local.get $object						call $atPut;; (ExpressionStatement) rawBits[oop + oopOffset] = bits;; (AssignmentExpression) rawBits[oop + oopOffset] = bits						local.get $'rawBits';; (BinaryExpression) oop + oopOffset;; (JSIdentifier) oop						local.get $oop;; (JSIdentifier) oopOffset						local.get $oopOffset						i32.add;; (JSIdentifier) bits						local.get $bits						call $atPut;; (BinaryExpression) pos < data.byteLength;; (JSIdentifier) pos						local.get $pos;; (StaticMemberExpression) data.byteLength;; (JSIdentifier) byteLength						local.get $byteLength						i32.lt_u						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ExpressionStatement) object.nextObject = endMarker;; (AssignmentExpression) object.nextObject = endMarker;; (JSIdentifier) endMarker						local.get $endMarker						local.set $nextObject;; (ForStatement) for (var i = 0; i < outPointerArray.poin...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_2;; (ExpressionStatement) oopMap[2.147483652e9 + i * 4] = outPoint...;; (AssignmentExpression) oopMap[2.147483652e9 + i * 4] = outPoint...						local.get $'oopMap';; (BinaryExpression) 2.147483652e9 + i * 4;; (JSLiteral) 2.147483652e9						i32.const 2147483652;; (BinaryExpression) i * 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.mul						i32.add;; (ComputedMemberExpression) outPointerArray.pointers[i];; (StaticMemberExpression) outPointerArray.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < outPointerArray.pointers.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) outPointerArray.pointers.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_2);; (ExpressionStatement) segmentWordArray.words = new Uint32Array...;; (AssignmentExpression) segmentWordArray.words = new Uint32Array...;; (NewExpression) new Uint32Array([segmentWordArray.words[...						unreachable						local.set $words;; (DoWhileStatement) an active DoWhileStatement with properti...;; (ReturnStatement) return roots;; (JSIdentifier) roots						local.get $roots						return);; (JSProperty) property: initSpurOverrides -> function(...;; (FunctionExpression) function() { 	this.registerObject = this...(func $initSpurOverrides						(local $temp i32)						;; (ExpressionStatement) this.registerObject = this.registerObjec...;; (AssignmentExpression) this.registerObject = this.registerObjec...;; (StaticMemberExpression) this.registerObjectSpur;; (JSIdentifier) registerObjectSpur						local.get $registerObjectSpur						local.set $registerObject;; (ExpressionStatement) this.writeToBuffer = this.writeToBufferS...;; (AssignmentExpression) this.writeToBuffer = this.writeToBufferS...;; (StaticMemberExpression) this.writeToBufferSpur;; (JSIdentifier) writeToBufferSpur						local.get $writeToBufferSpur						local.set $writeToBuffer);; (JSProperty) property: spurClassTable -> function(oop...;; (FunctionExpression) function(oopMap, rawBits, classPages, sp...(func $spurClassTable						(local $classPages i32)						(local $p i32)						(local $knownClass i32)						(local $temp i32)						(local $classIndex i32)						(local $classes i32)						(local $i i32)						(local $oopMap i32)						(local $key i32)						(local $splObjs i32)						(local $nil i32)						(local $rawBits i32)						(local $page i32)						(local $entry i32)						;; (ForStatement) for (var p = 0; p < 4096; p++) {var page...;; (VariableDeclaration) var p = 0;; (VariableDeclarator) p = 0;; (JSLiteral) 0						i32.const 0						local.set $p						(loop $loop_1;; (BlockStatement) var page = oopMap[classPages[p]] if (pag...;; (VariableDeclaration) var page = oopMap[classPages[p]];; (VariableDeclarator) page = oopMap[classPages[p]];; (ComputedMemberExpression) oopMap[classPages[p]];; (JSIdentifier) oopMap						local.get $oopMap;; (ComputedMemberExpression) classPages[p];; (JSIdentifier) classPages						local.get $classPages;; (JSIdentifier) p						local.get $p						i32.const 4						i32.mul						i32.add						i32.const 4						i32.mul						i32.add						local.set $page;; (IfStatement) if (page.oop) {page = rawBits[page.oop]};; (StaticMemberExpression) page.oop;; (JSIdentifier) oop						local.get $oop						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) page = rawBits[page.oop];; (AssignmentExpression) page = rawBits[page.oop];; (ComputedMemberExpression) rawBits[page.oop];; (JSIdentifier) rawBits						local.get $rawBits;; (StaticMemberExpression) page.oop;; (JSIdentifier) oop						local.get $oop						i32.const 4						i32.mul						i32.add						local.set $page));; (IfStatement) if (page.length === 1024) {for (var i = ...;; (BinaryExpression) page.length === 1024;; (StaticMemberExpression) page.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 1024						i32.const 1024						i32.eq						i32.const 0						i32.ne						(if (then;; (ForStatement) for (var i = 0; i < 1024; i++) {var entr...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_2;; (BlockStatement) var entry = oopMap[page[i]] if (!entry) ...;; (VariableDeclaration) var entry = oopMap[page[i]];; (VariableDeclarator) entry = oopMap[page[i]];; (ComputedMemberExpression) oopMap[page[i]];; (JSIdentifier) oopMap						local.get $oopMap;; (ComputedMemberExpression) page[i];; (JSIdentifier) page						local.get $page;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						i32.const 4						i32.mul						i32.add						local.set $entry;; (IfStatement) if (!entry) {throw Error('Invalid class ...;; (UnaryExpression) !entry;; (JSIdentifier) entry						local.get $entry						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('Invalid class table entry (...						unreachable));; (IfStatement) if (entry !== nil) {var classIndex = p *...;; (BinaryExpression) entry !== nil;; (JSIdentifier) entry						local.get $entry;; (JSIdentifier) nil						local.get $nil						i32.ne						i32.const 0						i32.ne						(if (then;; (BlockStatement) var classIndex = p * 1024 + i classes[cl...;; (VariableDeclaration) var classIndex = p * 1024 + i;; (VariableDeclarator) classIndex = p * 1024 + i;; (BinaryExpression) p * 1024 + i;; (BinaryExpression) p * 1024;; (JSIdentifier) p						local.get $p;; (JSLiteral) 1024						i32.const 1024						i32.mul;; (JSIdentifier) i						local.get $i						i32.add						local.set $classIndex;; (ExpressionStatement) classes[classIndex] = entry;; (AssignmentExpression) classes[classIndex] = entry						local.get $'classes';; (JSIdentifier) classIndex						local.get $classIndex;; (JSIdentifier) entry						local.get $entry						call $atPut));; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < 1024;; (JSIdentifier) i						local.get $i;; (JSLiteral) 1024						i32.const 1024						i32.lt_u						i32.const 0						br_if $loop_2)));; (UpdateExpression) p++;; (JSIdentifier) p						local.get $p						i32.const 1						i32.add;; (BinaryExpression) p < 4096;; (JSIdentifier) p						local.get $p;; (JSLiteral) 4096						i32.const 4096						i32.lt_u						i32.const 0						br_if $loop_1);; (ForInStatement) an active ForInStatement with properties...;; (ExpressionStatement) classes[3] = classes[1];; (AssignmentExpression) classes[3] = classes[1]						local.get $'classes';; (JSLiteral) 3						i32.const 3;; (ComputedMemberExpression) classes[1];; (JSIdentifier) classes						local.get $classes;; (JSLiteral) 1						i32.const 1						i32.const 4						i32.mul						i32.add						call $atPut;; (ExpressionStatement) this.classTable = classes;; (AssignmentExpression) this.classTable = classes;; (JSIdentifier) classes						local.get $classes						local.set $classTable;; (ExpressionStatement) this.classTableIndex = 1024;; (AssignmentExpression) this.classTableIndex = 1024;; (JSLiteral) 1024						i32.const 1024						local.set $classTableIndex;; (ReturnStatement) return classes;; (JSIdentifier) classes						local.get $classes						return);; (JSProperty) property: enterIntoClassTable -> functio...;; (FunctionExpression) function(newClass) { 	var index = this.c...(func $enterIntoClassTable						(local $newClass i32)						(local $temp i32)						(local $index i32)						(local $table i32)						;; (WhileStatement) while (index <= 4194303) {if (!table[ind...						(loop $loop_1;; (BlockStatement) if (!table[index]) {table[index] = newCl...;; (IfStatement) if (!table[index]) {table[index] = newCl...;; (UnaryExpression) !table[index];; (ComputedMemberExpression) table[index];; (JSIdentifier) table						local.get $table;; (JSIdentifier) index						local.get $index						i32.const 4						i32.mul						i32.add						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) table[index] = newClass newClass.hash = ...;; (ExpressionStatement) table[index] = newClass;; (AssignmentExpression) table[index] = newClass						local.get $'table';; (JSIdentifier) index						local.get $index;; (JSIdentifier) newClass						local.get $newClass						call $atPut;; (ExpressionStatement) newClass.hash = index;; (AssignmentExpression) newClass.hash = index;; (JSIdentifier) index						local.get $index						local.set $hash;; (ExpressionStatement) this.classTableIndex = index;; (AssignmentExpression) this.classTableIndex = index;; (JSIdentifier) index						local.get $index						local.set $classTableIndex;; (ReturnStatement) return index;; (JSIdentifier) index						local.get $index						return));; (ExpressionStatement) index++;; (UpdateExpression) index++;; (JSIdentifier) index						local.get $index						i32.const 1						i32.add;; (BinaryExpression) index <= 4194303;; (JSIdentifier) index						local.get $index;; (JSLiteral) 4194303						i32.const 4194303						i32.le_u						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue)						;; unwritable: (ExpressionStatement) console.error('class table full?');; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return);; (JSProperty) property: initCharacterTable -> function...;; (FunctionExpression) function(characterClass) { 	characterCla...(func $initCharacterTable						(local $characterClass i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) characterClass.classInstProto('Character;; (ExpressionStatement) this.characterClass = characterClass;; (AssignmentExpression) this.characterClass = characterClass;; (JSIdentifier) characterClass						local.get $characterClass						local.set $characterClass;; (ExpressionStatement) this.characterTable = {};; (AssignmentExpression) this.characterTable = {};; (ObjectExpression) {}						local.set $characterTable);; (JSProperty) property: getCharacter -> function(unico...;; (FunctionExpression) function(unicode) { 	var char = this.cha...(func $getCharacter						(local $temp i32)						(local $char i32)						(local $unicode i32)						;; (IfStatement) if (!char) {char = new this.characterCla...;; (UnaryExpression) !char;; (JSIdentifier) char						local.get $char						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) char = new this.characterClass.instProto...;; (ExpressionStatement) char = new this.characterClass.instProto...;; (AssignmentExpression) char = new this.characterClass.instProto...;; (NewExpression) new this.characterClass.instProto()						unreachable						local.set $char;; (ExpressionStatement) char.initInstanceOfChar(this.characterCl...;; (CallExpression) char.initInstanceOfChar(this.characterCl...						local.get $char;; (StaticMemberExpression) this.characterClass;; (JSIdentifier) characterClass						local.get $characterClass;; (JSIdentifier) unicode						local.get $unicode						call $initInstanceOfChar;; (ExpressionStatement) this.characterTable[unicode] = char;; (AssignmentExpression) this.characterTable[unicode] = char						local.get $this;; (JSIdentifier) unicode						local.get $unicode;; (JSIdentifier) char						local.get $char						call $atPut));; (ReturnStatement) return char;; (JSIdentifier) char						local.get $char						return);; (JSProperty) property: ensureClassesInTable -> functi...;; (FunctionExpression) function() { 	var obj = this.firstOldObj...(func $ensureClassesInTable						(local $maxIndex i32)						(local $temp i32)						(local $cls i32)						(local $obj i32)						;; (WhileStatement) while (obj) {var cls = obj.sqClass if (c...						(loop $loop_1;; (BlockStatement) var cls = obj.sqClass if (cls.hash === 0...;; (VariableDeclaration) var cls = obj.sqClass;; (VariableDeclarator) cls = obj.sqClass;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass						local.set $cls;; (IfStatement) if (cls.hash === 0) {this.enterIntoClass...;; (BinaryExpression) cls.hash === 0;; (StaticMemberExpression) cls.hash;; (JSIdentifier) hash						local.get $hash;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.enterIntoClassTable(cls);; (CallExpression) this.enterIntoClassTable(cls)						local.get $this;; (JSIdentifier) cls						local.get $cls						call $enterIntoClassTable));; (IfStatement) if (cls.hash > maxIndex) {maxIndex = cls...;; (BinaryExpression) cls.hash > maxIndex;; (StaticMemberExpression) cls.hash;; (JSIdentifier) hash						local.get $hash;; (JSIdentifier) maxIndex						local.get $maxIndex						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) maxIndex = cls.hash;; (AssignmentExpression) maxIndex = cls.hash;; (StaticMemberExpression) cls.hash;; (JSIdentifier) hash						local.get $hash						local.set $maxIndex));; (IfStatement) if (this.classTable[cls.hash] !== cls) {...;; (BinaryExpression) this.classTable[cls.hash] !== cls;; (ComputedMemberExpression) this.classTable[cls.hash];; (StaticMemberExpression) this.classTable;; (JSIdentifier) classTable						local.get $classTable;; (StaticMemberExpression) cls.hash;; (JSIdentifier) hash						local.get $hash						i32.const 4						i32.mul						i32.add;; (JSIdentifier) cls						local.get $cls						i32.ne						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('Class not in class table')						unreachable));; (ExpressionStatement) obj = obj.nextObject;; (AssignmentExpression) obj = obj.nextObject;; (StaticMemberExpression) obj.nextObject;; (JSIdentifier) nextObject						local.get $nextObject						local.set $obj;; (JSIdentifier) obj						local.get $obj						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ReturnStatement) return maxIndex >> 10 + 1;; (BinaryExpression) maxIndex >> 10 + 1;; (BinaryExpression) maxIndex >> 10;; (JSIdentifier) maxIndex						local.get $maxIndex;; (JSLiteral) 10						i32.const 10						i32.shr_s;; (JSLiteral) 1						i32.const 1						i32.add						return);; (JSProperty) property: classTableBytes -> function(nu...;; (FunctionExpression) function(numPages) { 	return 4 + 4104 + ...(func $classTableBytes						(local $numPages i32)						(local $temp i32)						;; (ReturnStatement) return 4 + 4104 + numPages * 4 + 1024 * ...;; (BinaryExpression) 4 + 4104 + numPages * 4 + 1024 * 4;; (BinaryExpression) 4 + 4104 + numPages * 4 + 1024;; (BinaryExpression) 4 + 4104;; (JSLiteral) 4						i32.const 4;; (JSLiteral) 4104						i32.const 4104						i32.add;; (BinaryExpression) numPages * 4 + 1024;; (JSIdentifier) numPages						local.get $numPages;; (BinaryExpression) 4 + 1024;; (JSLiteral) 4						i32.const 4;; (JSLiteral) 1024						i32.const 1024						i32.add						i32.mul						i32.add;; (JSLiteral) 4						i32.const 4						i32.mul						return);; (JSProperty) property: writeFreeLists -> function(dat...;; (FunctionExpression) function(data, pos, littleEndian, oopOff...(func $writeFreeLists						(local $data i32)						(local $temp i32)						(local $oopOffset i32)						(local $pos i32)						(local $littleEndian i32)						;; (ExpressionStatement) data.setUint32(pos, 167772178, littleEnd...;; (CallExpression) data.setUint32(pos, 167772178, littleEnd...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 167772178						i32.const 167772178;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (ExpressionStatement) data.setUint32(pos, 536870912, littleEnd...;; (CallExpression) data.setUint32(pos, 536870912, littleEnd...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 536870912						i32.const 536870912;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (ExpressionStatement) pos += 32 * 4;; (AssignmentExpression) pos += 32 * 4;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) 32 * 4;; (JSLiteral) 32						i32.const 32;; (JSLiteral) 4						i32.const 4						i32.mul						i32.add						local.set $pos;; (ReturnStatement) return pos;; (JSIdentifier) pos						local.get $pos						return);; (JSProperty) property: writeClassTable -> function(da...;; (FunctionExpression) function(data, pos, littleEndian, objToO...(func $writeClassTable						(local $p i32)						(local $data i32)						(local $temp i32)						(local $numPages i32)						(local $pos i32)						(local $minorTableBytes i32)						(local $classObj i32)						(local $classID i32)						(local $i i32)						(local $objToOop i32)						(local $minorTableSlots i32)						(local $nilFalseTrueBytes i32)						(local $majorTableBytes i32)						(local $firstPageOop i32)						(local $majorTableSlots i32)						(local $littleEndian i32)						(local $freeListBytes i32)						;; (ExpressionStatement) data.setUint32(pos, majorTableSlots, lit...;; (CallExpression) data.setUint32(pos, majorTableSlots, lit...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) majorTableSlots						local.get $majorTableSlots;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (ExpressionStatement) data.setUint32(pos, 4.27819008e9, little...;; (CallExpression) data.setUint32(pos, 4.27819008e9, little...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4.27819008e9						i32.const 4278190080;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (ExpressionStatement) data.setUint32(pos, 33554448, littleEndi...;; (CallExpression) data.setUint32(pos, 33554448, littleEndi...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 33554448						i32.const 33554448;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (ExpressionStatement) data.setUint32(pos, 4.27819008e9, little...;; (CallExpression) data.setUint32(pos, 4.27819008e9, little...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4.27819008e9						i32.const 4278190080;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (ForStatement) for (var p = 0; p < numPages; p++) {data...;; (VariableDeclaration) var p = 0;; (VariableDeclarator) p = 0;; (JSLiteral) 0						i32.const 0						local.set $p						(loop $loop_1;; (BlockStatement) data.setUint32(pos, firstPageOop + p * m...;; (ExpressionStatement) data.setUint32(pos, firstPageOop + p * m...;; (CallExpression) data.setUint32(pos, firstPageOop + p * m...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) firstPageOop + p * minorTableBytes;; (JSIdentifier) firstPageOop						local.get $firstPageOop;; (BinaryExpression) p * minorTableBytes;; (JSIdentifier) p						local.get $p;; (JSIdentifier) minorTableBytes						local.get $minorTableBytes						i32.mul						i32.add;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (UpdateExpression) p++;; (JSIdentifier) p						local.get $p						i32.const 1						i32.add;; (BinaryExpression) p < numPages;; (JSIdentifier) p						local.get $p;; (JSIdentifier) numPages						local.get $numPages						i32.lt_u						i32.const 0						br_if $loop_1);; (ExpressionStatement) pos += majorTableSlots - numPages * 4;; (AssignmentExpression) pos += majorTableSlots - numPages * 4;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) majorTableSlots - numPages * 4;; (BinaryExpression) majorTableSlots - numPages;; (JSIdentifier) majorTableSlots						local.get $majorTableSlots;; (JSIdentifier) numPages						local.get $numPages						i32.sub;; (JSLiteral) 4						i32.const 4						i32.mul						i32.add						local.set $pos						;; unwritable: (ForStatement) for (var p = 0; p < numPages; p++) {data;; (ReturnStatement) return pos;; (JSIdentifier) pos						local.get $pos						return);; (JSProperty) property: writeToBufferSpur -> function(...;; (FunctionExpression) function() { 	var headerSize = 64, trail...(func $writeToBufferSpur						(local $data i32)						(local $temp i32)						(local $numPages i32)						(local $pos i32)						(local $trailerSize i32)						(local $time i32)						(local $start i32)						(local $hiddenSize i32)						(local $obj i32)						(local $n i32)						(local $littleEndian i32)						(local $freeListsSize i32)						(local $headerSize i32);; (FunctionDeclaration) function writeWord(word) {data.setUint32...;; (FunctionExpression) function(word) { 	data.setUint32(pos, wo...(func $writeWord	(local $word i32)	(local $temp i32)	;; (ExpressionStatement) data.setUint32(pos, word, littleEndian);; (CallExpression) data.setUint32(pos, word, littleEndian)						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) word						local.get $word;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos);; (FunctionDeclaration) function objToOop(obj) {if (typeof obj =...;; (FunctionExpression) function(obj) { 	if (typeof obj === 'num...(func $objToOop	(local $obj i32)	(local $temp i32)		;; unwritable: (IfStatement) if (typeof obj === 'number') {return obj;; (IfStatement) if (obj._format === 7) {if (obj.hash !==...;; (BinaryExpression) obj._format === 7;; (StaticMemberExpression) obj._format;; (JSIdentifier) _format						local.get $_format;; (JSLiteral) 7						i32.const 7						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (obj.hash !== obj.oop >> 2 || obj.oop...;; (IfStatement) if (obj.hash !== obj.oop >> 2 || obj.oop...;; (BinaryExpression) obj.hash !== obj.oop >> 2 || obj.oop & 3...;; (BinaryExpression) obj.hash !== obj.oop >> 2;; (StaticMemberExpression) obj.hash;; (JSIdentifier) hash						local.get $hash;; (BinaryExpression) obj.oop >> 2;; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 2						i32.const 2						i32.shr_s						i32.ne;; (BinaryExpression) obj.oop & 3 !== 2;; (BinaryExpression) obj.oop & 3;; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 3						i32.const 3						i32.and;; (JSLiteral) 2						i32.const 2						i32.ne						i32.or						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('Bad immediate char')						unreachable));; (ReturnStatement) return obj.oop;; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop						return));; (IfStatement) if (obj.oop < 0) {throw Error('temporary...;; (BinaryExpression) obj.oop < 0;; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 0						i32.const 0						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('temporary oop')						unreachable));; (ReturnStatement) return obj.oop < 48 ? obj.oop : obj.oop ...;; (ConditionalExpression) obj.oop < 48 ? obj.oop : obj.oop + hidde...;; (BinaryExpression) obj.oop < 48;; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 48						i32.const 48						i32.lt_u						i32.const 1						i32.eq						(if (then;; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop)						(else;; (BinaryExpression) obj.oop + hiddenSize;; (StaticMemberExpression) obj.oop;; (JSIdentifier) oop						local.get $oop;; (JSIdentifier) hiddenSize						local.get $hiddenSize						i32.add						))						return)						;; (EmptyStatement) ;; (EmptyStatement) ;; (ExpressionStatement) writeWord(this.formatVersion());; (CallExpression) writeWord(this.formatVersion());; (CallExpression) this.formatVersion()						local.get $this						call $formatVersion						call $writeWord;; (ExpressionStatement) writeWord(headerSize);; (CallExpression) writeWord(headerSize);; (JSIdentifier) headerSize						local.get $headerSize						call $writeWord;; (ExpressionStatement) writeWord(hiddenSize + this.oldSpaceByte...;; (CallExpression) writeWord(hiddenSize + this.oldSpaceByte...;; (BinaryExpression) hiddenSize + this.oldSpaceBytes + traile...;; (BinaryExpression) hiddenSize + this.oldSpaceBytes;; (JSIdentifier) hiddenSize						local.get $hiddenSize;; (StaticMemberExpression) this.oldSpaceBytes;; (JSIdentifier) oldSpaceBytes						local.get $oldSpaceBytes						i32.add;; (JSIdentifier) trailerSize						local.get $trailerSize						i32.add						call $writeWord;; (ExpressionStatement) writeWord(this.firstOldObject.addr());; (CallExpression) writeWord(this.firstOldObject.addr());; (CallExpression) this.firstOldObject.addr()						local.get $firstOldObject						call $addr						call $writeWord;; (ExpressionStatement) writeWord(objToOop(this.specialObjectsAr...;; (CallExpression) writeWord(objToOop(this.specialObjectsAr...;; (CallExpression) objToOop(this.specialObjectsArray);; (StaticMemberExpression) this.specialObjectsArray;; (JSIdentifier) specialObjectsArray						local.get $specialObjectsArray						call $objToOop						call $writeWord;; (ExpressionStatement) writeWord(this.lastHash);; (CallExpression) writeWord(this.lastHash);; (StaticMemberExpression) this.lastHash;; (JSIdentifier) lastHash						local.get $lastHash						call $writeWord;; (ExpressionStatement) this.savedHeaderWords.forEach(writeWord);; (CallExpression) this.savedHeaderWords.forEach(writeWord)						local.get $savedHeaderWords;; (JSIdentifier) writeWord						local.get $writeWord						call $forEach;; (ExpressionStatement) writeWord(hiddenSize + this.oldSpaceByte...;; (CallExpression) writeWord(hiddenSize + this.oldSpaceByte...;; (BinaryExpression) hiddenSize + this.oldSpaceBytes + traile...;; (BinaryExpression) hiddenSize + this.oldSpaceBytes;; (JSIdentifier) hiddenSize						local.get $hiddenSize;; (StaticMemberExpression) this.oldSpaceBytes;; (JSIdentifier) oldSpaceBytes						local.get $oldSpaceBytes						i32.add;; (JSIdentifier) trailerSize						local.get $trailerSize						i32.add						call $writeWord;; (WhileStatement) while (pos < headerSize) {writeWord(0)}						(loop $loop_1;; (ExpressionStatement) writeWord(0);; (CallExpression) writeWord(0);; (JSLiteral) 0						i32.const 0						call $writeWord;; (BinaryExpression) pos < headerSize;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) headerSize						local.get $headerSize						i32.lt_u						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ExpressionStatement) pos = obj.writeTo(data, pos, littleEndia...;; (AssignmentExpression) pos = obj.writeTo(data, pos, littleEndia...;; (CallExpression) obj.writeTo(data, pos, littleEndian, obj...						local.get $obj;; (JSIdentifier) data						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) littleEndian						local.get $littleEndian;; (JSIdentifier) objToOop						local.get $objToOop						call $writeTo						local.set $pos;; (ExpressionStatement) obj = obj.nextObject;; (AssignmentExpression) obj = obj.nextObject;; (StaticMemberExpression) obj.nextObject;; (JSIdentifier) nextObject						local.get $nextObject						local.set $obj;; (ExpressionStatement) n++;; (UpdateExpression) n++;; (JSIdentifier) n						local.get $n						i32.const 1						i32.add;; (ExpressionStatement) pos = obj.writeTo(data, pos, littleEndia...;; (AssignmentExpression) pos = obj.writeTo(data, pos, littleEndia...;; (CallExpression) obj.writeTo(data, pos, littleEndian, obj...						local.get $obj;; (JSIdentifier) data						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) littleEndian						local.get $littleEndian;; (JSIdentifier) objToOop						local.get $objToOop						call $writeTo						local.set $pos;; (ExpressionStatement) obj = obj.nextObject;; (AssignmentExpression) obj = obj.nextObject;; (StaticMemberExpression) obj.nextObject;; (JSIdentifier) nextObject						local.get $nextObject						local.set $obj;; (ExpressionStatement) n++;; (UpdateExpression) n++;; (JSIdentifier) n						local.get $n						i32.const 1						i32.add;; (ExpressionStatement) pos = obj.writeTo(data, pos, littleEndia...;; (AssignmentExpression) pos = obj.writeTo(data, pos, littleEndia...;; (CallExpression) obj.writeTo(data, pos, littleEndian, obj...						local.get $obj;; (JSIdentifier) data						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) littleEndian						local.get $littleEndian;; (JSIdentifier) objToOop						local.get $objToOop						call $writeTo						local.set $pos;; (ExpressionStatement) obj = obj.nextObject;; (AssignmentExpression) obj = obj.nextObject;; (StaticMemberExpression) obj.nextObject;; (JSIdentifier) nextObject						local.get $nextObject						local.set $obj;; (ExpressionStatement) n++;; (UpdateExpression) n++;; (JSIdentifier) n						local.get $n						i32.const 1						i32.add;; (ExpressionStatement) pos = this.writeFreeLists(data, pos, lit...;; (AssignmentExpression) pos = this.writeFreeLists(data, pos, lit...;; (CallExpression) this.writeFreeLists(data, pos, littleEnd...						local.get $this;; (JSIdentifier) data						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) littleEndian						local.get $littleEndian;; (JSIdentifier) objToOop						local.get $objToOop						call $writeFreeLists						local.set $pos;; (ExpressionStatement) pos = this.writeClassTable(data, pos, li...;; (AssignmentExpression) pos = this.writeClassTable(data, pos, li...;; (CallExpression) this.writeClassTable(data, pos, littleEn...						local.get $this;; (JSIdentifier) data						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) littleEndian						local.get $littleEndian;; (JSIdentifier) objToOop						local.get $objToOop;; (JSIdentifier) numPages						local.get $numPages						call $writeClassTable						local.set $pos;; (WhileStatement) while (obj) {pos = obj.writeTo(data, pos...						(loop $loop_2;; (BlockStatement) pos = obj.writeTo(data, pos, littleEndia...;; (ExpressionStatement) pos = obj.writeTo(data, pos, littleEndia...;; (AssignmentExpression) pos = obj.writeTo(data, pos, littleEndia...;; (CallExpression) obj.writeTo(data, pos, littleEndian, obj...						local.get $obj;; (JSIdentifier) data						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) littleEndian						local.get $littleEndian;; (JSIdentifier) objToOop						local.get $objToOop						call $writeTo						local.set $pos;; (ExpressionStatement) obj = obj.nextObject;; (AssignmentExpression) obj = obj.nextObject;; (StaticMemberExpression) obj.nextObject;; (JSIdentifier) nextObject						local.get $nextObject						local.set $obj;; (ExpressionStatement) n++;; (UpdateExpression) n++;; (JSIdentifier) n						local.get $n						i32.const 1						i32.add;; (JSIdentifier) obj						local.get $obj						i32.const 0						i32.eq						br_if $loop_2)						(block $loop_2_continue);; (ExpressionStatement) writeWord(1241513987);; (CallExpression) writeWord(1241513987);; (JSLiteral) 1241513987						i32.const 1241513987						call $writeWord;; (ExpressionStatement) writeWord(8388608);; (CallExpression) writeWord(8388608);; (JSLiteral) 8388608						i32.const 8388608						call $writeWord;; (ExpressionStatement) writeWord(0);; (CallExpression) writeWord(0);; (JSLiteral) 0						i32.const 0						call $writeWord;; (ExpressionStatement) writeWord(0);; (CallExpression) writeWord(0);; (JSLiteral) 0						i32.const 0						call $writeWord;; (IfStatement) if (pos !== data.byteLength) {throw Erro...;; (BinaryExpression) pos !== data.byteLength;; (JSIdentifier) pos						local.get $pos;; (StaticMemberExpression) data.byteLength;; (JSIdentifier) byteLength						local.get $byteLength						i32.ne						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('wrong image size')						unreachable));; (IfStatement) if (n !== this.oldSpaceCount) {throw Err...;; (BinaryExpression) n !== this.oldSpaceCount;; (JSIdentifier) n						local.get $n;; (StaticMemberExpression) this.oldSpaceCount;; (JSIdentifier) oldSpaceCount						local.get $oldSpaceCount						i32.ne						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('wrong object count')						unreachable))						;; unwritable: (ExpressionStatement) console.log('Wrote ' + n + ' objects in ;; (ReturnStatement) return data.buffer;; (StaticMemberExpression) data.buffer;; (JSIdentifier) buffer						local.get $buffer						return);; (JSProperty) property: initInstanceOf -> function(aCl...;; (FunctionExpression) function(aClass, indexableSize, hash, ni...(func $initInstanceOf						(local $indexableSize i32)						(local $hash i32)						(local $aClass i32)						(local $instSize i32)						(local $instSpec i32)						(local $temp i32)						(local $nilObj i32)						;; (ExpressionStatement) this.sqClass = aClass;; (AssignmentExpression) this.sqClass = aClass;; (JSIdentifier) aClass						local.get $aClass						local.set $sqClass;; (ExpressionStatement) this.hash = hash;; (AssignmentExpression) this.hash = hash;; (JSIdentifier) hash						local.get $hash						local.set $hash;; (ExpressionStatement) this._format = instSpec >> 7 & 15;; (AssignmentExpression) this._format = instSpec >> 7 & 15;; (BinaryExpression) instSpec >> 7 & 15;; (BinaryExpression) instSpec >> 7;; (JSIdentifier) instSpec						local.get $instSpec;; (JSLiteral) 7						i32.const 7						i32.shr_s;; (JSLiteral) 15						i32.const 15						i32.and						local.set $_format;; (IfStatement) if (this._format < 8) {if (this._format ...;; (BinaryExpression) this._format < 8;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format;; (JSLiteral) 8						i32.const 8						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (this._format != 6) {if (instSize + i...;; (IfStatement) if (this._format != 6) {if (instSize + i...;; (BinaryExpression) this._format != 6;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format;; (JSLiteral) 6						i32.const 6						i32.ne						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (instSize + indexableSize > 0) {this....;; (IfStatement) if (instSize + indexableSize > 0) {this....;; (BinaryExpression) instSize + indexableSize > 0;; (BinaryExpression) instSize + indexableSize;; (JSIdentifier) instSize						local.get $instSize;; (JSIdentifier) indexableSize						local.get $indexableSize						i32.add;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.pointers = this.fillArray(instSize ...;; (AssignmentExpression) this.pointers = this.fillArray(instSize ...;; (CallExpression) this.fillArray(instSize + indexableSize,...						local.get $this;; (BinaryExpression) instSize + indexableSize;; (JSIdentifier) instSize						local.get $instSize;; (JSIdentifier) indexableSize						local.get $indexableSize						i32.add;; (JSIdentifier) nilObj						local.get $nilObj						call $fillArray						local.set $pointers)))						(else;; (IfStatement) if (indexableSize > 0) {if (aClass.isFlo...;; (BinaryExpression) indexableSize > 0;; (JSIdentifier) indexableSize						local.get $indexableSize;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (IfStatement) if (aClass.isFloatClass) {this.isFloat =...;; (StaticMemberExpression) aClass.isFloatClass;; (JSIdentifier) isFloatClass						local.get $isFloatClass						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.isFloat = true this.float = 0 ;; (ExpressionStatement) this.isFloat = true;; (AssignmentExpression) this.isFloat = true;; (JSLiteral) true						i32.const 1						local.set $isFloat;; (ExpressionStatement) this.float = 0;; (AssignmentExpression) this.float = 0;; (JSLiteral) 0						i32.const 0.0						local.set $float)						(else;; (ExpressionStatement) this.words = new Uint32Array(indexableSi...;; (AssignmentExpression) this.words = new Uint32Array(indexableSi...;; (NewExpression) new Uint32Array(indexableSize)						unreachable						local.set $words)))))))						(else;; (IfStatement) if (indexableSize > 0) {this.bytes = new...;; (BinaryExpression) indexableSize > 0;; (JSIdentifier) indexableSize						local.get $indexableSize;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.bytes = new Uint8Array(indexableSiz...;; (ExpressionStatement) this.bytes = new Uint8Array(indexableSiz...;; (AssignmentExpression) this.bytes = new Uint8Array(indexableSiz...;; (NewExpression) new Uint8Array(indexableSize)						unreachable						local.set $bytes)))));; (JSProperty) property: initAsClone -> function(origin...;; (FunctionExpression) function(original, hash) { 	this.sqClass...(func $initAsClone						(local $hash i32)						(local $original i32)						(local $temp i32)						;; (ExpressionStatement) this.sqClass = original.sqClass;; (AssignmentExpression) this.sqClass = original.sqClass;; (StaticMemberExpression) original.sqClass;; (JSIdentifier) sqClass						local.get $sqClass						local.set $sqClass;; (ExpressionStatement) this.hash = hash;; (AssignmentExpression) this.hash = hash;; (JSIdentifier) hash						local.get $hash						local.set $hash;; (ExpressionStatement) this._format = original._format;; (AssignmentExpression) this._format = original._format;; (StaticMemberExpression) original._format;; (JSIdentifier) _format						local.get $_format						local.set $_format;; (IfStatement) if (original.isFloat) {this.isFloat = or...;; (StaticMemberExpression) original.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.isFloat = original.isFloat this.flo...;; (ExpressionStatement) this.isFloat = original.isFloat;; (AssignmentExpression) this.isFloat = original.isFloat;; (StaticMemberExpression) original.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						local.set $isFloat;; (ExpressionStatement) this.float = original.float;; (AssignmentExpression) this.float = original.float;; (StaticMemberExpression) original.float;; (JSIdentifier) float						local.get $float						local.set $float)						(else;; (BlockStatement) if (original.pointers) {this.pointers = ...;; (IfStatement) if (original.pointers) {this.pointers = ...;; (StaticMemberExpression) original.pointers;; (JSIdentifier) pointers						local.get $pointers						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.pointers = original.pointers.slice(...;; (AssignmentExpression) this.pointers = original.pointers.slice(...;; (CallExpression) original.pointers.slice(0)						local.get $original.pointers;; (JSLiteral) 0						i32.const 0						call $slice						local.set $pointers));; (IfStatement) if (original.words) {this.words = new Ui...;; (StaticMemberExpression) original.words;; (JSIdentifier) words						local.get $words						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.words = new Uint32Array(original.wo...;; (AssignmentExpression) this.words = new Uint32Array(original.wo...;; (NewExpression) new Uint32Array(original.words)						unreachable						local.set $words));; (IfStatement) if (original.bytes) {this.bytes = new Ui...;; (StaticMemberExpression) original.bytes;; (JSIdentifier) bytes						local.get $bytes						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.bytes = new Uint8Array(original.byt...;; (AssignmentExpression) this.bytes = new Uint8Array(original.byt...;; (NewExpression) new Uint8Array(original.bytes)						unreachable						local.set $bytes)))));; (JSProperty) property: initFromImage -> function(oop,...;; (FunctionExpression) function(oop, cls, fmt, hsh) { 	this.oop...(func $initFromImage						(local $fmt i32)						(local $cls i32)						(local $hsh i32)						(local $temp i32)						(local $oop i32)						;; (ExpressionStatement) this.oop = oop;; (AssignmentExpression) this.oop = oop;; (JSIdentifier) oop						local.get $oop						local.set $oop;; (ExpressionStatement) this.sqClass = cls;; (AssignmentExpression) this.sqClass = cls;; (JSIdentifier) cls						local.get $cls						local.set $sqClass;; (ExpressionStatement) this._format = fmt;; (AssignmentExpression) this._format = fmt;; (JSIdentifier) fmt						local.get $fmt						local.set $_format;; (ExpressionStatement) this.hash = hsh;; (AssignmentExpression) this.hash = hsh;; (JSIdentifier) hsh						local.get $hsh						local.set $hash);; (JSProperty) property: classNameFromImage -> function...;; (FunctionExpression) function(oopMap, rawBits) { 	var name = ...(func $classNameFromImage						(local $bytes i32)						(local $oopMap i32)						(local $bits i32)						(local $rawBits i32)						(local $name i32)						(local $temp i32)												;; unwritable: (IfStatement) if (name && name._format >= 8 && name._f						;; unwritable: (ReturnStatement) return 'Class');; (JSProperty) property: renameFromImage -> function(oo...;; (FunctionExpression) function(oopMap, rawBits, ccArray) { 	va...(func $renameFromImage						(local $classObj i32)						(local $oopMap i32)						(local $rawBits i32)						(local $ccArray i32)						(local $temp i32)						(local $instProto i32)						(local $renamedObj i32)						;; (IfStatement) if (!classObj) {return this};; (UnaryExpression) !classObj;; (JSIdentifier) classObj						local.get $classObj						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this;; (ThisExpression) this						return));; (IfStatement) if (!instProto) {return this};; (UnaryExpression) !instProto;; (JSIdentifier) instProto						local.get $instProto						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this;; (ThisExpression) this						return));; (ExpressionStatement) renamedObj.oop = this.oop;; (AssignmentExpression) renamedObj.oop = this.oop;; (StaticMemberExpression) this.oop;; (JSIdentifier) oop						local.get $oop						local.set $oop;; (ExpressionStatement) renamedObj.sqClass = this.sqClass;; (AssignmentExpression) renamedObj.sqClass = this.sqClass;; (StaticMemberExpression) this.sqClass;; (JSIdentifier) sqClass						local.get $sqClass						local.set $sqClass;; (ExpressionStatement) renamedObj._format = this._format;; (AssignmentExpression) renamedObj._format = this._format;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format						local.set $_format;; (ExpressionStatement) renamedObj.hash = this.hash;; (AssignmentExpression) renamedObj.hash = this.hash;; (StaticMemberExpression) this.hash;; (JSIdentifier) hash						local.get $hash						local.set $hash;; (ReturnStatement) return renamedObj;; (JSIdentifier) renamedObj						local.get $renamedObj						return);; (JSProperty) property: installFromImage -> function(o...;; (FunctionExpression) function(oopMap, rawBits, ccArray, float...(func $installFromImage						(local $oops i32)						(local $nWords i32)						(local $temp i32)						(local $bits i32)						(local $oopMap i32)						(local $nativeFloats i32)						(local $floatClass i32)						(local $ccInt i32)						(local $methodHeader i32)						(local $rawBits i32)						(local $ccArray i32)						(local $littleEndian i32)						(local $numLits i32)						;; (IfStatement) if (ccInt > 0 && ccInt < 32) {this.sqCla...;; (BinaryExpression) ccInt > 0 && ccInt < 32;; (BinaryExpression) ccInt > 0;; (JSIdentifier) ccInt						local.get $ccInt;; (JSLiteral) 0						i32.const 0						i32.gt_u;; (BinaryExpression) ccInt < 32;; (JSIdentifier) ccInt						local.get $ccInt;; (JSLiteral) 32						i32.const 32						i32.lt_u						i32.and						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sqClass = oopMap[ccArray[ccInt - 1]...;; (AssignmentExpression) this.sqClass = oopMap[ccArray[ccInt - 1]...;; (ComputedMemberExpression) oopMap[ccArray[ccInt - 1]];; (JSIdentifier) oopMap						local.get $oopMap;; (ComputedMemberExpression) ccArray[ccInt - 1];; (JSIdentifier) ccArray						local.get $ccArray;; (BinaryExpression) ccInt - 1;; (JSIdentifier) ccInt						local.get $ccInt;; (JSLiteral) 1						i32.const 1						i32.sub						i32.const 4						i32.mul						i32.add						i32.const 4						i32.mul						i32.add						local.set $sqClass)						(else;; (ExpressionStatement) this.sqClass = oopMap[ccInt];; (AssignmentExpression) this.sqClass = oopMap[ccInt];; (ComputedMemberExpression) oopMap[ccInt];; (JSIdentifier) oopMap						local.get $oopMap;; (JSIdentifier) ccInt						local.get $ccInt						i32.const 4						i32.mul						i32.add						local.set $sqClass))						;; unwritable: (IfStatement) if (this._format < 5) {if (nWords > 0) {;; (ExpressionStatement) this.mark = false;; (AssignmentExpression) this.mark = false;; (JSLiteral) false						i32.const 0						local.set $mark);; (JSProperty) property: decodePointers -> function(nWo...;; (FunctionExpression) function(nWords, theBits, oopMap) { 	var...(func $decodePointers						(local $theBits i32)						(local $oopMap i32)						(local $i i32)						(local $ptrs i32)						(local $nWords i32)						(local $temp i32)						(local $oop i32)						;; (ForStatement) for (var i = 0; i < nWords; i++) {var oo...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (BlockStatement) var oop = theBits[i] if (oop & 1 === 1) ...;; (VariableDeclaration) var oop = theBits[i];; (VariableDeclarator) oop = theBits[i];; (ComputedMemberExpression) theBits[i];; (JSIdentifier) theBits						local.get $theBits;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						local.set $oop;; (IfStatement) if (oop & 1 === 1) {ptrs[i] = oop >> 1 }...;; (BinaryExpression) oop & 1 === 1;; (BinaryExpression) oop & 1;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 1						i32.const 1						i32.and;; (JSLiteral) 1						i32.const 1						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) ptrs[i] = oop >> 1 ;; (ExpressionStatement) ptrs[i] = oop >> 1;; (AssignmentExpression) ptrs[i] = oop >> 1						local.get $'ptrs';; (JSIdentifier) i						local.get $i;; (BinaryExpression) oop >> 1;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 1						i32.const 1						i32.shr_s						call $atPut)						(else;; (BlockStatement) ptrs[i] = oopMap[oop] || 42424242 ;; (ExpressionStatement) ptrs[i] = oopMap[oop] || 42424242;; (AssignmentExpression) ptrs[i] = oopMap[oop] || 42424242						local.get $'ptrs';; (JSIdentifier) i						local.get $i;; (BinaryExpression) oopMap[oop] || 42424242;; (ComputedMemberExpression) oopMap[oop];; (JSIdentifier) oopMap						local.get $oopMap;; (JSIdentifier) oop						local.get $oop						i32.const 4						i32.mul						i32.add;; (JSLiteral) 42424242						i32.const 42424242						i32.or						call $atPut));; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < nWords;; (JSIdentifier) i						local.get $i;; (JSIdentifier) nWords						local.get $nWords						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return ptrs;; (JSIdentifier) ptrs						local.get $ptrs						return);; (JSProperty) property: decodeWords -> function(nWords...;; (FunctionExpression) function(nWords, theBits, littleEndian) ...(func $decodeWords						(local $theBits i32)						(local $data i32)						(local $words i32)						(local $i i32)						(local $temp i32)						(local $nWords i32)						(local $littleEndian i32)						;; (ForStatement) for (var i = 0; i < nWords; i++) {words[...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) words[i] = data.getUint32(i * 4, littleE...;; (AssignmentExpression) words[i] = data.getUint32(i * 4, littleE...						local.get $'words';; (JSIdentifier) i						local.get $i;; (CallExpression) data.getUint32(i * 4, littleEndian)						local.get $data;; (BinaryExpression) i * 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.mul;; (JSIdentifier) littleEndian						local.get $littleEndian						call $getUint32						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < nWords;; (JSIdentifier) i						local.get $i;; (JSIdentifier) nWords						local.get $nWords						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return words;; (JSIdentifier) words						local.get $words						return);; (JSProperty) property: decodeBytes -> function(nWords...;; (FunctionExpression) function(nWords, theBits, wordOffset, fm...(func $decodeBytes						(local $theBits i32)						(local $bytes i32)						(local $wordOffset i32)						(local $wordsAsBytes i32)						(local $nWords i32)						(local $fmtLowBits i32)						(local $nBytes i32)						(local $temp i32)						;; (ExpressionStatement) bytes.set(wordsAsBytes);; (CallExpression) bytes.set(wordsAsBytes)						local.get $bytes;; (JSIdentifier) wordsAsBytes						local.get $wordsAsBytes						call $set;; (ReturnStatement) return bytes;; (JSIdentifier) bytes						local.get $bytes						return);; (JSProperty) property: decodeFloat -> function(theBit...;; (FunctionExpression) function(theBits, littleEndian, nativeFl...(func $decodeFloat						(local $theBits i32)						(local $data i32)						(local $nativeFloats i32)						(local $buffer i32)						(local $temp i32)						(local $swapped i32)						(local $littleEndian i32)						;; (IfStatement) if (!littleEndian) {return data.getFloat...;; (UnaryExpression) !littleEndian;; (JSIdentifier) littleEndian						local.get $littleEndian						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return data.getFloat64(0, false);; (CallExpression) data.getFloat64(0, false)						local.get $data;; (JSLiteral) 0						i32.const 0;; (JSLiteral) false						i32.const 0						call $getFloat64						return));; (IfStatement) if (nativeFloats) {return data.getFloat6...;; (JSIdentifier) nativeFloats						local.get $nativeFloats						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return data.getFloat64(0, true);; (CallExpression) data.getFloat64(0, true)						local.get $data;; (JSLiteral) 0						i32.const 0;; (JSLiteral) true						i32.const 1						call $getFloat64						return));; (ExpressionStatement) swapped.setUint32(0, data.getUint32(4));; (CallExpression) swapped.setUint32(0, data.getUint32(4))						local.get $swapped;; (JSLiteral) 0						i32.const 0;; (CallExpression) data.getUint32(4)						local.get $data;; (JSLiteral) 4						i32.const 4						call $getUint32						call $setUint32;; (ExpressionStatement) swapped.setUint32(4, data.getUint32(0));; (CallExpression) swapped.setUint32(4, data.getUint32(0))						local.get $swapped;; (JSLiteral) 4						i32.const 4;; (CallExpression) data.getUint32(0)						local.get $data;; (JSLiteral) 0						i32.const 0						call $getUint32						call $setUint32;; (ReturnStatement) return swapped.getFloat64(0, true);; (CallExpression) swapped.getFloat64(0, true)						local.get $swapped;; (JSLiteral) 0						i32.const 0;; (JSLiteral) true						i32.const 1						call $getFloat64						return);; (JSProperty) property: decodeFloatDeoptimized -> func...;; (FunctionExpression) function(theBits, littleEndian, nativeFl...(func $decodeFloatDeoptimized						(local $theBits i32)						(local $data i32)						(local $nativeFloats i32)						(local $buffer i32)						(local $temp i32)						(local $swapped i32)						(local $littleEndian i32)						;; (IfStatement) if (!littleEndian) {return data.getFloat...;; (UnaryExpression) !littleEndian;; (JSIdentifier) littleEndian						local.get $littleEndian						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return data.getFloat64(0, false);; (CallExpression) data.getFloat64(0, false)						local.get $data;; (JSLiteral) 0						i32.const 0;; (JSLiteral) false						i32.const 0						call $getFloat64						return));; (IfStatement) if (nativeFloats) {return data.getFloat6...;; (JSIdentifier) nativeFloats						local.get $nativeFloats						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return data.getFloat64(0, true);; (CallExpression) data.getFloat64(0, true)						local.get $data;; (JSLiteral) 0						i32.const 0;; (JSLiteral) true						i32.const 1						call $getFloat64						return));; (ExpressionStatement) function() { 	swapped.setUint32(0, data....;; (CallExpression) function() { 	swapped.setUint32(0, data....						call $getUint32(0))};; (ReturnStatement) return swapped.getFloat64(0, true);; (CallExpression) swapped.getFloat64(0, true)						local.get $swapped;; (JSLiteral) 0						i32.const 0;; (JSLiteral) true						i32.const 1						call $getFloat64						return);; (JSProperty) property: fillArray -> function(length, ...;; (FunctionExpression) function(length, filler) { 	for (var arr...(func $fillArray						(local $length i32)						(local $array i32)						(local $i i32)						(local $temp i32)						(local $filler i32)												;; unwritable: (ForStatement) for (var array = [], i = 0; i < length; ;; (ReturnStatement) return array;; (JSIdentifier) array						local.get $array						return);; (JSProperty) property: isWords -> function() { 	retur...;; (FunctionExpression) function() { 	return this._format === 6 ...(func $isWords						(local $temp i32)						;; (ReturnStatement) return this._format === 6;; (BinaryExpression) this._format === 6;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format;; (JSLiteral) 6						i32.const 6						i32.eq						return);; (JSProperty) property: isBytes -> function() { 	var f...;; (FunctionExpression) function() { 	var fmt = this._format ret...(func $isBytes						(local $fmt i32)						(local $temp i32)						;; (ReturnStatement) return fmt >= 8 && fmt <= 11;; (BinaryExpression) fmt >= 8 && fmt <= 11;; (BinaryExpression) fmt >= 8;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 8						i32.const 8						i32.ge_u;; (BinaryExpression) fmt <= 11;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 11						i32.const 11						i32.le_u						i32.and						return);; (JSProperty) property: isWordsOrBytes -> function() {...;; (FunctionExpression) function() { 	var fmt = this._format ret...(func $isWordsOrBytes						(local $fmt i32)						(local $temp i32)						;; (ReturnStatement) return fmt == 6 || fmt >= 8 && fmt <= 11;; (BinaryExpression) fmt == 6 || fmt >= 8 && fmt <= 11;; (BinaryExpression) fmt == 6;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 6						i32.const 6						i32.eq;; (BinaryExpression) fmt >= 8 && fmt <= 11;; (BinaryExpression) fmt >= 8;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 8						i32.const 8						i32.ge_u;; (BinaryExpression) fmt <= 11;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 11						i32.const 11						i32.le_u						i32.and						i32.or						return);; (JSProperty) property: isPointers -> function() { 	re...;; (FunctionExpression) function() { 	return this._format <= 4 }(func $isPointers						(local $temp i32)						;; (ReturnStatement) return this._format <= 4;; (BinaryExpression) this._format <= 4;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format;; (JSLiteral) 4						i32.const 4						i32.le_u						return);; (JSProperty) property: isWeak -> function() { 	return...;; (FunctionExpression) function() { 	return this._format === 4 ...(func $isWeak						(local $temp i32)						;; (ReturnStatement) return this._format === 4;; (BinaryExpression) this._format === 4;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format;; (JSLiteral) 4						i32.const 4						i32.eq						return);; (JSProperty) property: isMethod -> function() { 	retu...;; (FunctionExpression) function() { 	return this._format >= 12 ...(func $isMethod						(local $temp i32)						;; (ReturnStatement) return this._format >= 12;; (BinaryExpression) this._format >= 12;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format;; (JSLiteral) 12						i32.const 12						i32.ge_u						return);; (JSProperty) property: sameFormats -> function(a, b) ...;; (FunctionExpression) function(a, b) { 	return a < 8 ? a === b...(func $sameFormats						(local $b i32)						(local $temp i32)						(local $a i32)						;; (ReturnStatement) return a < 8 ? a === b : a & 12 === b & ...;; (ConditionalExpression) a < 8 ? a === b : a & 12 === b & 12;; (BinaryExpression) a < 8;; (JSIdentifier) a						local.get $a;; (JSLiteral) 8						i32.const 8						i32.lt_u						i32.const 1						i32.eq						(if (then;; (BinaryExpression) a === b;; (JSIdentifier) a						local.get $a;; (JSIdentifier) b						local.get $b						i32.eq)						(else;; (BinaryExpression) a & 12 === b & 12;; (BinaryExpression) a & 12;; (JSIdentifier) a						local.get $a;; (JSLiteral) 12						i32.const 12						i32.and;; (BinaryExpression) b & 12;; (JSIdentifier) b						local.get $b;; (JSLiteral) 12						i32.const 12						i32.and						i32.eq						))						return);; (JSProperty) property: sameFormatAs -> function(obj) ...;; (FunctionExpression) function(obj) { 	return this.sameFormats...(func $sameFormatAs						(local $obj i32)						(local $temp i32)						;; (ReturnStatement) return this.sameFormats(this._format, ob...;; (CallExpression) this.sameFormats(this._format, obj._form...						local.get $this;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format;; (StaticMemberExpression) obj._format;; (JSIdentifier) _format						local.get $_format						call $sameFormats						return);; (JSProperty) property: toString -> function() { 	retu...;; (FunctionExpression) function() { 	return this.sqInstName() }(func $toString						(local $temp i32)						;; (ReturnStatement) return this.sqInstName();; (CallExpression) this.sqInstName()						local.get $this						call $sqInstName						return);; (JSProperty) property: bytesAsString -> function() { ...;; (FunctionExpression) function() { 	if (!this.bytes) {return '...(func $bytesAsString						(local $temp i32)												;; unwritable: (IfStatement) if (!this.bytes) {return ''}						;; unwritable: (ReturnStatement) return Squeak.bytesAsString(this.bytes));; (JSProperty) property: bytesAsNumberString -> functio...;; (FunctionExpression) function(negative) { 	if (!this.bytes) {...(func $bytesAsNumberString						(local $digits i32)						(local $value i32)						(local $hex i32)						(local $i i32)						(local $negative i32)						(local $sign i32)						(local $temp i32)						(local $approx i32)												;; unwritable: (IfStatement) if (!this.bytes) {return ''};; (ForStatement) for (var i = this.bytes.length - 1; i >=...;; (VariableDeclaration) var i = this.bytes.length - 1;; (VariableDeclarator) i = this.bytes.length - 1;; (BinaryExpression) this.bytes.length - 1;; (StaticMemberExpression) this.bytes.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 1						i32.const 1						i32.sub						local.set $i						(loop $loop_1;; (BlockStatement) digits.push(hex[this.bytes[i] >> 4]) dig...;; (ExpressionStatement) digits.push(hex[this.bytes[i] >> 4]);; (CallExpression) digits.push(hex[this.bytes[i] >> 4])						local.get $digits;; (ComputedMemberExpression) hex[this.bytes[i] >> 4];; (JSIdentifier) hex						local.get $hex;; (BinaryExpression) this.bytes[i] >> 4;; (ComputedMemberExpression) this.bytes[i];; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add;; (JSLiteral) 4						i32.const 4						i32.shr_s						i32.const 4						i32.mul						i32.add						call $push;; (ExpressionStatement) digits.push(hex[this.bytes[i] & 15]);; (CallExpression) digits.push(hex[this.bytes[i] & 15])						local.get $digits;; (ComputedMemberExpression) hex[this.bytes[i] & 15];; (JSIdentifier) hex						local.get $hex;; (BinaryExpression) this.bytes[i] & 15;; (ComputedMemberExpression) this.bytes[i];; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add;; (JSLiteral) 15						i32.const 15						i32.and						i32.const 4						i32.mul						i32.add						call $push;; (ExpressionStatement) value = value * 256 + this.bytes[i];; (AssignmentExpression) value = value * 256 + this.bytes[i];; (BinaryExpression) value * 256 + this.bytes[i];; (BinaryExpression) value * 256;; (JSIdentifier) value						local.get $value;; (JSLiteral) 256						i32.const 256						i32.mul;; (ComputedMemberExpression) this.bytes[i];; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						i32.add						local.set $value;; (UpdateExpression) i--;; (JSIdentifier) i						local.get $i						i32.const 1						i32.sub;; (BinaryExpression) i >= 0;; (JSIdentifier) i						local.get $i;; (JSLiteral) 0						i32.const 0						i32.ge_u						i32.const 0						br_if $loop_1)						;; unwritable: (ReturnStatement) return sign + '16r' + digits.join('') + );; (JSProperty) property: assnKeyAsString -> function() ...;; (FunctionExpression) function() { 	return this.pointers[Squea...(func $assnKeyAsString						(local $temp i32)												;; unwritable: (ReturnStatement) return this.pointers[Squeak.Assn_key].by);; (JSProperty) property: slotNameAt -> function(index) ...;; (FunctionExpression) function(index) { 	var instSize = this.i...(func $slotNameAt						(local $temp i32)						(local $instSize i32)						(local $index i32)												;; unwritable: (IfStatement) if (index <= instSize) {return this.sqCl);; (JSProperty) property: sqInstName -> function() { 	if...;; (FunctionExpression) function() { 	if (this.isNil) {return 'n...(func $sqInstName						(local $className i32)						(local $str i32)						(local $temp i32)												;; unwritable: (IfStatement) if (this.isNil) {return 'nil'}						;; unwritable: (IfStatement) if (this.isTrue) {return 'true'}						;; unwritable: (IfStatement) if (this.isFalse) {return 'false'}						;; unwritable: (IfStatement) if (this.isFloat) {var str = this.float.						;; unwritable: (IfStatement) if (/ /.test(className)) {return 'the ' 						;; unwritable: (SwitchStatement) switch (className) { case 'String': case						;; unwritable: (ReturnStatement) return /^[aeiou]/i.test(className) ? 'an);; (JSProperty) property: pointersSize -> function() { 	...;; (FunctionExpression) function() { 	return this.pointers ? thi...(func $pointersSize						(local $temp i32)						;; (ReturnStatement) return this.pointers ? this.pointers.len...;; (ConditionalExpression) this.pointers ? this.pointers.length : 0;; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers						i32.const 1						i32.eq						(if (then;; (StaticMemberExpression) this.pointers.length;; (JSIdentifier) length						local.get $length)						(else;; (JSLiteral) 0						i32.const 0						))						return);; (JSProperty) property: bytesSize -> function() { 	ret...;; (FunctionExpression) function() { 	return this.bytes ? this.b...(func $bytesSize						(local $temp i32)						;; (ReturnStatement) return this.bytes ? this.bytes.length : ...;; (ConditionalExpression) this.bytes ? this.bytes.length : 0;; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes						i32.const 1						i32.eq						(if (then;; (StaticMemberExpression) this.bytes.length;; (JSIdentifier) length						local.get $length)						(else;; (JSLiteral) 0						i32.const 0						))						return);; (JSProperty) property: wordsSize -> function() { 	ret...;; (FunctionExpression) function() { 	return this.isFloat ? 2 : ...(func $wordsSize						(local $temp i32)						;; (ReturnStatement) return this.isFloat ? 2 : this.words ? t...;; (ConditionalExpression) this.isFloat ? 2 : this.words ? this.wor...;; (StaticMemberExpression) this.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						i32.const 1						i32.eq						(if (then;; (JSLiteral) 2						i32.const 2)						(else;; (ConditionalExpression) this.words ? this.words.length : 0;; (StaticMemberExpression) this.words;; (JSIdentifier) words						local.get $words						i32.const 1						i32.eq						(if (then;; (StaticMemberExpression) this.words.length;; (JSIdentifier) length						local.get $length)						(else;; (JSLiteral) 0						i32.const 0						))						))						return);; (JSProperty) property: instSize -> function() { 	var ...;; (FunctionExpression) function() { 	var fmt = this._format if ...(func $instSize						(local $fmt i32)						(local $temp i32)						;; (IfStatement) if (fmt > 4 || fmt === 2) {return 0};; (BinaryExpression) fmt > 4 || fmt === 2;; (BinaryExpression) fmt > 4;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 4						i32.const 4						i32.gt_u;; (BinaryExpression) fmt === 2;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 2						i32.const 2						i32.eq						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return));; (IfStatement) if (fmt < 2) {return this.pointersSize()...;; (BinaryExpression) fmt < 2;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 2						i32.const 2						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.pointersSize();; (CallExpression) this.pointersSize()						local.get $this						call $pointersSize						return));; (ReturnStatement) return this.sqClass.classInstSize();; (CallExpression) this.sqClass.classInstSize()						local.get $sqClass						call $classInstSize						return);; (JSProperty) property: indexableSize -> function(prim...;; (FunctionExpression) function(primHandler) { 	var fmt = this....(func $indexableSize						(local $fmt i32)						(local $primHandler i32)						(local $temp i32)						;; (IfStatement) if (fmt < 2) {return -1};; (BinaryExpression) fmt < 2;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 2						i32.const 2						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return -1;; (UnaryExpression) -1;; (JSLiteral) 1						i32.const 1						local.set $temp						i32.const 0						local.get $temp						i32.sub						return));; (IfStatement) if (fmt === 3 && primHandler.vm.isContex...;; (BinaryExpression) fmt === 3 && primHandler.vm.isContext(th...;; (BinaryExpression) fmt === 3 && primHandler.vm.isContext(th...;; (BinaryExpression) fmt === 3;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 3						i32.const 3						i32.eq;; (CallExpression) primHandler.vm.isContext(this)						local.get $primHandler.vm;; (ThisExpression) this						call $isContext						i32.and;; (UnaryExpression) !primHandler.allowAccessBeyondSP;; (StaticMemberExpression) primHandler.allowAccessBeyondSP;; (JSIdentifier) allowAccessBeyondSP						local.get $allowAccessBeyondSP						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.and						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.pointers[Squeak.Context_stac...;; (ComputedMemberExpression) this.pointers[Squeak.Context_stackPointe...;; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_stackPointer;; (JSIdentifier) Context_stackPointer						local.get $Context_stackPointer						i32.const 4						i32.mul						i32.add						return));; (IfStatement) if (fmt < 6) {return this.pointersSize()...;; (BinaryExpression) fmt < 6;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 6						i32.const 6						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.pointersSize() - this.instSi...;; (BinaryExpression) this.pointersSize() - this.instSize();; (CallExpression) this.pointersSize()						local.get $this						call $pointersSize;; (CallExpression) this.instSize()						local.get $this						call $instSize						i32.sub						return));; (IfStatement) if (fmt < 8) {return this.wordsSize()};; (BinaryExpression) fmt < 8;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 8						i32.const 8						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.wordsSize();; (CallExpression) this.wordsSize()						local.get $this						call $wordsSize						return));; (IfStatement) if (fmt < 12) {return this.bytesSize()};; (BinaryExpression) fmt < 12;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 12						i32.const 12						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.bytesSize();; (CallExpression) this.bytesSize()						local.get $this						call $bytesSize						return));; (ReturnStatement) return this.bytesSize() + 4 * this.point...;; (BinaryExpression) this.bytesSize() + 4 * this.pointersSize...;; (CallExpression) this.bytesSize()						local.get $this						call $bytesSize;; (BinaryExpression) 4 * this.pointersSize();; (JSLiteral) 4						i32.const 4;; (CallExpression) this.pointersSize()						local.get $this						call $pointersSize						i32.mul						i32.add						return);; (JSProperty) property: floatData -> function() { 	var...;; (FunctionExpression) function() { 	var buffer = new ArrayBuff...(func $floatData						(local $buffer i32)						(local $data i32)						(local $temp i32)						;; (ExpressionStatement) data.setFloat64(0, this.float, false);; (CallExpression) data.setFloat64(0, this.float, false)						local.get $data;; (JSLiteral) 0						i32.const 0;; (StaticMemberExpression) this.float;; (JSIdentifier) float						local.get $float;; (JSLiteral) false						i32.const 0						call $setFloat64;; (ReturnStatement) return data;; (JSIdentifier) data						local.get $data						return);; (JSProperty) property: wordsAsFloat32Array -> functio...;; (FunctionExpression) function() { 	return this.float32Array |...(func $wordsAsFloat32Array						(local $temp i32)						;; (ReturnStatement) return this.float32Array || this.words &...;; (BinaryExpression) this.float32Array || this.words && this....;; (StaticMemberExpression) this.float32Array;; (JSIdentifier) float32Array						local.get $float32Array;; (BinaryExpression) this.words && this.float32Array = new Fl...;; (StaticMemberExpression) this.words;; (JSIdentifier) words						local.get $words;; (AssignmentExpression) this.float32Array = new Float32Array(thi...;; (NewExpression) new Float32Array(this.words.buffer)						unreachable						local.set $float32Array						i32.and						i32.or						return);; (JSProperty) property: wordsAsFloat64Array -> functio...;; (FunctionExpression) function() { 	return this.float64Array |...(func $wordsAsFloat64Array						(local $temp i32)						;; (ReturnStatement) return this.float64Array || this.words &...;; (BinaryExpression) this.float64Array || this.words && this....;; (StaticMemberExpression) this.float64Array;; (JSIdentifier) float64Array						local.get $float64Array;; (BinaryExpression) this.words && this.float64Array = new Fl...;; (StaticMemberExpression) this.words;; (JSIdentifier) words						local.get $words;; (AssignmentExpression) this.float64Array = new Float64Array(thi...;; (NewExpression) new Float64Array(this.words.buffer)						unreachable						local.set $float64Array						i32.and						i32.or						return);; (JSProperty) property: wordsAsInt32Array -> function(...;; (FunctionExpression) function() { 	return this.int32Array || ...(func $wordsAsInt32Array						(local $temp i32)						;; (ReturnStatement) return this.int32Array || this.words && ...;; (BinaryExpression) this.int32Array || this.words && this.in...;; (StaticMemberExpression) this.int32Array;; (JSIdentifier) int32Array						local.get $int32Array;; (BinaryExpression) this.words && this.int32Array = new Int3...;; (StaticMemberExpression) this.words;; (JSIdentifier) words						local.get $words;; (AssignmentExpression) this.int32Array = new Int32Array(this.wo...;; (NewExpression) new Int32Array(this.words.buffer)						unreachable						local.set $int32Array						i32.and						i32.or						return);; (JSProperty) property: wordsAsInt16Array -> function(...;; (FunctionExpression) function() { 	return this.int16Array || ...(func $wordsAsInt16Array						(local $temp i32)						;; (ReturnStatement) return this.int16Array || this.words && ...;; (BinaryExpression) this.int16Array || this.words && this.in...;; (StaticMemberExpression) this.int16Array;; (JSIdentifier) int16Array						local.get $int16Array;; (BinaryExpression) this.words && this.int16Array = new Int1...;; (StaticMemberExpression) this.words;; (JSIdentifier) words						local.get $words;; (AssignmentExpression) this.int16Array = new Int16Array(this.wo...;; (NewExpression) new Int16Array(this.words.buffer)						unreachable						local.set $int16Array						i32.and						i32.or						return);; (JSProperty) property: wordsAsUint16Array -> function...;; (FunctionExpression) function() { 	return this.uint16Array ||...(func $wordsAsUint16Array						(local $temp i32)						;; (ReturnStatement) return this.uint16Array || this.words &&...;; (BinaryExpression) this.uint16Array || this.words && this.u...;; (StaticMemberExpression) this.uint16Array;; (JSIdentifier) uint16Array						local.get $uint16Array;; (BinaryExpression) this.words && this.uint16Array = new Uin...;; (StaticMemberExpression) this.words;; (JSIdentifier) words						local.get $words;; (AssignmentExpression) this.uint16Array = new Uint16Array(this....;; (NewExpression) new Uint16Array(this.words.buffer)						unreachable						local.set $uint16Array						i32.and						i32.or						return);; (JSProperty) property: wordsAsUint8Array -> function(...;; (FunctionExpression) function() { 	return this.uint8Array || ...(func $wordsAsUint8Array						(local $temp i32)						;; (ReturnStatement) return this.uint8Array || this.words && ...;; (BinaryExpression) this.uint8Array || this.words && this.ui...;; (StaticMemberExpression) this.uint8Array;; (JSIdentifier) uint8Array						local.get $uint8Array;; (BinaryExpression) this.words && this.uint8Array = new Uint...;; (StaticMemberExpression) this.words;; (JSIdentifier) words						local.get $words;; (AssignmentExpression) this.uint8Array = new Uint8Array(this.wo...;; (NewExpression) new Uint8Array(this.words.buffer)						unreachable						local.set $uint8Array						i32.and						i32.or						return);; (JSProperty) property: wordsOrBytes -> function() { 	...;; (FunctionExpression) function() { 	if (this.words) {return th...(func $wordsOrBytes						(local $temp i32)						;; (IfStatement) if (this.words) {return this.words};; (StaticMemberExpression) this.words;; (JSIdentifier) words						local.get $words						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.words;; (StaticMemberExpression) this.words;; (JSIdentifier) words						local.get $words						return));; (IfStatement) if (this.uint32Array) {return this.uint3...;; (StaticMemberExpression) this.uint32Array;; (JSIdentifier) uint32Array						local.get $uint32Array						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.uint32Array;; (StaticMemberExpression) this.uint32Array;; (JSIdentifier) uint32Array						local.get $uint32Array						return));; (IfStatement) if (!this.bytes) {return nil};; (UnaryExpression) !this.bytes;; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return));; (ReturnStatement) return this.uint32Array = new Uint32Arra...;; (AssignmentExpression) this.uint32Array = new Uint32Array(this....;; (NewExpression) new Uint32Array(this.bytes.buffer, 0, th...						unreachable						local.set $uint32Array						return);; (JSProperty) property: setAddr -> function(addr) { 	v...;; (FunctionExpression) function(addr) { 	var words = this.snaps...(func $setAddr						(local $words i32)						(local $addr i32)						(local $temp i32)						;; (ExpressionStatement) this.oop = addr + words.header * 4;; (AssignmentExpression) this.oop = addr + words.header * 4;; (BinaryExpression) addr + words.header * 4;; (JSIdentifier) addr						local.get $addr;; (BinaryExpression) words.header * 4;; (StaticMemberExpression) words.header;; (JSIdentifier) header						local.get $header;; (JSLiteral) 4						i32.const 4						i32.mul						i32.add						local.set $oop;; (ReturnStatement) return addr + words.header + words.body ...;; (BinaryExpression) addr + words.header + words.body * 4;; (JSIdentifier) addr						local.get $addr;; (BinaryExpression) words.header + words.body * 4;; (BinaryExpression) words.header + words.body;; (StaticMemberExpression) words.header;; (JSIdentifier) header						local.get $header;; (StaticMemberExpression) words.body;; (JSIdentifier) body						local.get $body						i32.add;; (JSLiteral) 4						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: snapshotSize -> function() { 	...;; (FunctionExpression) function() { 	var nWords = this.isFloat ...(func $snapshotSize						(local $nWords i32)						(local $extraHeader i32)						(local $temp i32)						;; (IfStatement) if (this.bytes) {nWords += this.bytes.le...;; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) nWords += this.bytes.length + 3 >>> 2;; (AssignmentExpression) nWords += this.bytes.length + 3 >>> 2;; (JSIdentifier) nWords						local.get $nWords;; (BinaryExpression) this.bytes.length + 3 >>> 2;; (BinaryExpression) this.bytes.length + 3;; (StaticMemberExpression) this.bytes.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 3						i32.const 3						i32.add;; (JSLiteral) 2						i32.const 2						i32.shr_u						i32.add						local.set $nWords));; (ExpressionStatement) nWords++;; (UpdateExpression) nWords++;; (JSIdentifier) nWords						local.get $nWords						i32.const 1						i32.add;; (ReturnStatement) return {property: header -> extraHeader,...;; (ObjectExpression) {property: header -> extraHeader, proper...						return);; (JSProperty) property: addr -> function() { 	return t...;; (FunctionExpression) function() { 	return this.oop - this.sna...(func $addr						(local $temp i32)						;; (ReturnStatement) return this.oop - this.snapshotSize().he...;; (BinaryExpression) this.oop - this.snapshotSize().header * ...;; (StaticMemberExpression) this.oop;; (JSIdentifier) oop						local.get $oop;; (BinaryExpression) this.snapshotSize().header * 4;; (StaticMemberExpression) this.snapshotSize().header;; (JSIdentifier) header						local.get $header;; (JSLiteral) 4						i32.const 4						i32.mul						i32.sub						return);; (JSProperty) property: totalBytes -> function() { 	va...;; (FunctionExpression) function() { 	var words = this.snapshotS...(func $totalBytes						(local $words i32)						(local $temp i32)						;; (ReturnStatement) return words.header + words.body * 4;; (BinaryExpression) words.header + words.body * 4;; (BinaryExpression) words.header + words.body;; (StaticMemberExpression) words.header;; (JSIdentifier) header						local.get $header;; (StaticMemberExpression) words.body;; (JSIdentifier) body						local.get $body						i32.add;; (JSLiteral) 4						i32.const 4						i32.mul						return);; (JSProperty) property: writeTo -> function(data, pos,...;; (FunctionExpression) function(data, pos, image) { 	if (this.b...(func $writeTo						(local $data i32)						(local $image i32)						(local $size i32)						(local $i i32)						(local $formatAndHash i32)						(local $temp i32)						(local $pos i32)						(local $beforePos i32)						;; (IfStatement) if (this.bytes) {this._format |= -this.b...;; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this._format |= -this.bytes.length & 3;; (AssignmentExpression) this._format |= -this.bytes.length & 3;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format;; (BinaryExpression) -this.bytes.length & 3;; (UnaryExpression) -this.bytes.length;; (StaticMemberExpression) this.bytes.length;; (JSIdentifier) length						local.get $length						local.set $temp						i32.const 0						local.get $temp						i32.sub;; (JSLiteral) 3						i32.const 3						i32.and						i32.sub						local.set $_format));; (SwitchStatement) switch (size.header) { case 2: data.setU...size.header						local.set $temp;; (SwitchCase)  case 2: data.setUint32(pos, size.body <...						local.get $temp;; (JSLiteral) 2						i32.const 2						i32.eq						(if (then ;; (ExpressionStatement) data.setUint32(pos, size.body << 2 | Squ...;; (CallExpression) data.setUint32(pos, size.body << 2 | Squ...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) size.body << 2 | Squeak.HeaderTypeSizeAn...;; (BinaryExpression) size.body << 2;; (StaticMemberExpression) size.body;; (JSIdentifier) body						local.get $body;; (JSLiteral) 2						i32.const 2						i32.shl;; (StaticMemberExpression) Squeak.HeaderTypeSizeAndClass;; (JSIdentifier) HeaderTypeSizeAndClass						local.get $HeaderTypeSizeAndClass						i32.or						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (ExpressionStatement) data.setUint32(pos, this.sqClass.oop | S...;; (CallExpression) data.setUint32(pos, this.sqClass.oop | S...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) this.sqClass.oop | Squeak.HeaderTypeSize...;; (StaticMemberExpression) this.sqClass.oop;; (JSIdentifier) oop						local.get $oop;; (StaticMemberExpression) Squeak.HeaderTypeSizeAndClass;; (JSIdentifier) HeaderTypeSizeAndClass						local.get $HeaderTypeSizeAndClass						i32.or						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (ExpressionStatement) data.setUint32(pos, formatAndHash | Sque...;; (CallExpression) data.setUint32(pos, formatAndHash | Sque...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) formatAndHash | Squeak.HeaderTypeSizeAnd...;; (JSIdentifier) formatAndHash						local.get $formatAndHash;; (StaticMemberExpression) Squeak.HeaderTypeSizeAndClass;; (JSIdentifier) HeaderTypeSizeAndClass						local.get $HeaderTypeSizeAndClass						i32.or						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (BreakStatement) break						));; (SwitchCase)  case 1: data.setUint32(pos, this.sqClas...						local.get $temp;; (JSLiteral) 1						i32.const 1						i32.eq						(if (then ;; (ExpressionStatement) data.setUint32(pos, this.sqClass.oop | S...;; (CallExpression) data.setUint32(pos, this.sqClass.oop | S...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) this.sqClass.oop | Squeak.HeaderTypeClas...;; (StaticMemberExpression) this.sqClass.oop;; (JSIdentifier) oop						local.get $oop;; (StaticMemberExpression) Squeak.HeaderTypeClass;; (JSIdentifier) HeaderTypeClass						local.get $HeaderTypeClass						i32.or						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (ExpressionStatement) data.setUint32(pos, formatAndHash | size...;; (CallExpression) data.setUint32(pos, formatAndHash | size...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) formatAndHash | size.body << 2 | Squeak....;; (BinaryExpression) formatAndHash | size.body << 2;; (JSIdentifier) formatAndHash						local.get $formatAndHash;; (BinaryExpression) size.body << 2;; (StaticMemberExpression) size.body;; (JSIdentifier) body						local.get $body;; (JSLiteral) 2						i32.const 2						i32.shl						i32.or;; (StaticMemberExpression) Squeak.HeaderTypeClass;; (JSIdentifier) HeaderTypeClass						local.get $HeaderTypeClass						i32.or						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (BreakStatement) break						));; (SwitchCase)  case 0: var classIndex = image.compactC...						local.get $temp;; (JSLiteral) 0						i32.const 0						i32.eq						(if (then ;; (VariableDeclaration) var classIndex = image.compactClasses.in...;; (VariableDeclarator) classIndex = image.compactClasses.indexO...;; (BinaryExpression) image.compactClasses.indexOf(this.sqClas...;; (CallExpression) image.compactClasses.indexOf(this.sqClas...						local.get $image.compactClasses;; (StaticMemberExpression) this.sqClass;; (JSIdentifier) sqClass						local.get $sqClass						call $indexOf;; (JSLiteral) 1						i32.const 1						i32.add						local.set $classIndex;; (ExpressionStatement) data.setUint32(pos, formatAndHash | clas...;; (CallExpression) data.setUint32(pos, formatAndHash | clas...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) formatAndHash | classIndex << 12 | size....;; (BinaryExpression) formatAndHash | classIndex << 12 | size....;; (BinaryExpression) formatAndHash | classIndex << 12;; (JSIdentifier) formatAndHash						local.get $formatAndHash;; (BinaryExpression) classIndex << 12;; (JSIdentifier) classIndex						local.get $classIndex;; (JSLiteral) 12						i32.const 12						i32.shl						i32.or;; (BinaryExpression) size.body << 2;; (StaticMemberExpression) size.body;; (JSIdentifier) body						local.get $body;; (JSLiteral) 2						i32.const 2						i32.shl						i32.or;; (StaticMemberExpression) Squeak.HeaderTypeShort;; (JSIdentifier) HeaderTypeShort						local.get $HeaderTypeShort						i32.or						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos						));; (IfStatement) if (this.isFloat) {data.setFloat64(pos, ...;; (StaticMemberExpression) this.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						i32.const 0						i32.ne						(if (then;; (BlockStatement) data.setFloat64(pos, this.float) pos += ...;; (ExpressionStatement) data.setFloat64(pos, this.float);; (CallExpression) data.setFloat64(pos, this.float)						local.get $data;; (JSIdentifier) pos						local.get $pos;; (StaticMemberExpression) this.float;; (JSIdentifier) float						local.get $float						call $setFloat64;; (ExpressionStatement) pos += 8;; (AssignmentExpression) pos += 8;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 8						i32.const 8						i32.add						local.set $pos)						(else;; (IfStatement) if (this.words) {for (var i = 0; i < thi...;; (StaticMemberExpression) this.words;; (JSIdentifier) words						local.get $words						i32.const 0						i32.ne						(if (then;; (BlockStatement) for (var i = 0; i < this.words.length; i...;; (ForStatement) for (var i = 0; i < this.words.length; i...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (BlockStatement) data.setUint32(pos, this.words[i]) pos +...;; (ExpressionStatement) data.setUint32(pos, this.words[i]);; (CallExpression) data.setUint32(pos, this.words[i])						local.get $data;; (JSIdentifier) pos						local.get $pos;; (ComputedMemberExpression) this.words[i];; (StaticMemberExpression) this.words;; (JSIdentifier) words						local.get $words;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < this.words.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) this.words.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_1))						(else;; (IfStatement) if (this.pointers) {for (var i = 0; i < ...;; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers						i32.const 0						i32.ne						(if (then;; (BlockStatement) for (var i = 0; i < this.pointers.length...;; (ForStatement) for (var i = 0; i < this.pointers.length...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_2;; (BlockStatement) data.setUint32(pos, image.objectToOop(th...;; (ExpressionStatement) data.setUint32(pos, image.objectToOop(th...;; (CallExpression) data.setUint32(pos, image.objectToOop(th...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (CallExpression) image.objectToOop(this.pointers[i])						local.get $image;; (ComputedMemberExpression) this.pointers[i];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						call $objectToOop						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < this.pointers.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) this.pointers.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_2)))))));; (IfStatement) if (this.bytes) {for (var i = 0; i < thi...;; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes						i32.const 0						i32.ne						(if (then;; (BlockStatement) for (var i = 0; i < this.bytes.length; i...;; (ForStatement) for (var i = 0; i < this.bytes.length; i...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_3;; (ExpressionStatement) data.setUint8(pos++, this.bytes[i]);; (CallExpression) data.setUint8(pos++, this.bytes[i])						local.get $data;; (UpdateExpression) pos++;; (JSIdentifier) pos						local.get $pos						i32.const 1						i32.add;; (ComputedMemberExpression) this.bytes[i];; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						call $setUint8;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < this.bytes.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) this.bytes.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_3);; (ExpressionStatement) pos += -this.bytes.length & 3;; (AssignmentExpression) pos += -this.bytes.length & 3;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) -this.bytes.length & 3;; (UnaryExpression) -this.bytes.length;; (StaticMemberExpression) this.bytes.length;; (JSIdentifier) length						local.get $length						local.set $temp						i32.const 0						local.get $temp						i32.sub;; (JSLiteral) 3						i32.const 3						i32.and						i32.add						local.set $pos));; (IfStatement) if (pos !== beforePos + this.totalBytes(...;; (BinaryExpression) pos !== beforePos + this.totalBytes();; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) beforePos + this.totalBytes();; (JSIdentifier) beforePos						local.get $beforePos;; (CallExpression) this.totalBytes()						local.get $this						call $totalBytes						i32.add						i32.ne						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('written size does not match...						unreachable));; (ReturnStatement) return pos;; (JSIdentifier) pos						local.get $pos						return);; (JSProperty) property: classInstFormat -> function() ...;; (FunctionExpression) function() { 	return this.pointers[Squea...(func $classInstFormat						(local $temp i32)						;; (ReturnStatement) return this.pointers[Squeak.Class_format...;; (BinaryExpression) this.pointers[Squeak.Class_format] >> 7 ...;; (BinaryExpression) this.pointers[Squeak.Class_format] >> 7;; (ComputedMemberExpression) this.pointers[Squeak.Class_format];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Class_format;; (JSIdentifier) Class_format						local.get $Class_format						i32.const 4						i32.mul						i32.add;; (JSLiteral) 7						i32.const 7						i32.shr_s;; (JSLiteral) 15						i32.const 15						i32.and						return);; (JSProperty) property: classInstSize -> function() { ...;; (FunctionExpression) function() { 	var spec = this.pointers[S...(func $classInstSize						(local $spec i32)						(local $temp i32)						;; (ReturnStatement) return spec >> 10 & 192 + spec >> 1 & 63...;; (BinaryExpression) spec >> 10 & 192 + spec >> 1 & 63 - 1;; (BinaryExpression) spec >> 10 & 192 + spec >> 1 & 63;; (BinaryExpression) spec >> 10 & 192;; (BinaryExpression) spec >> 10;; (JSIdentifier) spec						local.get $spec;; (JSLiteral) 10						i32.const 10						i32.shr_s;; (JSLiteral) 192						i32.const 192						i32.and;; (BinaryExpression) spec >> 1 & 63;; (BinaryExpression) spec >> 1;; (JSIdentifier) spec						local.get $spec;; (JSLiteral) 1						i32.const 1						i32.shr_s;; (JSLiteral) 63						i32.const 63						i32.and						i32.add;; (JSLiteral) 1						i32.const 1						i32.sub						return);; (JSProperty) property: instVarNames -> function() { 	...;; (FunctionExpression) function() { 	for (var index = 3; index ...(func $instVarNames						(local $varNames i32)						(local $temp i32)						(local $index i32)						;; (ForStatement) for (var index = 3; index <= 4; index++)...;; (VariableDeclaration) var index = 3;; (VariableDeclarator) index = 3;; (JSLiteral) 3						i32.const 3						local.set $index						(loop $loop_1;; (BlockStatement) var varNames = this.pointers[index].poin...;; (VariableDeclaration) var varNames = this.pointers[index].poin...;; (VariableDeclarator) varNames = this.pointers[index].pointers;; (StaticMemberExpression) this.pointers[index].pointers;; (JSIdentifier) pointers						local.get $pointers						local.set $varNames;; (IfStatement) if (varNames && varNames.length && varNa...;; (BinaryExpression) varNames && varNames.length && varNames[...;; (BinaryExpression) varNames && varNames.length;; (JSIdentifier) varNames						local.get $varNames;; (StaticMemberExpression) varNames.length;; (JSIdentifier) length						local.get $length						i32.and;; (StaticMemberExpression) varNames[0].bytes;; (JSIdentifier) bytes						local.get $bytes						i32.and						i32.const 0						i32.ne						(if (then;; (BlockStatement) return varNames.map(function(each) { 	re...;; (ReturnStatement) return varNames.map(function(each) { 	re...;; (CallExpression) varNames.map(function(each) { 	return ea...						local.get $varNames;; (FunctionExpression) function(each) { 	return each.bytesAsStr...(func $nil						(local $each i32)						(local $temp i32)						;; (ReturnStatement) return each.bytesAsString();; (CallExpression) each.bytesAsString()						local.get $each						call $bytesAsString						return)						call $map						return));; (UpdateExpression) index++;; (JSIdentifier) index						local.get $index						i32.const 1						i32.add;; (BinaryExpression) index <= 4;; (JSIdentifier) index						local.get $index;; (JSLiteral) 4						i32.const 4						i32.le_u						i32.const 0						br_if $loop_1)						;; unwritable: (ReturnStatement) return []);; (JSProperty) property: allInstVarNames -> function() ...;; (FunctionExpression) function() { 	var superclass = this.supe...(func $allInstVarNames						(local $superclass i32)						(local $temp i32)												;; unwritable: (IfStatement) if (superclass.isNil) {return this.instV);; (JSProperty) property: superclass -> function() { 	re...;; (FunctionExpression) function() { 	return this.pointers[0] }(func $superclass						(local $temp i32)						;; (ReturnStatement) return this.pointers[0];; (ComputedMemberExpression) this.pointers[0];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: className -> function() { 	if ...;; (FunctionExpression) function() { 	if (!this.pointers) {retur...(func $className						(local $nameIdx i32)						(local $name i32)						(local $clsIndex i32)						(local $cls i32)						(local $temp i32)												;; unwritable: (IfStatement) if (!this.pointers) {return '_NOTACLASS_;; (ForStatement) for (var nameIdx = 6; nameIdx <= 7; name...;; (VariableDeclaration) var nameIdx = 6;; (VariableDeclarator) nameIdx = 6;; (JSLiteral) 6						i32.const 6						local.set $nameIdx						(loop $loop_1;; (BlockStatement) var name = this.pointers[nameIdx] if (na...;; (VariableDeclaration) var name = this.pointers[nameIdx];; (VariableDeclarator) name = this.pointers[nameIdx];; (ComputedMemberExpression) this.pointers[nameIdx];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSIdentifier) nameIdx						local.get $nameIdx						i32.const 4						i32.mul						i32.add						local.set $name;; (IfStatement) if (name && name.bytes) {return name.byt...;; (BinaryExpression) name && name.bytes;; (JSIdentifier) name						local.get $name;; (StaticMemberExpression) name.bytes;; (JSIdentifier) bytes						local.get $bytes						i32.and						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return name.bytesAsString();; (CallExpression) name.bytesAsString()						local.get $name						call $bytesAsString						return));; (UpdateExpression) nameIdx++;; (JSIdentifier) nameIdx						local.get $nameIdx						i32.const 1						i32.add;; (BinaryExpression) nameIdx <= 7;; (JSIdentifier) nameIdx						local.get $nameIdx;; (JSLiteral) 7						i32.const 7						i32.le_u						i32.const 0						br_if $loop_1)						;; unwritable: (ForStatement) for (var clsIndex = 5; clsIndex <= 6; cl						;; unwritable: (ReturnStatement) return '_SOMECLASS_');; (JSProperty) property: defaultInst -> function() { 	r...;; (FunctionExpression) function() { 	return Squeak.Object }(func $defaultInst						(local $temp i32)						;; (ReturnStatement) return Squeak.Object;; (StaticMemberExpression) Squeak.Object;; (JSIdentifier) Object						local.get $Object						return);; (JSProperty) property: classInstProto -> function(cla...;; (FunctionExpression) function(className) { 	if (this.instProt...(func $classInstProto						(local $className i32)						(local $temp i32)						(local $safeName i32)						(local $proto i32)						;; (IfStatement) if (this.instProto) {return this.instPro...;; (StaticMemberExpression) this.instProto;; (JSIdentifier) instProto						local.get $instProto						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.instProto;; (StaticMemberExpression) this.instProto;; (JSIdentifier) instProto						local.get $instProto						return));; (TryStatement) an active TryStatement with properties: ...						;; unwritable: (ExpressionStatement) Object.defineProperty(this, 'instProto',;; (ReturnStatement) return proto;; (JSIdentifier) proto						local.get $proto						return);; (JSProperty) property: methodNumLits -> function() { ...;; (FunctionExpression) function() { 	return this.pointers[0] >>...(func $methodNumLits						(local $temp i32)						;; (ReturnStatement) return this.pointers[0] >> 9 & 255;; (BinaryExpression) this.pointers[0] >> 9 & 255;; (BinaryExpression) this.pointers[0] >> 9;; (ComputedMemberExpression) this.pointers[0];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add;; (JSLiteral) 9						i32.const 9						i32.shr_s;; (JSLiteral) 255						i32.const 255						i32.and						return);; (JSProperty) property: methodNumArgs -> function() { ...;; (FunctionExpression) function() { 	return this.pointers[0] >>...(func $methodNumArgs						(local $temp i32)						;; (ReturnStatement) return this.pointers[0] >> 24 & 15;; (BinaryExpression) this.pointers[0] >> 24 & 15;; (BinaryExpression) this.pointers[0] >> 24;; (ComputedMemberExpression) this.pointers[0];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add;; (JSLiteral) 24						i32.const 24						i32.shr_s;; (JSLiteral) 15						i32.const 15						i32.and						return);; (JSProperty) property: methodPrimitiveIndex -> functi...;; (FunctionExpression) function() { 	var primBits = this.pointe...(func $methodPrimitiveIndex						(local $primBits i32)						(local $temp i32)						;; (IfStatement) if (primBits > 511) {return primBits & 5...;; (BinaryExpression) primBits > 511;; (JSIdentifier) primBits						local.get $primBits;; (JSLiteral) 511						i32.const 511						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return primBits & 511 + primBits >> 19;; (BinaryExpression) primBits & 511 + primBits >> 19;; (BinaryExpression) primBits & 511;; (JSIdentifier) primBits						local.get $primBits;; (JSLiteral) 511						i32.const 511						i32.and;; (BinaryExpression) primBits >> 19;; (JSIdentifier) primBits						local.get $primBits;; (JSLiteral) 19						i32.const 19						i32.shr_s						i32.add						return)						(else;; (ReturnStatement) return primBits;; (JSIdentifier) primBits						local.get $primBits						return)));; (JSProperty) property: methodClassForSuper -> functio...;; (FunctionExpression) function() { 	var assn = this.pointers[t...(func $methodClassForSuper						(local $assn i32)						(local $temp i32)						;; (ReturnStatement) return assn.pointers[Squeak.Assn_value];; (ComputedMemberExpression) assn.pointers[Squeak.Assn_value];; (StaticMemberExpression) assn.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Assn_value;; (JSIdentifier) Assn_value						local.get $Assn_value						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: methodNeedsLargeFrame -> funct...;; (FunctionExpression) function() { 	return this.pointers[0] & ...(func $methodNeedsLargeFrame						(local $temp i32)						;; (ReturnStatement) return this.pointers[0] & 131072 > 0;; (BinaryExpression) this.pointers[0] & 131072 > 0;; (BinaryExpression) this.pointers[0] & 131072;; (ComputedMemberExpression) this.pointers[0];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add;; (JSLiteral) 131072						i32.const 131072						i32.and;; (JSLiteral) 0						i32.const 0						i32.gt_u						return);; (JSProperty) property: methodAddPointers -> function(...;; (FunctionExpression) function(headerAndLits) { 	this.pointers...(func $methodAddPointers						(local $headerAndLits i32)						(local $temp i32)						;; (ExpressionStatement) this.pointers = headerAndLits;; (AssignmentExpression) this.pointers = headerAndLits;; (JSIdentifier) headerAndLits						local.get $headerAndLits						local.set $pointers);; (JSProperty) property: methodTempCount -> function() ...;; (FunctionExpression) function() { 	return this.pointers[0] >>...(func $methodTempCount						(local $temp i32)						;; (ReturnStatement) return this.pointers[0] >> 18 & 63;; (BinaryExpression) this.pointers[0] >> 18 & 63;; (BinaryExpression) this.pointers[0] >> 18;; (ComputedMemberExpression) this.pointers[0];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add;; (JSLiteral) 18						i32.const 18						i32.shr_s;; (JSLiteral) 63						i32.const 63						i32.and						return);; (JSProperty) property: methodGetLiteral -> function(z...;; (FunctionExpression) function(zeroBasedIndex) { 	return this....(func $methodGetLiteral						(local $temp i32)						(local $zeroBasedIndex i32)						;; (ReturnStatement) return this.pointers[1 + zeroBasedIndex];; (ComputedMemberExpression) this.pointers[1 + zeroBasedIndex];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) 1 + zeroBasedIndex;; (JSLiteral) 1						i32.const 1;; (JSIdentifier) zeroBasedIndex						local.get $zeroBasedIndex						i32.add						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: methodGetSelector -> function(...;; (FunctionExpression) function(zeroBasedIndex) { 	return this....(func $methodGetSelector						(local $temp i32)						(local $zeroBasedIndex i32)						;; (ReturnStatement) return this.pointers[1 + zeroBasedIndex];; (ComputedMemberExpression) this.pointers[1 + zeroBasedIndex];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) 1 + zeroBasedIndex;; (JSLiteral) 1						i32.const 1;; (JSIdentifier) zeroBasedIndex						local.get $zeroBasedIndex						i32.add						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: methodSelector -> function() {...;; (FunctionExpression) function() { 	return this.methodGetSelec...(func $methodSelector						(local $temp i32)												;; unwritable: (ReturnStatement) return this.methodGetSelector(this.metho);; (JSProperty) property: contextHome -> function() { 	r...;; (FunctionExpression) function() { 	return this.contextIsBlock...(func $contextHome						(local $temp i32)						;; (ReturnStatement) return this.contextIsBlock() ? this.poin...;; (ConditionalExpression) this.contextIsBlock() ? this.pointers[Sq...;; (CallExpression) this.contextIsBlock()						local.get $this						call $contextIsBlock						i32.const 1						i32.eq						(if (then;; (ComputedMemberExpression) this.pointers[Squeak.BlockContext_home];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.BlockContext_home;; (JSIdentifier) BlockContext_home						local.get $BlockContext_home						i32.const 4						i32.mul						i32.add)						(else;; (ThisExpression) this						))						return);; (JSProperty) property: contextIsBlock -> function() {...;; (FunctionExpression) function() { 	return typeof this.pointer...(func $contextIsBlock						(local $temp i32)												;; unwritable: (ReturnStatement) return typeof this.pointers[Squeak.Block);; (JSProperty) property: contextMethod -> function() { ...;; (FunctionExpression) function() { 	return this.contextHome()....(func $contextMethod						(local $temp i32)						;; (ReturnStatement) return this.contextHome().pointers[Squea...;; (ComputedMemberExpression) this.contextHome().pointers[Squeak.Conte...;; (StaticMemberExpression) this.contextHome().pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_method;; (JSIdentifier) Context_method						local.get $Context_method						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: contextSender -> function() { ...;; (FunctionExpression) function() { 	return this.pointers[Squea...(func $contextSender						(local $temp i32)						;; (ReturnStatement) return this.pointers[Squeak.Context_send...;; (ComputedMemberExpression) this.pointers[Squeak.Context_sender];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_sender;; (JSIdentifier) Context_sender						local.get $Context_sender						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: contextAncestor -> function(ge...;; (FunctionExpression) function(generation) { 	var ancestor = t...(func $contextAncestor						(local $generation i32)						(local $i i32)						(local $temp i32)						(local $ancestor i32)						;; (ForStatement) for (i = 0; i < generation; i++) {ancest...;; (AssignmentExpression) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (BlockStatement) ancestor = ancestor.contextSender() ;; (ExpressionStatement) ancestor = ancestor.contextSender();; (AssignmentExpression) ancestor = ancestor.contextSender();; (CallExpression) ancestor.contextSender()						local.get $ancestor						call $contextSender						local.set $ancestor;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < generation;; (JSIdentifier) i						local.get $i;; (JSIdentifier) generation						local.get $generation						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return ancestor;; (JSIdentifier) ancestor						local.get $ancestor						return);; (JSProperty) property: contextSizeWithStack -> functi...;; (FunctionExpression) function(vm) { 	if (vm && vm.activeConte...(func $contextSizeWithStack						(local $vm i32)						(local $temp i32)						(local $sp i32)						;; (IfStatement) if (vm && vm.activeContext === this) {re...;; (BinaryExpression) vm && vm.activeContext === this;; (JSIdentifier) vm						local.get $vm;; (BinaryExpression) vm.activeContext === this;; (StaticMemberExpression) vm.activeContext;; (JSIdentifier) activeContext						local.get $activeContext;; (ThisExpression) this						i32.eq						i32.and						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return vm.sp + 1;; (BinaryExpression) vm.sp + 1;; (StaticMemberExpression) vm.sp;; (JSIdentifier) sp						local.get $sp;; (JSLiteral) 1						i32.const 1						i32.add						return))						;; unwritable: (ReturnStatement) return Squeak.Context_tempFrameStart + t);; (JSProperty) property: initInstanceOf -> function(aCl...;; (FunctionExpression) function(aClass, indexableSize, hash, ni...(func $initInstanceOf						(local $indexableSize i32)						(local $hash i32)						(local $aClass i32)						(local $instSize i32)						(local $instSpec i32)						(local $format i32)						(local $nilObj i32)						(local $temp i32)						;; (ExpressionStatement) this.sqClass = aClass;; (AssignmentExpression) this.sqClass = aClass;; (JSIdentifier) aClass						local.get $aClass						local.set $sqClass;; (ExpressionStatement) this.hash = hash;; (AssignmentExpression) this.hash = hash;; (JSIdentifier) hash						local.get $hash						local.set $hash;; (ExpressionStatement) this._format = format;; (AssignmentExpression) this._format = format;; (JSIdentifier) format						local.get $format						local.set $_format;; (IfStatement) if (format < 12) {if (format < 10) {if (...;; (BinaryExpression) format < 12;; (JSIdentifier) format						local.get $format;; (JSLiteral) 12						i32.const 12						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (format < 10) {if (instSize + indexab...;; (IfStatement) if (format < 10) {if (instSize + indexab...;; (BinaryExpression) format < 10;; (JSIdentifier) format						local.get $format;; (JSLiteral) 10						i32.const 10						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (instSize + indexableSize > 0) {this....;; (IfStatement) if (instSize + indexableSize > 0) {this....;; (BinaryExpression) instSize + indexableSize > 0;; (BinaryExpression) instSize + indexableSize;; (JSIdentifier) instSize						local.get $instSize;; (JSIdentifier) indexableSize						local.get $indexableSize						i32.add;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.pointers = this.fillArray(instSize ...;; (AssignmentExpression) this.pointers = this.fillArray(instSize ...;; (CallExpression) this.fillArray(instSize + indexableSize,...						local.get $this;; (BinaryExpression) instSize + indexableSize;; (JSIdentifier) instSize						local.get $instSize;; (JSIdentifier) indexableSize						local.get $indexableSize						i32.add;; (JSIdentifier) nilObj						local.get $nilObj						call $fillArray						local.set $pointers)))						(else;; (IfStatement) if (indexableSize > 0) {if (aClass.isFlo...;; (BinaryExpression) indexableSize > 0;; (JSIdentifier) indexableSize						local.get $indexableSize;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (IfStatement) if (aClass.isFloatClass) {this.isFloat =...;; (StaticMemberExpression) aClass.isFloatClass;; (JSIdentifier) isFloatClass						local.get $isFloatClass						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.isFloat = true this.float = 0 ;; (ExpressionStatement) this.isFloat = true;; (AssignmentExpression) this.isFloat = true;; (JSLiteral) true						i32.const 1						local.set $isFloat;; (ExpressionStatement) this.float = 0;; (AssignmentExpression) this.float = 0;; (JSLiteral) 0						i32.const 0.0						local.set $float)						(else;; (ExpressionStatement) this.words = new Uint32Array(indexableSi...;; (AssignmentExpression) this.words = new Uint32Array(indexableSi...;; (NewExpression) new Uint32Array(indexableSize)						unreachable						local.set $words)))))))						(else;; (IfStatement) if (indexableSize > 0) {this.bytes = new...;; (BinaryExpression) indexableSize > 0;; (JSIdentifier) indexableSize						local.get $indexableSize;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.bytes = new Uint8Array(indexableSiz...;; (ExpressionStatement) this.bytes = new Uint8Array(indexableSiz...;; (AssignmentExpression) this.bytes = new Uint8Array(indexableSiz...;; (NewExpression) new Uint8Array(indexableSize)						unreachable						local.set $bytes)))));; (JSProperty) property: installFromImage -> function(o...;; (FunctionExpression) function(oopMap, rawBits, classTable, fl...(func $installFromImage						(local $nWords i32)						(local $temp i32)						(local $getCharacter i32)						(local $bits i32)						(local $classID i32)						(local $classTable i32)						(local $oopMap i32)						(local $floatClass i32)						(local $rawBits i32)						(local $littleEndian i32)						;; (IfStatement) if (classID < 32) {throw Error('Invalid ...;; (BinaryExpression) classID < 32;; (JSIdentifier) classID						local.get $classID;; (JSLiteral) 32						i32.const 32						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('Invalid class ID: ' + class...						unreachable));; (ExpressionStatement) this.sqClass = classTable[classID];; (AssignmentExpression) this.sqClass = classTable[classID];; (ComputedMemberExpression) classTable[classID];; (JSIdentifier) classTable						local.get $classTable;; (JSIdentifier) classID						local.get $classID						i32.const 4						i32.mul						i32.add						local.set $sqClass;; (IfStatement) if (!this.sqClass) {throw Error('Class I...;; (UnaryExpression) !this.sqClass;; (StaticMemberExpression) this.sqClass;; (JSIdentifier) sqClass						local.get $sqClass						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('Class ID not in class table...						unreachable))						;; unwritable: (SwitchStatement) switch (this._format) { case 0: case 1: ;; (ExpressionStatement) this.mark = false;; (AssignmentExpression) this.mark = false;; (JSLiteral) false						i32.const 0						local.set $mark);; (JSProperty) property: decodePointers -> function(nWo...;; (FunctionExpression) function(nWords, theBits, oopMap, getCha...(func $decodePointers						(local $theBits i32)						(local $oopMap i32)						(local $i i32)						(local $getCharacter i32)						(local $nWords i32)						(local $ptrs i32)						(local $oop i32)						(local $temp i32)						;; (ForStatement) for (var i = 0; i < nWords; i++) {var oo...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (BlockStatement) var oop = theBits[i] if (oop & 1 === 1) ...;; (VariableDeclaration) var oop = theBits[i];; (VariableDeclarator) oop = theBits[i];; (ComputedMemberExpression) theBits[i];; (JSIdentifier) theBits						local.get $theBits;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						local.set $oop;; (IfStatement) if (oop & 1 === 1) {ptrs[i] = oop >> 1 }...;; (BinaryExpression) oop & 1 === 1;; (BinaryExpression) oop & 1;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 1						i32.const 1						i32.and;; (JSLiteral) 1						i32.const 1						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) ptrs[i] = oop >> 1 ;; (ExpressionStatement) ptrs[i] = oop >> 1;; (AssignmentExpression) ptrs[i] = oop >> 1						local.get $'ptrs';; (JSIdentifier) i						local.get $i;; (BinaryExpression) oop >> 1;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 1						i32.const 1						i32.shr_s						call $atPut)						(else;; (IfStatement) if (oop & 3 === 2) {ptrs[i] = getCharact...;; (BinaryExpression) oop & 3 === 2;; (BinaryExpression) oop & 3;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 3						i32.const 3						i32.and;; (JSLiteral) 2						i32.const 2						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) ptrs[i] = getCharacter(oop >>> 2) ;; (ExpressionStatement) ptrs[i] = getCharacter(oop >>> 2);; (AssignmentExpression) ptrs[i] = getCharacter(oop >>> 2)						local.get $'ptrs';; (JSIdentifier) i						local.get $i;; (CallExpression) getCharacter(oop >>> 2);; (BinaryExpression) oop >>> 2;; (JSIdentifier) oop						local.get $oop;; (JSLiteral) 2						i32.const 2						i32.shr_u						call $getCharacter						call $atPut)						(else;; (BlockStatement) ptrs[i] = oopMap[oop] || 42424242 ;; (ExpressionStatement) ptrs[i] = oopMap[oop] || 42424242;; (AssignmentExpression) ptrs[i] = oopMap[oop] || 42424242						local.get $'ptrs';; (JSIdentifier) i						local.get $i;; (BinaryExpression) oopMap[oop] || 42424242;; (ComputedMemberExpression) oopMap[oop];; (JSIdentifier) oopMap						local.get $oopMap;; (JSIdentifier) oop						local.get $oop						i32.const 4						i32.mul						i32.add;; (JSLiteral) 42424242						i32.const 42424242						i32.or						call $atPut))));; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < nWords;; (JSIdentifier) i						local.get $i;; (JSIdentifier) nWords						local.get $nWords						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return ptrs;; (JSIdentifier) ptrs						local.get $ptrs						return);; (JSProperty) property: initInstanceOfChar -> function...;; (FunctionExpression) function(charClass, unicode) { 	this.oop...(func $initInstanceOfChar						(local $temp i32)						(local $charClass i32)						(local $unicode i32)						;; (ExpressionStatement) this.oop = unicode << 2 | 2;; (AssignmentExpression) this.oop = unicode << 2 | 2;; (BinaryExpression) unicode << 2 | 2;; (BinaryExpression) unicode << 2;; (JSIdentifier) unicode						local.get $unicode;; (JSLiteral) 2						i32.const 2						i32.shl;; (JSLiteral) 2						i32.const 2						i32.or						local.set $oop;; (ExpressionStatement) this.sqClass = charClass;; (AssignmentExpression) this.sqClass = charClass;; (JSIdentifier) charClass						local.get $charClass						local.set $sqClass;; (ExpressionStatement) this.hash = unicode;; (AssignmentExpression) this.hash = unicode;; (JSIdentifier) unicode						local.get $unicode						local.set $hash;; (ExpressionStatement) this._format = 7;; (AssignmentExpression) this._format = 7;; (JSLiteral) 7						i32.const 7						local.set $_format;; (ExpressionStatement) this.mark = true;; (AssignmentExpression) this.mark = true;; (JSLiteral) true						i32.const 1						local.set $mark);; (JSProperty) property: classNameFromImage -> function...;; (FunctionExpression) function(oopMap, rawBits) { 	var name = ...(func $classNameFromImage						(local $bytes i32)						(local $oopMap i32)						(local $bits i32)						(local $rawBits i32)						(local $name i32)						(local $temp i32)												;; unwritable: (IfStatement) if (name && name._format >= 16 && name._						;; unwritable: (ReturnStatement) return 'Class');; (JSProperty) property: renameFromImage -> function(oo...;; (FunctionExpression) function(oopMap, rawBits, classTable) { ...(func $renameFromImage						(local $classObj i32)						(local $oopMap i32)						(local $rawBits i32)						(local $temp i32)						(local $instProto i32)						(local $classTable i32)						(local $renamedObj i32)						;; (IfStatement) if (!classObj) {return this};; (UnaryExpression) !classObj;; (JSIdentifier) classObj						local.get $classObj						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this;; (ThisExpression) this						return));; (IfStatement) if (!instProto) {return this};; (UnaryExpression) !instProto;; (JSIdentifier) instProto						local.get $instProto						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this;; (ThisExpression) this						return));; (ExpressionStatement) renamedObj.oop = this.oop;; (AssignmentExpression) renamedObj.oop = this.oop;; (StaticMemberExpression) this.oop;; (JSIdentifier) oop						local.get $oop						local.set $oop;; (ExpressionStatement) renamedObj.sqClass = this.sqClass;; (AssignmentExpression) renamedObj.sqClass = this.sqClass;; (StaticMemberExpression) this.sqClass;; (JSIdentifier) sqClass						local.get $sqClass						local.set $sqClass;; (ExpressionStatement) renamedObj._format = this._format;; (AssignmentExpression) renamedObj._format = this._format;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format						local.set $_format;; (ExpressionStatement) renamedObj.hash = this.hash;; (AssignmentExpression) renamedObj.hash = this.hash;; (StaticMemberExpression) this.hash;; (JSIdentifier) hash						local.get $hash						local.set $hash;; (ReturnStatement) return renamedObj;; (JSIdentifier) renamedObj						local.get $renamedObj						return);; (JSProperty) property: instSize -> function() { 	if (...;; (FunctionExpression) function() { 	if (this._format < 2) {ret...(func $instSize						(local $temp i32)						;; (IfStatement) if (this._format < 2) {return this.point...;; (BinaryExpression) this._format < 2;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format;; (JSLiteral) 2						i32.const 2						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.pointersSize();; (CallExpression) this.pointersSize()						local.get $this						call $pointersSize						return));; (ReturnStatement) return this.sqClass.classInstSize();; (CallExpression) this.sqClass.classInstSize()						local.get $sqClass						call $classInstSize						return);; (JSProperty) property: indexableSize -> function(prim...;; (FunctionExpression) function(primHandler) { 	var fmt = this....(func $indexableSize						(local $fmt i32)						(local $primHandler i32)						(local $temp i32)						;; (IfStatement) if (fmt < 2) {return -1};; (BinaryExpression) fmt < 2;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 2						i32.const 2						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return -1;; (UnaryExpression) -1;; (JSLiteral) 1						i32.const 1						local.set $temp						i32.const 0						local.get $temp						i32.sub						return));; (IfStatement) if (fmt === 3 && primHandler.vm.isContex...;; (BinaryExpression) fmt === 3 && primHandler.vm.isContext(th...;; (BinaryExpression) fmt === 3;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 3						i32.const 3						i32.eq;; (CallExpression) primHandler.vm.isContext(this)						local.get $primHandler.vm;; (ThisExpression) this						call $isContext						i32.and						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.pointers[Squeak.Context_stac...;; (ComputedMemberExpression) this.pointers[Squeak.Context_stackPointe...;; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_stackPointer;; (JSIdentifier) Context_stackPointer						local.get $Context_stackPointer						i32.const 4						i32.mul						i32.add						return));; (IfStatement) if (fmt < 6) {return this.pointersSize()...;; (BinaryExpression) fmt < 6;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 6						i32.const 6						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.pointersSize() - this.instSi...;; (BinaryExpression) this.pointersSize() - this.instSize();; (CallExpression) this.pointersSize()						local.get $this						call $pointersSize;; (CallExpression) this.instSize()						local.get $this						call $instSize						i32.sub						return));; (IfStatement) if (fmt < 12) {return this.wordsSize()};; (BinaryExpression) fmt < 12;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 12						i32.const 12						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.wordsSize();; (CallExpression) this.wordsSize()						local.get $this						call $wordsSize						return));; (IfStatement) if (fmt < 16) {return this.shortsSize()};; (BinaryExpression) fmt < 16;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 16						i32.const 16						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.shortsSize();; (CallExpression) this.shortsSize()						local.get $this						call $shortsSize						return));; (IfStatement) if (fmt < 24) {return this.bytesSize()};; (BinaryExpression) fmt < 24;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 24						i32.const 24						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.bytesSize();; (CallExpression) this.bytesSize()						local.get $this						call $bytesSize						return));; (ReturnStatement) return 4 * this.pointersSize() + this.by...;; (BinaryExpression) 4 * this.pointersSize() + this.bytesSize...;; (BinaryExpression) 4 * this.pointersSize();; (JSLiteral) 4						i32.const 4;; (CallExpression) this.pointersSize()						local.get $this						call $pointersSize						i32.mul;; (CallExpression) this.bytesSize()						local.get $this						call $bytesSize						i32.add						return);; (JSProperty) property: snapshotSize -> function() { 	...;; (FunctionExpression) function() { 	var nWords = this.isFloat ...(func $snapshotSize						(local $nWords i32)						(local $extraHeader i32)						(local $temp i32)						;; (IfStatement) if (this.bytes) {nWords += this.bytes.le...;; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) nWords += this.bytes.length + 3 >>> 2;; (AssignmentExpression) nWords += this.bytes.length + 3 >>> 2;; (JSIdentifier) nWords						local.get $nWords;; (BinaryExpression) this.bytes.length + 3 >>> 2;; (BinaryExpression) this.bytes.length + 3;; (StaticMemberExpression) this.bytes.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 3						i32.const 3						i32.add;; (JSLiteral) 2						i32.const 2						i32.shr_u						i32.add						local.set $nWords));; (ExpressionStatement) nWords += nWords & 1;; (AssignmentExpression) nWords += nWords & 1;; (JSIdentifier) nWords						local.get $nWords;; (BinaryExpression) nWords & 1;; (JSIdentifier) nWords						local.get $nWords;; (JSLiteral) 1						i32.const 1						i32.and						i32.add						local.set $nWords;; (ExpressionStatement) nWords += 2;; (AssignmentExpression) nWords += 2;; (JSIdentifier) nWords						local.get $nWords;; (JSLiteral) 2						i32.const 2						i32.add						local.set $nWords;; (IfStatement) if (nWords < 4) {nWords = 4};; (BinaryExpression) nWords < 4;; (JSIdentifier) nWords						local.get $nWords;; (JSLiteral) 4						i32.const 4						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) nWords = 4;; (AssignmentExpression) nWords = 4;; (JSLiteral) 4						i32.const 4						local.set $nWords));; (ReturnStatement) return {property: header -> extraHeader,...;; (ObjectExpression) {property: header -> extraHeader, proper...						return);; (JSProperty) property: writeTo -> function(data, pos,...;; (FunctionExpression) function(data, pos, littleEndian, objToO...(func $writeTo						(local $data i32)						(local $nWords i32)						(local $temp i32)						(local $pos i32)						(local $beforePos i32)						(local $sizeAndHash i32)						(local $formatAndClass i32)						(local $i i32)						(local $objToOop i32)						(local $littleEndian i32)						;; (IfStatement) if (this.bytes) {nWords += this.bytes.le...;; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes						i32.const 0						i32.ne						(if (then;; (BlockStatement) nWords += this.bytes.length + 3 >>> 2 th...;; (ExpressionStatement) nWords += this.bytes.length + 3 >>> 2;; (AssignmentExpression) nWords += this.bytes.length + 3 >>> 2;; (JSIdentifier) nWords						local.get $nWords;; (BinaryExpression) this.bytes.length + 3 >>> 2;; (BinaryExpression) this.bytes.length + 3;; (StaticMemberExpression) this.bytes.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 3						i32.const 3						i32.add;; (JSLiteral) 2						i32.const 2						i32.shr_u						i32.add						local.set $nWords;; (ExpressionStatement) this._format |= -this.bytes.length & 3;; (AssignmentExpression) this._format |= -this.bytes.length & 3;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format;; (BinaryExpression) -this.bytes.length & 3;; (UnaryExpression) -this.bytes.length;; (StaticMemberExpression) this.bytes.length;; (JSIdentifier) length						local.get $length						local.set $temp						i32.const 0						local.get $temp						i32.sub;; (JSLiteral) 3						i32.const 3						i32.and						i32.sub						local.set $_format));; (IfStatement) if (nWords >= 255) {data.setUint32(pos, ...;; (BinaryExpression) nWords >= 255;; (JSIdentifier) nWords						local.get $nWords;; (JSLiteral) 255						i32.const 255						i32.ge_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) data.setUint32(pos, nWords, littleEndian...;; (ExpressionStatement) data.setUint32(pos, nWords, littleEndian...;; (CallExpression) data.setUint32(pos, nWords, littleEndian...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) nWords						local.get $nWords;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (ExpressionStatement) sizeAndHash = 255 << 24 | this.hash & 41...;; (AssignmentExpression) sizeAndHash = 255 << 24 | this.hash & 41...;; (BinaryExpression) 255 << 24 | this.hash & 4194303;; (BinaryExpression) 255 << 24;; (JSLiteral) 255						i32.const 255;; (JSLiteral) 24						i32.const 24						i32.shl;; (BinaryExpression) this.hash & 4194303;; (StaticMemberExpression) this.hash;; (JSIdentifier) hash						local.get $hash;; (JSLiteral) 4194303						i32.const 4194303						i32.and						i32.or						local.set $sizeAndHash;; (ExpressionStatement) data.setUint32(pos, sizeAndHash, littleE...;; (CallExpression) data.setUint32(pos, sizeAndHash, littleE...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) sizeAndHash						local.get $sizeAndHash;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos));; (ExpressionStatement) data.setUint32(pos, formatAndClass, litt...;; (CallExpression) data.setUint32(pos, formatAndClass, litt...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) formatAndClass						local.get $formatAndClass;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (ExpressionStatement) data.setUint32(pos, sizeAndHash, littleE...;; (CallExpression) data.setUint32(pos, sizeAndHash, littleE...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (JSIdentifier) sizeAndHash						local.get $sizeAndHash;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (IfStatement) if (this.isFloat) {data.setFloat64(pos, ...;; (StaticMemberExpression) this.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						i32.const 0						i32.ne						(if (then;; (BlockStatement) data.setFloat64(pos, this.float, littleE...;; (ExpressionStatement) data.setFloat64(pos, this.float, littleE...;; (CallExpression) data.setFloat64(pos, this.float, littleE...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (StaticMemberExpression) this.float;; (JSIdentifier) float						local.get $float;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setFloat64;; (ExpressionStatement) pos += 8;; (AssignmentExpression) pos += 8;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 8						i32.const 8						i32.add						local.set $pos)						(else;; (IfStatement) if (this.words) {for (var i = 0; i < thi...;; (StaticMemberExpression) this.words;; (JSIdentifier) words						local.get $words						i32.const 0						i32.ne						(if (then;; (BlockStatement) for (var i = 0; i < this.words.length; i...;; (ForStatement) for (var i = 0; i < this.words.length; i...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (BlockStatement) data.setUint32(pos, this.words[i], littl...;; (ExpressionStatement) data.setUint32(pos, this.words[i], littl...;; (CallExpression) data.setUint32(pos, this.words[i], littl...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (ComputedMemberExpression) this.words[i];; (StaticMemberExpression) this.words;; (JSIdentifier) words						local.get $words;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < this.words.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) this.words.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_1))						(else;; (IfStatement) if (this.pointers) {for (var i = 0; i < ...;; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers						i32.const 0						i32.ne						(if (then;; (BlockStatement) for (var i = 0; i < this.pointers.length...;; (ForStatement) for (var i = 0; i < this.pointers.length...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_2;; (BlockStatement) data.setUint32(pos, objToOop(this.pointe...;; (ExpressionStatement) data.setUint32(pos, objToOop(this.pointe...;; (CallExpression) data.setUint32(pos, objToOop(this.pointe...						local.get $data;; (JSIdentifier) pos						local.get $pos;; (CallExpression) objToOop(this.pointers[i]);; (ComputedMemberExpression) this.pointers[i];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						call $objToOop;; (JSIdentifier) littleEndian						local.get $littleEndian						call $setUint32;; (ExpressionStatement) pos += 4;; (AssignmentExpression) pos += 4;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 4						i32.const 4						i32.add						local.set $pos;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < this.pointers.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) this.pointers.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_2)))))));; (IfStatement) if (this.bytes) {for (var i = 0; i < thi...;; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes						i32.const 0						i32.ne						(if (then;; (BlockStatement) for (var i = 0; i < this.bytes.length; i...;; (ForStatement) for (var i = 0; i < this.bytes.length; i...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_3;; (ExpressionStatement) data.setUint8(pos++, this.bytes[i]);; (CallExpression) data.setUint8(pos++, this.bytes[i])						local.get $data;; (UpdateExpression) pos++;; (JSIdentifier) pos						local.get $pos						i32.const 1						i32.add;; (ComputedMemberExpression) this.bytes[i];; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						call $setUint8;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < this.bytes.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) this.bytes.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_3);; (ExpressionStatement) pos += -this.bytes.length & 3;; (AssignmentExpression) pos += -this.bytes.length & 3;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) -this.bytes.length & 3;; (UnaryExpression) -this.bytes.length;; (StaticMemberExpression) this.bytes.length;; (JSIdentifier) length						local.get $length						local.set $temp						i32.const 0						local.get $temp						i32.sub;; (JSLiteral) 3						i32.const 3						i32.and						i32.add						local.set $pos));; (IfStatement) if (nWords === 0) {pos += 8} else {pos +...;; (BinaryExpression) nWords === 0;; (JSIdentifier) nWords						local.get $nWords;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) pos += 8;; (AssignmentExpression) pos += 8;; (JSIdentifier) pos						local.get $pos;; (JSLiteral) 8						i32.const 8						i32.add						local.set $pos)						(else;; (ExpressionStatement) pos += nWords & 1 * 4;; (AssignmentExpression) pos += nWords & 1 * 4;; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) nWords & 1 * 4;; (BinaryExpression) nWords & 1;; (JSIdentifier) nWords						local.get $nWords;; (JSLiteral) 1						i32.const 1						i32.and;; (JSLiteral) 4						i32.const 4						i32.mul						i32.add						local.set $pos));; (IfStatement) if (pos !== beforePos + this.totalBytes(...;; (BinaryExpression) pos !== beforePos + this.totalBytes();; (JSIdentifier) pos						local.get $pos;; (BinaryExpression) beforePos + this.totalBytes();; (JSIdentifier) beforePos						local.get $beforePos;; (CallExpression) this.totalBytes()						local.get $this						call $totalBytes						i32.add						i32.ne						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('written size does not match...						unreachable));; (ReturnStatement) return pos;; (JSIdentifier) pos						local.get $pos						return);; (JSProperty) property: isBytes -> function() { 	var f...;; (FunctionExpression) function() { 	var fmt = this._format ret...(func $isBytes						(local $fmt i32)						(local $temp i32)						;; (ReturnStatement) return fmt >= 16 && fmt <= 23;; (BinaryExpression) fmt >= 16 && fmt <= 23;; (BinaryExpression) fmt >= 16;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 16						i32.const 16						i32.ge_u;; (BinaryExpression) fmt <= 23;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 23						i32.const 23						i32.le_u						i32.and						return);; (JSProperty) property: isPointers -> function() { 	re...;; (FunctionExpression) function() { 	return this._format <= 6 }(func $isPointers						(local $temp i32)						;; (ReturnStatement) return this._format <= 6;; (BinaryExpression) this._format <= 6;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format;; (JSLiteral) 6						i32.const 6						i32.le_u						return);; (JSProperty) property: isWords -> function() { 	retur...;; (FunctionExpression) function() { 	return this._format === 10...(func $isWords						(local $temp i32)						;; (ReturnStatement) return this._format === 10;; (BinaryExpression) this._format === 10;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format;; (JSLiteral) 10						i32.const 10						i32.eq						return);; (JSProperty) property: isWordsOrBytes -> function() {...;; (FunctionExpression) function() { 	var fmt = this._format ret...(func $isWordsOrBytes						(local $fmt i32)						(local $temp i32)						;; (ReturnStatement) return fmt === 10 || fmt >= 16 && fmt <=...;; (BinaryExpression) fmt === 10 || fmt >= 16 && fmt <= 23;; (BinaryExpression) fmt === 10;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 10						i32.const 10						i32.eq;; (BinaryExpression) fmt >= 16 && fmt <= 23;; (BinaryExpression) fmt >= 16;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 16						i32.const 16						i32.ge_u;; (BinaryExpression) fmt <= 23;; (JSIdentifier) fmt						local.get $fmt;; (JSLiteral) 23						i32.const 23						i32.le_u						i32.and						i32.or						return);; (JSProperty) property: isWeak -> function() { 	return...;; (FunctionExpression) function() { 	return this._format === 4 ...(func $isWeak						(local $temp i32)						;; (ReturnStatement) return this._format === 4;; (BinaryExpression) this._format === 4;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format;; (JSLiteral) 4						i32.const 4						i32.eq						return);; (JSProperty) property: isMethod -> function() { 	retu...;; (FunctionExpression) function() { 	return this._format >= 24 ...(func $isMethod						(local $temp i32)						;; (ReturnStatement) return this._format >= 24;; (BinaryExpression) this._format >= 24;; (StaticMemberExpression) this._format;; (JSIdentifier) _format						local.get $_format;; (JSLiteral) 24						i32.const 24						i32.ge_u						return);; (JSProperty) property: sameFormats -> function(a, b) ...;; (FunctionExpression) function(a, b) { 	return a < 16 ? a === ...(func $sameFormats						(local $b i32)						(local $temp i32)						(local $a i32)						;; (ReturnStatement) return a < 16 ? a === b : a & 248 === b ...;; (ConditionalExpression) a < 16 ? a === b : a & 248 === b & 248;; (BinaryExpression) a < 16;; (JSIdentifier) a						local.get $a;; (JSLiteral) 16						i32.const 16						i32.lt_u						i32.const 1						i32.eq						(if (then;; (BinaryExpression) a === b;; (JSIdentifier) a						local.get $a;; (JSIdentifier) b						local.get $b						i32.eq)						(else;; (BinaryExpression) a & 248 === b & 248;; (BinaryExpression) a & 248;; (JSIdentifier) a						local.get $a;; (JSLiteral) 248						i32.const 248						i32.and;; (BinaryExpression) b & 248;; (JSIdentifier) b						local.get $b;; (JSLiteral) 248						i32.const 248						i32.and						i32.eq						))						return);; (JSProperty) property: defaultInst -> function() { 	r...;; (FunctionExpression) function() { 	return Squeak.ObjectSpur }(func $defaultInst						(local $temp i32)						;; (ReturnStatement) return Squeak.ObjectSpur;; (StaticMemberExpression) Squeak.ObjectSpur;; (JSIdentifier) ObjectSpur						local.get $ObjectSpur						return);; (JSProperty) property: classInstFormat -> function() ...;; (FunctionExpression) function() { 	return this.pointers[Squea...(func $classInstFormat						(local $temp i32)						;; (ReturnStatement) return this.pointers[Squeak.Class_format...;; (BinaryExpression) this.pointers[Squeak.Class_format] >> 16...;; (BinaryExpression) this.pointers[Squeak.Class_format] >> 16;; (ComputedMemberExpression) this.pointers[Squeak.Class_format];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Class_format;; (JSIdentifier) Class_format						local.get $Class_format						i32.const 4						i32.mul						i32.add;; (JSLiteral) 16						i32.const 16						i32.shr_s;; (JSLiteral) 31						i32.const 31						i32.and						return);; (JSProperty) property: classInstSize -> function() { ...;; (FunctionExpression) function() { 	return this.pointers[Squea...(func $classInstSize						(local $temp i32)						;; (ReturnStatement) return this.pointers[Squeak.Class_format...;; (BinaryExpression) this.pointers[Squeak.Class_format] & 655...;; (ComputedMemberExpression) this.pointers[Squeak.Class_format];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Class_format;; (JSIdentifier) Class_format						local.get $Class_format						i32.const 4						i32.mul						i32.add;; (JSLiteral) 65535						i32.const 65535						i32.and						return);; (JSProperty) property: classByteSizeOfInstance -> fun...;; (FunctionExpression) function(nElements) { 	var format = this...(func $classByteSizeOfInstance						(local $temp i32)						(local $nWords i32)						(local $format i32)						(local $nElements i32)						;; (IfStatement) if (format < 9) {nWords += nElements} el...;; (BinaryExpression) format < 9;; (JSIdentifier) format						local.get $format;; (JSLiteral) 9						i32.const 9						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) nWords += nElements;; (AssignmentExpression) nWords += nElements;; (JSIdentifier) nWords						local.get $nWords;; (JSIdentifier) nElements						local.get $nElements						i32.add						local.set $nWords)						(else;; (IfStatement) if (format >= 16) {nWords += nElements +...;; (BinaryExpression) format >= 16;; (JSIdentifier) format						local.get $format;; (JSLiteral) 16						i32.const 16						i32.ge_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) nWords += nElements + 3 / 4 | 0;; (AssignmentExpression) nWords += nElements + 3 / 4 | 0;; (JSIdentifier) nWords						local.get $nWords;; (BinaryExpression) nElements + 3 / 4 | 0;; (BinaryExpression) nElements + 3 / 4;; (BinaryExpression) nElements + 3;; (JSIdentifier) nElements						local.get $nElements;; (JSLiteral) 3						i32.const 3						i32.add;; (JSLiteral) 4						i32.const 4						i32.div_s;; (JSLiteral) 0						i32.const 0						i32.or						i32.add						local.set $nWords)						(else;; (IfStatement) if (format >= 12) {nWords += nElements +...;; (BinaryExpression) format >= 12;; (JSIdentifier) format						local.get $format;; (JSLiteral) 12						i32.const 12						i32.ge_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) nWords += nElements + 1 / 2 | 0;; (AssignmentExpression) nWords += nElements + 1 / 2 | 0;; (JSIdentifier) nWords						local.get $nWords;; (BinaryExpression) nElements + 1 / 2 | 0;; (BinaryExpression) nElements + 1 / 2;; (BinaryExpression) nElements + 1;; (JSIdentifier) nElements						local.get $nElements;; (JSLiteral) 1						i32.const 1						i32.add;; (JSLiteral) 2						i32.const 2						i32.div_s;; (JSLiteral) 0						i32.const 0						i32.or						i32.add						local.set $nWords)						(else;; (IfStatement) if (format >= 10) {nWords += nElements} ...;; (BinaryExpression) format >= 10;; (JSIdentifier) format						local.get $format;; (JSLiteral) 10						i32.const 10						i32.ge_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) nWords += nElements;; (AssignmentExpression) nWords += nElements;; (JSIdentifier) nWords						local.get $nWords;; (JSIdentifier) nElements						local.get $nElements						i32.add						local.set $nWords)						(else;; (ExpressionStatement) nWords += nElements * 2;; (AssignmentExpression) nWords += nElements * 2;; (JSIdentifier) nWords						local.get $nWords;; (BinaryExpression) nElements * 2;; (JSIdentifier) nElements						local.get $nElements;; (JSLiteral) 2						i32.const 2						i32.mul						i32.add						local.set $nWords))))))));; (ExpressionStatement) nWords += nWords & 1;; (AssignmentExpression) nWords += nWords & 1;; (JSIdentifier) nWords						local.get $nWords;; (BinaryExpression) nWords & 1;; (JSIdentifier) nWords						local.get $nWords;; (JSLiteral) 1						i32.const 1						i32.and						i32.add						local.set $nWords;; (ExpressionStatement) nWords += nWords >= 255 ? 4 : 2;; (AssignmentExpression) nWords += nWords >= 255 ? 4 : 2;; (JSIdentifier) nWords						local.get $nWords;; (ConditionalExpression) nWords >= 255 ? 4 : 2;; (BinaryExpression) nWords >= 255;; (JSIdentifier) nWords						local.get $nWords;; (JSLiteral) 255						i32.const 255						i32.ge_u						i32.const 1						i32.eq						(if (then;; (JSLiteral) 4						i32.const 4)						(else;; (JSLiteral) 2						i32.const 2						))						i32.add						local.set $nWords;; (IfStatement) if (nWords < 4) {nWords = 4};; (BinaryExpression) nWords < 4;; (JSIdentifier) nWords						local.get $nWords;; (JSLiteral) 4						i32.const 4						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) nWords = 4;; (AssignmentExpression) nWords = 4;; (JSLiteral) 4						i32.const 4						local.set $nWords));; (ReturnStatement) return nWords * 4;; (BinaryExpression) nWords * 4;; (JSIdentifier) nWords						local.get $nWords;; (JSLiteral) 4						i32.const 4						i32.mul						return);; (JSProperty) property: methodNumLits -> function() { ...;; (FunctionExpression) function() { 	return this.pointers[0] & ...(func $methodNumLits						(local $temp i32)						;; (ReturnStatement) return this.pointers[0] & 32767;; (BinaryExpression) this.pointers[0] & 32767;; (ComputedMemberExpression) this.pointers[0];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add;; (JSLiteral) 32767						i32.const 32767						i32.and						return);; (JSProperty) property: methodPrimitiveIndex -> functi...;; (FunctionExpression) function() { 	if (this.pointers[0] & 655...(func $methodPrimitiveIndex						(local $temp i32)						;; (IfStatement) if (this.pointers[0] & 65536 === 0) {ret...;; (BinaryExpression) this.pointers[0] & 65536 === 0;; (BinaryExpression) this.pointers[0] & 65536;; (ComputedMemberExpression) this.pointers[0];; (StaticMemberExpression) this.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add;; (JSLiteral) 65536						i32.const 65536						i32.and;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return));; (ReturnStatement) return this.bytes[1] + 256 * this.bytes[...;; (BinaryExpression) this.bytes[1] + 256 * this.bytes[2];; (ComputedMemberExpression) this.bytes[1];; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes;; (JSLiteral) 1						i32.const 1						i32.const 4						i32.mul						i32.add;; (BinaryExpression) 256 * this.bytes[2];; (JSLiteral) 256						i32.const 256;; (ComputedMemberExpression) this.bytes[2];; (StaticMemberExpression) this.bytes;; (JSIdentifier) bytes						local.get $bytes;; (JSLiteral) 2						i32.const 2						i32.const 4						i32.mul						i32.add						i32.mul						i32.add						return);; (JSProperty) property: initialize -> function(image, ...;; (FunctionExpression) function(image, display) { 	this.status(...(func $initialize						(local $display i32)						(local $image i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.status('squeak: initializing interp						;; unwritable: (ExpressionStatement) console.log('squeak: initializing interp;; (ExpressionStatement) this.Squeak = Squeak;; (AssignmentExpression) this.Squeak = Squeak;; (JSIdentifier) Squeak						local.get $Squeak						local.set $Squeak;; (ExpressionStatement) this.image = image;; (AssignmentExpression) this.image = image;; (JSIdentifier) image						local.get $image						local.set $image;; (ExpressionStatement) this.image.vm = this;; (AssignmentExpression) this.image.vm = this;; (ThisExpression) this						local.set $vm;; (ExpressionStatement) this.primHandler = new Squeak.Primitives...;; (AssignmentExpression) this.primHandler = new Squeak.Primitives...;; (NewExpression) new Squeak.Primitives(this, display)						unreachable						local.set $primHandler;; (ExpressionStatement) this.loadImageState();; (CallExpression) this.loadImageState()						local.get $this						call $loadImageState;; (ExpressionStatement) this.hackImage();; (CallExpression) this.hackImage()						local.get $this						call $hackImage;; (ExpressionStatement) this.initVMState();; (CallExpression) this.initVMState()						local.get $this						call $initVMState;; (ExpressionStatement) this.loadInitialContext();; (CallExpression) this.loadInitialContext()						local.get $this						call $loadInitialContext;; (ExpressionStatement) this.initCompiler();; (CallExpression) this.initCompiler()						local.get $this						call $initCompiler						;; unwritable: (ExpressionStatement) console.log('squeak: ready'));; (JSProperty) property: objectWithUUID -> function(uui...;; (FunctionExpression) function(uuid) { 	var object = this.imag...(func $objectWithUUID						(local $object i32)						(local $uuid i32)						(local $temp i32)						;; (WhileStatement) while (object) {if (this.uuidForObject(o...						(loop $loop_1;; (BlockStatement) if (this.uuidForObject(object) === uuid)...;; (IfStatement) if (this.uuidForObject(object) === uuid)...;; (BinaryExpression) this.uuidForObject(object) === uuid;; (CallExpression) this.uuidForObject(object)						local.get $this;; (JSIdentifier) object						local.get $object						call $uuidForObject;; (JSIdentifier) uuid						local.get $uuid						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return object;; (JSIdentifier) object						local.get $object						return)						(else;; (ExpressionStatement) object = object.nextObject;; (AssignmentExpression) object = object.nextObject;; (StaticMemberExpression) object.nextObject;; (JSIdentifier) nextObject						local.get $nextObject						local.set $object));; (JSIdentifier) object						local.get $object						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ReturnStatement) return uuid;; (JSIdentifier) uuid						local.get $uuid						return);; (JSProperty) property: uuidForObject -> function(obje...;; (FunctionExpression) function(object) { 	if (object.sqClass) ...(func $uuidForObject						(local $object i32)						(local $temp i32)												;; unwritable: (IfStatement) if (object.sqClass) {if (object.oop <= 0);; (JSProperty) property: nextByteGuarded -> function() ...;; (FunctionExpression) function() { 	var byte = this.nextByte()...(func $nextByteGuarded						(local $byte i32)						(local $temp i32)												;; unwritable: (IfStatement) if (typeof byte == 'undefined') {an acti;; (ReturnStatement) return byte;; (JSIdentifier) byte						local.get $byte						return);; (JSProperty) property: log -> function(packed) { 	con...;; (FunctionExpression) function(packed) { 	console.log(packed) ...(func $log						(local $packed i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) console.log(packed));; (JSProperty) property: pop2AndPushDivResult -> functi...;; (FunctionExpression) function(first, second) { 	return this.p...(func $pop2AndPushDivResult						(local $first i32)						(local $second i32)						(local $temp i32)						;; (ReturnStatement) return this.pop2AndPushIntResult(this.di...;; (CallExpression) this.pop2AndPushIntResult(this.div(first...						local.get $this;; (CallExpression) this.div(first, second)						local.get $this;; (JSIdentifier) first						local.get $first;; (JSIdentifier) second						local.get $second						call $div						call $pop2AndPushIntResult						return);; (JSProperty) property: pushExportThisContext -> funct...;; (FunctionExpression) function() { 	this.push(this.exportThisC...(func $pushExportThisContext						(local $temp i32)						;; (ExpressionStatement) this.push(this.exportThisContext());; (CallExpression) this.push(this.exportThisContext())						local.get $this;; (CallExpression) this.exportThisContext()						local.get $this						call $exportThisContext						call $push);; (JSProperty) property: doReturnWithUUID -> function(v...;; (FunctionExpression) function(value, context) { 	this.doRetur...(func $doReturnWithUUID						(local $context i32)						(local $value i32)						(local $temp i32)						;; (ExpressionStatement) this.doReturn(this.objectWithUUID(value)...;; (CallExpression) this.doReturn(this.objectWithUUID(value)...						local.get $this;; (CallExpression) this.objectWithUUID(value)						local.get $this;; (JSIdentifier) value						local.get $value						call $objectWithUUID;; (CallExpression) this.objectWithUUID(context)						local.get $this;; (JSIdentifier) context						local.get $context						call $objectWithUUID						call $doReturn);; (JSProperty) property: pushObjectWithUUID -> function...;; (FunctionExpression) function(uuid) { 	this.push(this.objectW...(func $pushObjectWithUUID						(local $uuid i32)						(local $temp i32)						;; (ExpressionStatement) this.push(this.objectWithUUID(uuid));; (CallExpression) this.push(this.objectWithUUID(uuid))						local.get $this;; (CallExpression) this.objectWithUUID(uuid)						local.get $this;; (JSIdentifier) uuid						local.get $uuid						call $objectWithUUID						call $push);; (JSProperty) property: pop2AndPushBoolResultWithUUID ...;; (FunctionExpression) function(bool) { 	return this.pop2AndPus...(func $pop2AndPushBoolResultWithUUID						(local $temp i32)						(local $bool i32)						;; (ReturnStatement) return this.pop2AndPushBoolResult(bool);; (CallExpression) this.pop2AndPushBoolResult(bool)						local.get $this;; (JSIdentifier) bool						local.get $bool						call $pop2AndPushBoolResult						return);; (JSProperty) property: pop2AndPushNumResultWithUUID -...;; (FunctionExpression) function(num) { 	return this.pop2AndPush...(func $pop2AndPushNumResultWithUUID						(local $num i32)						(local $temp i32)						;; (ReturnStatement) return this.pop2AndPushNumResult(this.ob...;; (CallExpression) this.pop2AndPushNumResult(this.objectWit...						local.get $this;; (CallExpression) this.objectWithUUID(num)						local.get $this;; (JSIdentifier) num						local.get $num						call $objectWithUUID						call $pop2AndPushNumResult						return);; (JSProperty) property: stackIntOrFloatUsingUUID -> fu...;; (FunctionExpression) function(depth) { 	return this.uuidForOb...(func $stackIntOrFloatUsingUUID						(local $temp i32)						(local $depth i32)						;; (ReturnStatement) return this.uuidForObject(this.stackIntO...;; (CallExpression) this.uuidForObject(this.stackIntOrFloat(...						local.get $this;; (CallExpression) this.stackIntOrFloat(depth)						local.get $this;; (JSIdentifier) depth						local.get $depth						call $stackIntOrFloat						call $uuidForObject						return);; (JSProperty) property: popUsingUUID -> function() { 	...;; (FunctionExpression) function() { 	var uuid = this.uuidForObj...(func $popUsingUUID						(local $uuid i32)						(local $temp i32)						;; (ExpressionStatement) this.pop();; (CallExpression) this.pop()						local.get $this						call $pop;; (ReturnStatement) return uuid;; (JSIdentifier) uuid						local.get $uuid						return);; (JSProperty) property: topUsingUUID -> function() { 	...;; (FunctionExpression) function() { 	return this.uuidForObject(...(func $topUsingUUID						(local $temp i32)						;; (ReturnStatement) return this.uuidForObject(this.top());; (CallExpression) this.uuidForObject(this.top())						local.get $this;; (CallExpression) this.top()						local.get $this						call $top						call $uuidForObject						return);; (JSProperty) property: receiverBeDirty -> function() ...;; (FunctionExpression) function() { 	this.receiver.dirty = true...(func $receiverBeDirty						(local $temp i32)						;; (ExpressionStatement) this.receiver.dirty = true;; (AssignmentExpression) this.receiver.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty);; (JSProperty) property: pointersAt -> function(uuid, i...;; (FunctionExpression) function(uuid, index) { 	an active TrySt...(func $pointersAt						(local $temp i32)						(local $uuid i32)						(local $index i32)						;; (TryStatement) an active TryStatement with properties: ...);; (JSProperty) property: pointersAtPut -> function(uuid...;; (FunctionExpression) function(uuid, index, value) { 	an activ...(func $pointersAtPut						(local $value i32)						(local $temp i32)						(local $index i32)						(local $uuid i32)						;; (TryStatement) an active TryStatement with properties: ...);; (JSProperty) property: homeContextPointersAtPut -> fu...;; (FunctionExpression) function(index, value) { 	this.homeConte...(func $homeContextPointersAtPut						(local $temp i32)						(local $value i32)						(local $index i32)						;; (ExpressionStatement) this.homeContext.pointers[index] = this....;; (AssignmentExpression) this.homeContext.pointers[index] = this....						local.get $this.homeContext;; (JSIdentifier) index						local.get $index;; (CallExpression) this.objectWithUUID(value)						local.get $this;; (JSIdentifier) value						local.get $value						call $objectWithUUID						call $atPut);; (JSProperty) property: receiverPointersAtPut -> funct...;; (FunctionExpression) function(index, value) { 	this.receiver....(func $receiverPointersAtPut						(local $temp i32)						(local $value i32)						(local $index i32)						;; (ExpressionStatement) this.receiver.pointers[index] = this.obj...;; (AssignmentExpression) this.receiver.pointers[index] = this.obj...						local.get $this.receiver;; (JSIdentifier) index						local.get $index;; (CallExpression) this.objectWithUUID(value)						local.get $this;; (JSIdentifier) value						local.get $value						call $objectWithUUID						call $atPut);; (JSProperty) property: quickSendOtherWithUUID -> func...;; (FunctionExpression) function(uuid, lobits) { 	return this.pr...(func $quickSendOtherWithUUID						(local $temp i32)						(local $uuid i32)						(local $lobits i32)						;; (ReturnStatement) return this.primHandler.quickSendOther(t...;; (CallExpression) this.primHandler.quickSendOther(this.obj...						local.get $primHandler;; (CallExpression) this.objectWithUUID(uuid)						local.get $this;; (JSIdentifier) uuid						local.get $uuid						call $objectWithUUID;; (JSIdentifier) lobits						local.get $lobits						call $quickSendOther						return);; (JSProperty) property: sendFromUUID -> function(uuid,...;; (FunctionExpression) function(uuid, index, bool) { 	this.send...(func $sendFromUUID						(local $temp i32)						(local $index i32)						(local $uuid i32)						(local $bool i32)						;; (ExpressionStatement) this.send(this.objectWithUUID(uuid), ind...;; (CallExpression) this.send(this.objectWithUUID(uuid), ind...						local.get $this;; (CallExpression) this.objectWithUUID(uuid)						local.get $this;; (JSIdentifier) uuid						local.get $uuid						call $objectWithUUID;; (JSIdentifier) index						local.get $index;; (JSIdentifier) bool						local.get $bool						call $send);; (JSProperty) property: theByteCodeCount -> function()...;; (FunctionExpression) function() { 	return this.byteCodeCount ...(func $theByteCodeCount						(local $temp i32)						;; (ReturnStatement) return this.byteCodeCount;; (StaticMemberExpression) this.byteCodeCount;; (JSIdentifier) byteCodeCount						local.get $byteCodeCount						return);; (JSProperty) property: setByteCodeCount -> function(c...;; (FunctionExpression) function(count) { 	this.byteCodeCount = ...(func $setByteCodeCount						(local $count i32)						(local $temp i32)						;; (ExpressionStatement) this.byteCodeCount = count;; (AssignmentExpression) this.byteCodeCount = count;; (JSIdentifier) count						local.get $count						local.set $byteCodeCount);; (JSProperty) property: thePC -> function() { 	return ...;; (FunctionExpression) function() { 	return this.pc }(func $thePC						(local $temp i32)						;; (ReturnStatement) return this.pc;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc						return);; (JSProperty) property: setPC -> function(thePC) { 	th...;; (FunctionExpression) function(thePC) { 	this.pc = thePC }(func $setPC						(local $thePC i32)						(local $temp i32)						;; (ExpressionStatement) this.pc = thePC;; (AssignmentExpression) this.pc = thePC;; (JSIdentifier) thePC						local.get $thePC						local.set $pc);; (JSProperty) property: theSuccess -> function() { 	re...;; (FunctionExpression) function() { 	return this.success }(func $theSuccess						(local $temp i32)						;; (ReturnStatement) return this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						return);; (JSProperty) property: setSuccess -> function(theSucc...;; (FunctionExpression) function(theSuccess) { 	this.success = t...(func $setSuccess						(local $temp i32)						(local $theSuccess i32)						;; (ExpressionStatement) this.success = theSuccess;; (AssignmentExpression) this.success = theSuccess;; (JSIdentifier) theSuccess						local.get $theSuccess						local.set $success);; (JSProperty) property: setResultIsFloat -> function(t...;; (FunctionExpression) function(theResultIsFloat) { 	this.resul...(func $setResultIsFloat						(local $theResultIsFloat i32)						(local $temp i32)						;; (ExpressionStatement) this.resultIsFloat = theResultIsFloat;; (AssignmentExpression) this.resultIsFloat = theResultIsFloat;; (JSIdentifier) theResultIsFloat						local.get $theResultIsFloat						local.set $resultIsFloat);; (JSProperty) property: theInterruptCheckCounter -> fu...;; (FunctionExpression) function() { 	return this.interruptCheck...(func $theInterruptCheckCounter						(local $temp i32)						;; (ReturnStatement) return this.interruptCheckCounter;; (StaticMemberExpression) this.interruptCheckCounter;; (JSIdentifier) interruptCheckCounter						local.get $interruptCheckCounter						return);; (JSProperty) property: setTheInterruptCheckCounter ->...;; (FunctionExpression) function(int) { 	this.interruptCheckCoun...(func $setTheInterruptCheckCounter						(local $int i32)						(local $temp i32)						;; (ExpressionStatement) this.interruptCheckCounter = int;; (AssignmentExpression) this.interruptCheckCounter = int;; (JSIdentifier) int						local.get $int						local.set $interruptCheckCounter);; (JSProperty) property: contextTempFrameStart -> funct...;; (FunctionExpression) function() { 	return Squeak.Context_temp...(func $contextTempFrameStart						(local $temp i32)						;; (ReturnStatement) return Squeak.Context_tempFrameStart;; (StaticMemberExpression) Squeak.Context_tempFrameStart;; (JSIdentifier) Context_tempFrameStart						local.get $Context_tempFrameStart						return);; (JSProperty) property: associationValue -> function()...;; (FunctionExpression) function() { 	return Squeak.Assn_value }(func $associationValue						(local $temp i32)						;; (ReturnStatement) return Squeak.Assn_value;; (StaticMemberExpression) Squeak.Assn_value;; (JSIdentifier) Assn_value						local.get $Assn_value						return);; (JSProperty) property: theReceiver -> function() { 	r...;; (FunctionExpression) function() { 	return this.uuidForObject(...(func $theReceiver						(local $temp i32)						;; (ReturnStatement) return this.uuidForObject(this.receiver);; (CallExpression) this.uuidForObject(this.receiver)						local.get $this;; (StaticMemberExpression) this.receiver;; (JSIdentifier) receiver						local.get $receiver						call $uuidForObject						return);; (JSProperty) property: theTrueObj -> function() { 	re...;; (FunctionExpression) function() { 	return this.uuidForObject(...(func $theTrueObj						(local $temp i32)						;; (ReturnStatement) return this.uuidForObject(this.trueObj);; (CallExpression) this.uuidForObject(this.trueObj)						local.get $this;; (StaticMemberExpression) this.trueObj;; (JSIdentifier) trueObj						local.get $trueObj						call $uuidForObject						return);; (JSProperty) property: theFalseObj -> function() { 	r...;; (FunctionExpression) function() { 	return this.uuidForObject(...(func $theFalseObj						(local $temp i32)						;; (ReturnStatement) return this.uuidForObject(this.falseObj);; (CallExpression) this.uuidForObject(this.falseObj)						local.get $this;; (StaticMemberExpression) this.falseObj;; (JSIdentifier) falseObj						local.get $falseObj						call $uuidForObject						return);; (JSProperty) property: theNilObj -> function() { 	ret...;; (FunctionExpression) function() { 	return this.uuidForObject(...(func $theNilObj						(local $temp i32)						;; (ReturnStatement) return this.uuidForObject(this.nilObj);; (CallExpression) this.uuidForObject(this.nilObj)						local.get $this;; (StaticMemberExpression) this.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $uuidForObject						return);; (JSProperty) property: theActiveContext -> function()...;; (FunctionExpression) function() { 	return this.uuidForObject(...(func $theActiveContext						(local $temp i32)						;; (ReturnStatement) return this.uuidForObject(this.activeCon...;; (CallExpression) this.uuidForObject(this.activeContext)						local.get $this;; (StaticMemberExpression) this.activeContext;; (JSIdentifier) activeContext						local.get $activeContext						call $uuidForObject						return);; (JSProperty) property: theHomeContext -> function() {...;; (FunctionExpression) function() { 	return this.uuidForObject(...(func $theHomeContext						(local $temp i32)						;; (ReturnStatement) return this.uuidForObject(this.homeConte...;; (CallExpression) this.uuidForObject(this.homeContext)						local.get $this;; (StaticMemberExpression) this.homeContext;; (JSIdentifier) homeContext						local.get $homeContext						call $uuidForObject						return);; (JSProperty) property: blockContextCaller -> function...;; (FunctionExpression) function() { 	return Squeak.BlockContext...(func $blockContextCaller						(local $temp i32)						;; (ReturnStatement) return Squeak.BlockContext_caller;; (StaticMemberExpression) Squeak.BlockContext_caller;; (JSIdentifier) BlockContext_caller						local.get $BlockContext_caller						return);; (JSProperty) property: methodGetLiteral -> function(i...;; (FunctionExpression) function(index) { 	return this.uuidForOb...(func $methodGetLiteral						(local $temp i32)						(local $index i32)						;; (ReturnStatement) return this.uuidForObject(this.method.me...;; (CallExpression) this.uuidForObject(this.method.methodGet...						local.get $this;; (CallExpression) this.method.methodGetLiteral(index)						local.get $method;; (JSIdentifier) index						local.get $index						call $methodGetLiteral						call $uuidForObject						return);; (JSProperty) property: methodGetSelector -> function(...;; (FunctionExpression) function(index) { 	return this.uuidForOb...(func $methodGetSelector						(local $temp i32)						(local $index i32)						;; (ReturnStatement) return this.uuidForObject(this.method.me...;; (CallExpression) this.uuidForObject(this.method.methodGet...						local.get $this;; (CallExpression) this.method.methodGetSelector(index)						local.get $method;; (JSIdentifier) index						local.get $index						call $methodGetSelector						call $uuidForObject						return);; (JSProperty) property: loadImageState -> function() {...;; (FunctionExpression) function() { 	this.specialObjects = this...(func $loadImageState						(local $temp i32)						;; (ExpressionStatement) this.specialObjects = this.image.special...;; (AssignmentExpression) this.specialObjects = this.image.special...;; (StaticMemberExpression) this.image.specialObjectsArray.pointers;; (JSIdentifier) pointers						local.get $pointers						local.set $specialObjects;; (ExpressionStatement) this.specialSelectors = this.specialObje...;; (AssignmentExpression) this.specialSelectors = this.specialObje...;; (StaticMemberExpression) this.specialObjects[Squeak.splOb_Special...;; (JSIdentifier) pointers						local.get $pointers						local.set $specialSelectors;; (ExpressionStatement) this.nilObj = this.specialObjects[Squeak...;; (AssignmentExpression) this.nilObj = this.specialObjects[Squeak...;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_NilObje...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_NilObject;; (JSIdentifier) splOb_NilObject						local.get $splOb_NilObject						i32.const 4						i32.mul						i32.add						local.set $nilObj;; (ExpressionStatement) this.falseObj = this.specialObjects[Sque...;; (AssignmentExpression) this.falseObj = this.specialObjects[Sque...;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_FalseOb...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_FalseObject;; (JSIdentifier) splOb_FalseObject						local.get $splOb_FalseObject						i32.const 4						i32.mul						i32.add						local.set $falseObj;; (ExpressionStatement) this.trueObj = this.specialObjects[Squea...;; (AssignmentExpression) this.trueObj = this.specialObjects[Squea...;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_TrueObj...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_TrueObject;; (JSIdentifier) splOb_TrueObject						local.get $splOb_TrueObject						i32.const 4						i32.mul						i32.add						local.set $trueObj;; (ExpressionStatement) this.hasClosures = this.image.hasClosure...;; (AssignmentExpression) this.hasClosures = this.image.hasClosure...;; (StaticMemberExpression) this.image.hasClosures;; (JSIdentifier) hasClosures						local.get $hasClosures						local.set $hasClosures;; (ExpressionStatement) this.globals = this.findGlobals();; (AssignmentExpression) this.globals = this.findGlobals();; (CallExpression) this.findGlobals()						local.get $this						call $findGlobals						local.set $globals						;; unwritable: (IfStatement) if (!this.hasClosures && !this.findMetho;; (IfStatement) if (this.image.version == 6501) {this.pr...;; (BinaryExpression) this.image.version == 6501;; (StaticMemberExpression) this.image.version;; (JSIdentifier) version						local.get $version;; (JSLiteral) 6501						i32.const 6501						i32.eq						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.primHandler.reverseDisplay = true;; (AssignmentExpression) this.primHandler.reverseDisplay = true;; (JSLiteral) true						i32.const 1						local.set $reverseDisplay)));; (JSProperty) property: initVMState -> function() { 	t...;; (FunctionExpression) function() { 	this.byteCodeCount = 0 thi...(func $initVMState						(local $temp i32)						(local $i i32)						;; (ExpressionStatement) this.byteCodeCount = 0;; (AssignmentExpression) this.byteCodeCount = 0;; (JSLiteral) 0						i32.const 0						local.set $byteCodeCount;; (ExpressionStatement) this.sendCount = 0;; (AssignmentExpression) this.sendCount = 0;; (JSLiteral) 0						i32.const 0						local.set $sendCount;; (ExpressionStatement) this.interruptCheckCounter = 0;; (AssignmentExpression) this.interruptCheckCounter = 0;; (JSLiteral) 0						i32.const 0						local.set $interruptCheckCounter;; (ExpressionStatement) this.interruptCheckCounterFeedBackReset ...;; (AssignmentExpression) this.interruptCheckCounterFeedBackReset ...;; (JSLiteral) 1000						i32.const 1000						local.set $interruptCheckCounterFeedBackReset;; (ExpressionStatement) this.interruptChecksEveryNms = 3;; (AssignmentExpression) this.interruptChecksEveryNms = 3;; (JSLiteral) 3						i32.const 3						local.set $interruptChecksEveryNms;; (ExpressionStatement) this.nextPollTick = 0;; (AssignmentExpression) this.nextPollTick = 0;; (JSLiteral) 0						i32.const 0						local.set $nextPollTick;; (ExpressionStatement) this.nextWakeupTick = 0;; (AssignmentExpression) this.nextWakeupTick = 0;; (JSLiteral) 0						i32.const 0						local.set $nextWakeupTick;; (ExpressionStatement) this.lastTick = 0;; (AssignmentExpression) this.lastTick = 0;; (JSLiteral) 0						i32.const 0						local.set $lastTick;; (ExpressionStatement) this.interruptKeycode = 2094;; (AssignmentExpression) this.interruptKeycode = 2094;; (JSLiteral) 2094						i32.const 2094						local.set $interruptKeycode;; (ExpressionStatement) this.interruptPending = false;; (AssignmentExpression) this.interruptPending = false;; (JSLiteral) false						i32.const 0						local.set $interruptPending;; (ExpressionStatement) this.pendingFinalizationSignals = 0;; (AssignmentExpression) this.pendingFinalizationSignals = 0;; (JSLiteral) 0						i32.const 0						local.set $pendingFinalizationSignals;; (ExpressionStatement) this.freeContexts = this.nilObj;; (AssignmentExpression) this.freeContexts = this.nilObj;; (StaticMemberExpression) this.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						local.set $freeContexts;; (ExpressionStatement) this.freeLargeContexts = this.nilObj;; (AssignmentExpression) this.freeLargeContexts = this.nilObj;; (StaticMemberExpression) this.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						local.set $freeLargeContexts;; (ExpressionStatement) this.reclaimableContextCount = 0;; (AssignmentExpression) this.reclaimableContextCount = 0;; (JSLiteral) 0						i32.const 0						local.set $reclaimableContextCount;; (ExpressionStatement) this.nRecycledContexts = 0;; (AssignmentExpression) this.nRecycledContexts = 0;; (JSLiteral) 0						i32.const 0						local.set $nRecycledContexts;; (ExpressionStatement) this.nAllocatedContexts = 0;; (AssignmentExpression) this.nAllocatedContexts = 0;; (JSLiteral) 0						i32.const 0						local.set $nAllocatedContexts;; (ExpressionStatement) this.methodCacheSize = 1024;; (AssignmentExpression) this.methodCacheSize = 1024;; (JSLiteral) 1024						i32.const 1024						local.set $methodCacheSize;; (ExpressionStatement) this.methodCacheMask = this.methodCacheS...;; (AssignmentExpression) this.methodCacheMask = this.methodCacheS...;; (BinaryExpression) this.methodCacheSize - 1;; (StaticMemberExpression) this.methodCacheSize;; (JSIdentifier) methodCacheSize						local.get $methodCacheSize;; (JSLiteral) 1						i32.const 1						i32.sub						local.set $methodCacheMask;; (ExpressionStatement) this.methodCacheRandomish = 0;; (AssignmentExpression) this.methodCacheRandomish = 0;; (JSLiteral) 0						i32.const 0						local.set $methodCacheRandomish						;; unwritable: (ExpressionStatement) this.methodCache = [];; (ForStatement) for (var i = 0; i < this.methodCacheSize...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) this.methodCache[i] = {property: lkupCla...;; (AssignmentExpression) this.methodCache[i] = {property: lkupCla...						local.get $this;; (JSIdentifier) i						local.get $i;; (ObjectExpression) {property: lkupClass -> nil, property: s...						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < this.methodCacheSize;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) this.methodCacheSize;; (JSIdentifier) methodCacheSize						local.get $methodCacheSize						i32.lt_u						i32.const 0						br_if $loop_1);; (ExpressionStatement) this.breakOutOfInterpreter = false;; (AssignmentExpression) this.breakOutOfInterpreter = false;; (JSLiteral) false						i32.const 0						local.set $breakOutOfInterpreter;; (ExpressionStatement) this.breakOutTick = 0;; (AssignmentExpression) this.breakOutTick = 0;; (JSLiteral) 0						i32.const 0						local.set $breakOutTick;; (ExpressionStatement) this.breakOnMethod = nil;; (AssignmentExpression) this.breakOnMethod = nil;; (JSLiteral) nil						i32.const 0						local.set $breakOnMethod;; (ExpressionStatement) this.breakOnNewMethod = false;; (AssignmentExpression) this.breakOnNewMethod = false;; (JSLiteral) false						i32.const 0						local.set $breakOnNewMethod;; (ExpressionStatement) this.breakOnContextChanged = false;; (AssignmentExpression) this.breakOnContextChanged = false;; (JSLiteral) false						i32.const 0						local.set $breakOnContextChanged;; (ExpressionStatement) this.breakOnContextReturned = nil;; (AssignmentExpression) this.breakOnContextReturned = nil;; (JSLiteral) nil						i32.const 0						local.set $breakOnContextReturned;; (ExpressionStatement) this.messages = {};; (AssignmentExpression) this.messages = {};; (ObjectExpression) {}						local.set $messages						;; unwritable: (ExpressionStatement) this.startupTime = Date.now());; (JSProperty) property: loadInitialContext -> function...;; (FunctionExpression) function() { 	var schedAssn = this.speci...(func $loadInitialContext						(local $proc i32)						(local $sched i32)						(local $temp i32)						(local $schedAssn i32)						;; (ExpressionStatement) this.activeContext = proc.pointers[Squea...;; (AssignmentExpression) this.activeContext = proc.pointers[Squea...;; (ComputedMemberExpression) proc.pointers[Squeak.Proc_suspendedConte...;; (StaticMemberExpression) proc.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Proc_suspendedContext;; (JSIdentifier) Proc_suspendedContext						local.get $Proc_suspendedContext						i32.const 4						i32.mul						i32.add						local.set $activeContext;; (ExpressionStatement) this.activeContext.dirty = true;; (AssignmentExpression) this.activeContext.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty;; (ExpressionStatement) this.fetchContextRegisters(this.activeCo...;; (CallExpression) this.fetchContextRegisters(this.activeCo...						local.get $this;; (StaticMemberExpression) this.activeContext;; (JSIdentifier) activeContext						local.get $activeContext						call $fetchContextRegisters;; (ExpressionStatement) this.reclaimableContextCount = 0;; (AssignmentExpression) this.reclaimableContextCount = 0;; (JSLiteral) 0						i32.const 0						local.set $reclaimableContextCount);; (JSProperty) property: findGlobals -> function() { 	v...;; (FunctionExpression) function() { 	var smalltalk = this.speci...(func $findGlobals						(local $globalsClass i32)						(local $smalltalk i32)						(local $globals i32)						(local $temp i32)						(local $smalltalkClass i32)												;; unwritable: (IfStatement) if (smalltalkClass === 'Association') {s						;; unwritable: (IfStatement) if (smalltalkClass === 'SystemDictionary						;; unwritable: (IfStatement) if (smalltalkClass === 'SmalltalkImage')						;; unwritable: (ExpressionStatement) console.warn('cannot find global dict')						;; unwritable: (ReturnStatement) return []);; (JSProperty) property: initCompiler -> function() { 	...;; (FunctionExpression) function() { 	if (!Squeak.Compiler) {ret...(func $initCompiler						(local $kObjPerSec i32)						(local $temp i32)												;; unwritable: (IfStatement) if (!Squeak.Compiler) {return console.wa;; (TryStatement) an active TryStatement with properties: ...						;; unwritable: (IfStatement) if (kObjPerSec < 10) {return console.war;; (TryStatement) an active TryStatement with properties: ...);; (JSProperty) property: hackImage -> function() { 	var...;; (FunctionExpression) function() { 	var returnSelf = 256, retu...(func $hackImage						(local $returnNil i32)						(local $returnTrue i32)						(local $returnSelf i32)						(local $temp i32)						(local $returnFalse i32)												;; unwritable: (ExpressionStatement) [].forEach(function(each) { 	var m = thi						;; unwritable: (IfStatement) if (this.findMethod('PharoClassInstaller);; (JSProperty) property: interpretOne -> function(singl...;; (FunctionExpression) function(singleStep) { 	if (this.method....(func $interpretOne						(local $singleStep i32)						(local $b2 i32)						(local $b i32)						(local $Squeak i32)						(local $temp i32)						;; (IfStatement) if (this.method.compiled) {if (singleSte...;; (StaticMemberExpression) this.method.compiled;; (JSIdentifier) compiled						local.get $compiled						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (singleStep) {if (!this.compiler.enab...;; (IfStatement) if (singleStep) {if (!this.compiler.enab...;; (JSIdentifier) singleStep						local.get $singleStep						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (!this.compiler.enableSingleStepping(...;; (IfStatement) if (!this.compiler.enableSingleStepping(...;; (UnaryExpression) !this.compiler.enableSingleStepping(this...;; (CallExpression) this.compiler.enableSingleStepping(this....						local.get $compiler;; (StaticMemberExpression) this.method;; (JSIdentifier) method						local.get $method						call $enableSingleStepping						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.method.compiled = nil return this.i...;; (ExpressionStatement) this.method.compiled = nil;; (AssignmentExpression) this.method.compiled = nil;; (JSLiteral) nil						i32.const 0						local.set $compiled;; (ReturnStatement) return this.interpretOne(singleStep);; (CallExpression) this.interpretOne(singleStep)						local.get $this;; (JSIdentifier) singleStep						local.get $singleStep						call $interpretOne						return));; (ExpressionStatement) this.breakNow();; (CallExpression) this.breakNow()						local.get $this						call $breakNow));; (ExpressionStatement) this.method.compiled(this);; (CallExpression) this.method.compiled(this)						local.get $method;; (ThisExpression) this						call $compiled;; (ReturnStatement) return 						return));; (ExpressionStatement) this.byteCodeCount++;; (UpdateExpression) this.byteCodeCount++;; (StaticMemberExpression) this.byteCodeCount;; (JSIdentifier) byteCodeCount						local.get $byteCodeCount						i32.const 1						i32.add;; (ExpressionStatement) b = this.nextByte();; (AssignmentExpression) b = this.nextByte();; (CallExpression) this.nextByte()						local.get $this						call $nextByte						local.set $b						;; unwritable: (IfStatement) if (typeof b == 'undefined') {an active ;; (IfStatement) if (b < 128) {switch (b) { case 0: case ...;; (BinaryExpression) b < 128;; (JSIdentifier) b						local.get $b;; (JSLiteral) 128						i32.const 128						i32.lt_u						i32.const 0						i32.ne						(if (then;; (SwitchStatement) switch (b) { case 0: case 1: case 2: cas...b						local.set $temp;; (SwitchCase)  case 0:						local.get $temp;; (JSLiteral) 0						i32.const 0						i32.eq						(if (then 						));; (SwitchCase)  case 1:						local.get $temp;; (JSLiteral) 1						i32.const 1						i32.eq						(if (then 						));; (SwitchCase)  case 2:						local.get $temp;; (JSLiteral) 2						i32.const 2						i32.eq						(if (then 						));; (SwitchCase)  case 3:						local.get $temp;; (JSLiteral) 3						i32.const 3						i32.eq						(if (then 						));; (SwitchCase)  case 4:						local.get $temp;; (JSLiteral) 4						i32.const 4						i32.eq						(if (then 						));; (SwitchCase)  case 5:						local.get $temp;; (JSLiteral) 5						i32.const 5						i32.eq						(if (then 						));; (SwitchCase)  case 6:						local.get $temp;; (JSLiteral) 6						i32.const 6						i32.eq						(if (then 						));; (SwitchCase)  case 7:						local.get $temp;; (JSLiteral) 7						i32.const 7						i32.eq						(if (then 						));; (SwitchCase)  case 8:						local.get $temp;; (JSLiteral) 8						i32.const 8						i32.eq						(if (then 						));; (SwitchCase)  case 9:						local.get $temp;; (JSLiteral) 9						i32.const 9						i32.eq						(if (then 						));; (SwitchCase)  case 10:						local.get $temp;; (JSLiteral) 10						i32.const 10						i32.eq						(if (then 						));; (SwitchCase)  case 11:						local.get $temp;; (JSLiteral) 11						i32.const 11						i32.eq						(if (then 						));; (SwitchCase)  case 12:						local.get $temp;; (JSLiteral) 12						i32.const 12						i32.eq						(if (then 						));; (SwitchCase)  case 13:						local.get $temp;; (JSLiteral) 13						i32.const 13						i32.eq						(if (then 						));; (SwitchCase)  case 14:						local.get $temp;; (JSLiteral) 14						i32.const 14						i32.eq						(if (then 						));; (SwitchCase)  case 15: this.push(this.receiver.pointe...						local.get $temp;; (JSLiteral) 15						i32.const 15						i32.eq						(if (then ;; (ExpressionStatement) this.push(this.receiver.pointers[b & 15]...;; (CallExpression) this.push(this.receiver.pointers[b & 15]...						local.get $this;; (ComputedMemberExpression) this.receiver.pointers[b & 15];; (StaticMemberExpression) this.receiver.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						i32.const 4						i32.mul						i32.add						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 16:						local.get $temp;; (JSLiteral) 16						i32.const 16						i32.eq						(if (then 						));; (SwitchCase)  case 17:						local.get $temp;; (JSLiteral) 17						i32.const 17						i32.eq						(if (then 						));; (SwitchCase)  case 18:						local.get $temp;; (JSLiteral) 18						i32.const 18						i32.eq						(if (then 						));; (SwitchCase)  case 19:						local.get $temp;; (JSLiteral) 19						i32.const 19						i32.eq						(if (then 						));; (SwitchCase)  case 20:						local.get $temp;; (JSLiteral) 20						i32.const 20						i32.eq						(if (then 						));; (SwitchCase)  case 21:						local.get $temp;; (JSLiteral) 21						i32.const 21						i32.eq						(if (then 						));; (SwitchCase)  case 22:						local.get $temp;; (JSLiteral) 22						i32.const 22						i32.eq						(if (then 						));; (SwitchCase)  case 23:						local.get $temp;; (JSLiteral) 23						i32.const 23						i32.eq						(if (then 						));; (SwitchCase)  case 24:						local.get $temp;; (JSLiteral) 24						i32.const 24						i32.eq						(if (then 						));; (SwitchCase)  case 25:						local.get $temp;; (JSLiteral) 25						i32.const 25						i32.eq						(if (then 						));; (SwitchCase)  case 26:						local.get $temp;; (JSLiteral) 26						i32.const 26						i32.eq						(if (then 						));; (SwitchCase)  case 27:						local.get $temp;; (JSLiteral) 27						i32.const 27						i32.eq						(if (then 						));; (SwitchCase)  case 28:						local.get $temp;; (JSLiteral) 28						i32.const 28						i32.eq						(if (then 						));; (SwitchCase)  case 29:						local.get $temp;; (JSLiteral) 29						i32.const 29						i32.eq						(if (then 						));; (SwitchCase)  case 30:						local.get $temp;; (JSLiteral) 30						i32.const 30						i32.eq						(if (then 						));; (SwitchCase)  case 31: this.push(this.homeContext.poi...						local.get $temp;; (JSLiteral) 31						i32.const 31						i32.eq						(if (then ;; (ExpressionStatement) this.push(this.homeContext.pointers[Sque...;; (CallExpression) this.push(this.homeContext.pointers[Sque...						local.get $this;; (ComputedMemberExpression) this.homeContext.pointers[Squeak.Context...;; (StaticMemberExpression) this.homeContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) Squeak.Context_tempFrameStart + b & 15;; (StaticMemberExpression) Squeak.Context_tempFrameStart;; (JSIdentifier) Context_tempFrameStart						local.get $Context_tempFrameStart;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						i32.add						i32.const 4						i32.mul						i32.add						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 32:						local.get $temp;; (JSLiteral) 32						i32.const 32						i32.eq						(if (then 						));; (SwitchCase)  case 33:						local.get $temp;; (JSLiteral) 33						i32.const 33						i32.eq						(if (then 						));; (SwitchCase)  case 34:						local.get $temp;; (JSLiteral) 34						i32.const 34						i32.eq						(if (then 						));; (SwitchCase)  case 35:						local.get $temp;; (JSLiteral) 35						i32.const 35						i32.eq						(if (then 						));; (SwitchCase)  case 36:						local.get $temp;; (JSLiteral) 36						i32.const 36						i32.eq						(if (then 						));; (SwitchCase)  case 37:						local.get $temp;; (JSLiteral) 37						i32.const 37						i32.eq						(if (then 						));; (SwitchCase)  case 38:						local.get $temp;; (JSLiteral) 38						i32.const 38						i32.eq						(if (then 						));; (SwitchCase)  case 39:						local.get $temp;; (JSLiteral) 39						i32.const 39						i32.eq						(if (then 						));; (SwitchCase)  case 40:						local.get $temp;; (JSLiteral) 40						i32.const 40						i32.eq						(if (then 						));; (SwitchCase)  case 41:						local.get $temp;; (JSLiteral) 41						i32.const 41						i32.eq						(if (then 						));; (SwitchCase)  case 42:						local.get $temp;; (JSLiteral) 42						i32.const 42						i32.eq						(if (then 						));; (SwitchCase)  case 43:						local.get $temp;; (JSLiteral) 43						i32.const 43						i32.eq						(if (then 						));; (SwitchCase)  case 44:						local.get $temp;; (JSLiteral) 44						i32.const 44						i32.eq						(if (then 						));; (SwitchCase)  case 45:						local.get $temp;; (JSLiteral) 45						i32.const 45						i32.eq						(if (then 						));; (SwitchCase)  case 46:						local.get $temp;; (JSLiteral) 46						i32.const 46						i32.eq						(if (then 						));; (SwitchCase)  case 47:						local.get $temp;; (JSLiteral) 47						i32.const 47						i32.eq						(if (then 						));; (SwitchCase)  case 48:						local.get $temp;; (JSLiteral) 48						i32.const 48						i32.eq						(if (then 						));; (SwitchCase)  case 49:						local.get $temp;; (JSLiteral) 49						i32.const 49						i32.eq						(if (then 						));; (SwitchCase)  case 50:						local.get $temp;; (JSLiteral) 50						i32.const 50						i32.eq						(if (then 						));; (SwitchCase)  case 51:						local.get $temp;; (JSLiteral) 51						i32.const 51						i32.eq						(if (then 						));; (SwitchCase)  case 52:						local.get $temp;; (JSLiteral) 52						i32.const 52						i32.eq						(if (then 						));; (SwitchCase)  case 53:						local.get $temp;; (JSLiteral) 53						i32.const 53						i32.eq						(if (then 						));; (SwitchCase)  case 54:						local.get $temp;; (JSLiteral) 54						i32.const 54						i32.eq						(if (then 						));; (SwitchCase)  case 55:						local.get $temp;; (JSLiteral) 55						i32.const 55						i32.eq						(if (then 						));; (SwitchCase)  case 56:						local.get $temp;; (JSLiteral) 56						i32.const 56						i32.eq						(if (then 						));; (SwitchCase)  case 57:						local.get $temp;; (JSLiteral) 57						i32.const 57						i32.eq						(if (then 						));; (SwitchCase)  case 58:						local.get $temp;; (JSLiteral) 58						i32.const 58						i32.eq						(if (then 						));; (SwitchCase)  case 59:						local.get $temp;; (JSLiteral) 59						i32.const 59						i32.eq						(if (then 						));; (SwitchCase)  case 60:						local.get $temp;; (JSLiteral) 60						i32.const 60						i32.eq						(if (then 						));; (SwitchCase)  case 61:						local.get $temp;; (JSLiteral) 61						i32.const 61						i32.eq						(if (then 						));; (SwitchCase)  case 62:						local.get $temp;; (JSLiteral) 62						i32.const 62						i32.eq						(if (then 						));; (SwitchCase)  case 63: this.push(this.method.methodGe...						local.get $temp;; (JSLiteral) 63						i32.const 63						i32.eq						(if (then ;; (ExpressionStatement) this.push(this.method.methodGetLiteral(b...;; (CallExpression) this.push(this.method.methodGetLiteral(b...						local.get $this;; (CallExpression) this.method.methodGetLiteral(b & 31)						local.get $method;; (BinaryExpression) b & 31;; (JSIdentifier) b						local.get $b;; (JSLiteral) 31						i32.const 31						i32.and						call $methodGetLiteral						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 64:						local.get $temp;; (JSLiteral) 64						i32.const 64						i32.eq						(if (then 						));; (SwitchCase)  case 65:						local.get $temp;; (JSLiteral) 65						i32.const 65						i32.eq						(if (then 						));; (SwitchCase)  case 66:						local.get $temp;; (JSLiteral) 66						i32.const 66						i32.eq						(if (then 						));; (SwitchCase)  case 67:						local.get $temp;; (JSLiteral) 67						i32.const 67						i32.eq						(if (then 						));; (SwitchCase)  case 68:						local.get $temp;; (JSLiteral) 68						i32.const 68						i32.eq						(if (then 						));; (SwitchCase)  case 69:						local.get $temp;; (JSLiteral) 69						i32.const 69						i32.eq						(if (then 						));; (SwitchCase)  case 70:						local.get $temp;; (JSLiteral) 70						i32.const 70						i32.eq						(if (then 						));; (SwitchCase)  case 71:						local.get $temp;; (JSLiteral) 71						i32.const 71						i32.eq						(if (then 						));; (SwitchCase)  case 72:						local.get $temp;; (JSLiteral) 72						i32.const 72						i32.eq						(if (then 						));; (SwitchCase)  case 73:						local.get $temp;; (JSLiteral) 73						i32.const 73						i32.eq						(if (then 						));; (SwitchCase)  case 74:						local.get $temp;; (JSLiteral) 74						i32.const 74						i32.eq						(if (then 						));; (SwitchCase)  case 75:						local.get $temp;; (JSLiteral) 75						i32.const 75						i32.eq						(if (then 						));; (SwitchCase)  case 76:						local.get $temp;; (JSLiteral) 76						i32.const 76						i32.eq						(if (then 						));; (SwitchCase)  case 77:						local.get $temp;; (JSLiteral) 77						i32.const 77						i32.eq						(if (then 						));; (SwitchCase)  case 78:						local.get $temp;; (JSLiteral) 78						i32.const 78						i32.eq						(if (then 						));; (SwitchCase)  case 79:						local.get $temp;; (JSLiteral) 79						i32.const 79						i32.eq						(if (then 						));; (SwitchCase)  case 80:						local.get $temp;; (JSLiteral) 80						i32.const 80						i32.eq						(if (then 						));; (SwitchCase)  case 81:						local.get $temp;; (JSLiteral) 81						i32.const 81						i32.eq						(if (then 						));; (SwitchCase)  case 82:						local.get $temp;; (JSLiteral) 82						i32.const 82						i32.eq						(if (then 						));; (SwitchCase)  case 83:						local.get $temp;; (JSLiteral) 83						i32.const 83						i32.eq						(if (then 						));; (SwitchCase)  case 84:						local.get $temp;; (JSLiteral) 84						i32.const 84						i32.eq						(if (then 						));; (SwitchCase)  case 85:						local.get $temp;; (JSLiteral) 85						i32.const 85						i32.eq						(if (then 						));; (SwitchCase)  case 86:						local.get $temp;; (JSLiteral) 86						i32.const 86						i32.eq						(if (then 						));; (SwitchCase)  case 87:						local.get $temp;; (JSLiteral) 87						i32.const 87						i32.eq						(if (then 						));; (SwitchCase)  case 88:						local.get $temp;; (JSLiteral) 88						i32.const 88						i32.eq						(if (then 						));; (SwitchCase)  case 89:						local.get $temp;; (JSLiteral) 89						i32.const 89						i32.eq						(if (then 						));; (SwitchCase)  case 90:						local.get $temp;; (JSLiteral) 90						i32.const 90						i32.eq						(if (then 						));; (SwitchCase)  case 91:						local.get $temp;; (JSLiteral) 91						i32.const 91						i32.eq						(if (then 						));; (SwitchCase)  case 92:						local.get $temp;; (JSLiteral) 92						i32.const 92						i32.eq						(if (then 						));; (SwitchCase)  case 93:						local.get $temp;; (JSLiteral) 93						i32.const 93						i32.eq						(if (then 						));; (SwitchCase)  case 94:						local.get $temp;; (JSLiteral) 94						i32.const 94						i32.eq						(if (then 						));; (SwitchCase)  case 95: this.push(this.method.methodGe...						local.get $temp;; (JSLiteral) 95						i32.const 95						i32.eq						(if (then ;; (ExpressionStatement) this.push(this.method.methodGetLiteral(b...;; (CallExpression) this.push(this.method.methodGetLiteral(b...						local.get $this;; (ComputedMemberExpression) this.method.methodGetLiteral(b & 31).poi...;; (StaticMemberExpression) this.method.methodGetLiteral(b & 31).poi...;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Assn_value;; (JSIdentifier) Assn_value						local.get $Assn_value						i32.const 4						i32.mul						i32.add						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 96:						local.get $temp;; (JSLiteral) 96						i32.const 96						i32.eq						(if (then 						));; (SwitchCase)  case 97:						local.get $temp;; (JSLiteral) 97						i32.const 97						i32.eq						(if (then 						));; (SwitchCase)  case 98:						local.get $temp;; (JSLiteral) 98						i32.const 98						i32.eq						(if (then 						));; (SwitchCase)  case 99:						local.get $temp;; (JSLiteral) 99						i32.const 99						i32.eq						(if (then 						));; (SwitchCase)  case 100:						local.get $temp;; (JSLiteral) 100						i32.const 100						i32.eq						(if (then 						));; (SwitchCase)  case 101:						local.get $temp;; (JSLiteral) 101						i32.const 101						i32.eq						(if (then 						));; (SwitchCase)  case 102:						local.get $temp;; (JSLiteral) 102						i32.const 102						i32.eq						(if (then 						));; (SwitchCase)  case 103: this.receiver.dirty = true th...						local.get $temp;; (JSLiteral) 103						i32.const 103						i32.eq						(if (then ;; (ExpressionStatement) this.receiver.dirty = true;; (AssignmentExpression) this.receiver.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty;; (ExpressionStatement) this.receiver.pointers[b & 7] = this.pop...;; (AssignmentExpression) this.receiver.pointers[b & 7] = this.pop...						local.get $this.receiver;; (BinaryExpression) b & 7;; (JSIdentifier) b						local.get $b;; (JSLiteral) 7						i32.const 7						i32.and;; (CallExpression) this.pop()						local.get $this						call $pop						call $atPut;; (ReturnStatement) return 						return						));; (SwitchCase)  case 104:						local.get $temp;; (JSLiteral) 104						i32.const 104						i32.eq						(if (then 						));; (SwitchCase)  case 105:						local.get $temp;; (JSLiteral) 105						i32.const 105						i32.eq						(if (then 						));; (SwitchCase)  case 106:						local.get $temp;; (JSLiteral) 106						i32.const 106						i32.eq						(if (then 						));; (SwitchCase)  case 107:						local.get $temp;; (JSLiteral) 107						i32.const 107						i32.eq						(if (then 						));; (SwitchCase)  case 108:						local.get $temp;; (JSLiteral) 108						i32.const 108						i32.eq						(if (then 						));; (SwitchCase)  case 109:						local.get $temp;; (JSLiteral) 109						i32.const 109						i32.eq						(if (then 						));; (SwitchCase)  case 110:						local.get $temp;; (JSLiteral) 110						i32.const 110						i32.eq						(if (then 						));; (SwitchCase)  case 111: this.homeContext.pointers[Squ...						local.get $temp;; (JSLiteral) 111						i32.const 111						i32.eq						(if (then ;; (ExpressionStatement) this.homeContext.pointers[Squeak.Context...;; (AssignmentExpression) this.homeContext.pointers[Squeak.Context...						local.get $this.homeContext;; (BinaryExpression) Squeak.Context_tempFrameStart + b & 7;; (StaticMemberExpression) Squeak.Context_tempFrameStart;; (JSIdentifier) Context_tempFrameStart						local.get $Context_tempFrameStart;; (BinaryExpression) b & 7;; (JSIdentifier) b						local.get $b;; (JSLiteral) 7						i32.const 7						i32.and						i32.add;; (CallExpression) this.pop()						local.get $this						call $pop						call $atPut;; (ReturnStatement) return 						return						));; (SwitchCase)  case 112: this.push(this.receiver) retu...						local.get $temp;; (JSLiteral) 112						i32.const 112						i32.eq						(if (then ;; (ExpressionStatement) this.push(this.receiver);; (CallExpression) this.push(this.receiver)						local.get $this;; (StaticMemberExpression) this.receiver;; (JSIdentifier) receiver						local.get $receiver						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 113: this.push(this.trueObj) retur...						local.get $temp;; (JSLiteral) 113						i32.const 113						i32.eq						(if (then ;; (ExpressionStatement) this.push(this.trueObj);; (CallExpression) this.push(this.trueObj)						local.get $this;; (StaticMemberExpression) this.trueObj;; (JSIdentifier) trueObj						local.get $trueObj						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 114: this.push(this.falseObj) retu...						local.get $temp;; (JSLiteral) 114						i32.const 114						i32.eq						(if (then ;; (ExpressionStatement) this.push(this.falseObj);; (CallExpression) this.push(this.falseObj)						local.get $this;; (StaticMemberExpression) this.falseObj;; (JSIdentifier) falseObj						local.get $falseObj						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 115: this.push(this.nilObj) return...						local.get $temp;; (JSLiteral) 115						i32.const 115						i32.eq						(if (then ;; (ExpressionStatement) this.push(this.nilObj);; (CallExpression) this.push(this.nilObj)						local.get $this;; (StaticMemberExpression) this.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 116: this.push(-1) return 						local.get $temp;; (JSLiteral) 116						i32.const 116						i32.eq						(if (then ;; (ExpressionStatement) this.push(-1);; (CallExpression) this.push(-1)						local.get $this;; (UnaryExpression) -1;; (JSLiteral) 1						i32.const 1						local.set $temp						i32.const 0						local.get $temp						i32.sub						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 117: this.push(0) return 						local.get $temp;; (JSLiteral) 117						i32.const 117						i32.eq						(if (then ;; (ExpressionStatement) this.push(0);; (CallExpression) this.push(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 118: this.push(1) return 						local.get $temp;; (JSLiteral) 118						i32.const 118						i32.eq						(if (then ;; (ExpressionStatement) this.push(1);; (CallExpression) this.push(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 119: this.push(2) return 						local.get $temp;; (JSLiteral) 119						i32.const 119						i32.eq						(if (then ;; (ExpressionStatement) this.push(2);; (CallExpression) this.push(2)						local.get $this;; (JSLiteral) 2						i32.const 2						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 120: this.doReturn(this.receiver) ...						local.get $temp;; (JSLiteral) 120						i32.const 120						i32.eq						(if (then ;; (ExpressionStatement) this.doReturn(this.receiver);; (CallExpression) this.doReturn(this.receiver)						local.get $this;; (StaticMemberExpression) this.receiver;; (JSIdentifier) receiver						local.get $receiver						call $doReturn;; (ReturnStatement) return 						return						));; (SwitchCase)  case 121: this.doReturn(this.trueObj) r...						local.get $temp;; (JSLiteral) 121						i32.const 121						i32.eq						(if (then ;; (ExpressionStatement) this.doReturn(this.trueObj);; (CallExpression) this.doReturn(this.trueObj)						local.get $this;; (StaticMemberExpression) this.trueObj;; (JSIdentifier) trueObj						local.get $trueObj						call $doReturn;; (ReturnStatement) return 						return						));; (SwitchCase)  case 122: this.doReturn(this.falseObj) ...						local.get $temp;; (JSLiteral) 122						i32.const 122						i32.eq						(if (then ;; (ExpressionStatement) this.doReturn(this.falseObj);; (CallExpression) this.doReturn(this.falseObj)						local.get $this;; (StaticMemberExpression) this.falseObj;; (JSIdentifier) falseObj						local.get $falseObj						call $doReturn;; (ReturnStatement) return 						return						));; (SwitchCase)  case 123: this.doReturn(this.nilObj) re...						local.get $temp;; (JSLiteral) 123						i32.const 123						i32.eq						(if (then ;; (ExpressionStatement) this.doReturn(this.nilObj);; (CallExpression) this.doReturn(this.nilObj)						local.get $this;; (StaticMemberExpression) this.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $doReturn;; (ReturnStatement) return 						return						));; (SwitchCase)  case 124: this.doReturn(this.pop()) ret...						local.get $temp;; (JSLiteral) 124						i32.const 124						i32.eq						(if (then ;; (ExpressionStatement) this.doReturn(this.pop());; (CallExpression) this.doReturn(this.pop())						local.get $this;; (CallExpression) this.pop()						local.get $this						call $pop						call $doReturn;; (ReturnStatement) return 						return						));; (SwitchCase)  case 125: this.doReturn(this.pop(), thi...						local.get $temp;; (JSLiteral) 125						i32.const 125						i32.eq						(if (then ;; (ExpressionStatement) this.doReturn(this.pop(), this.activeCon...;; (CallExpression) this.doReturn(this.pop(), this.activeCon...						local.get $this;; (CallExpression) this.pop()						local.get $this						call $pop;; (ComputedMemberExpression) this.activeContext.pointers[Squeak.Block...;; (StaticMemberExpression) this.activeContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.BlockContext_caller;; (JSIdentifier) BlockContext_caller						local.get $BlockContext_caller						i32.const 4						i32.mul						i32.add						call $doReturn;; (ReturnStatement) return 						return						));; (SwitchCase)  case 126: this.nono() return 						local.get $temp;; (JSLiteral) 126						i32.const 126						i32.eq						(if (then ;; (ExpressionStatement) this.nono();; (CallExpression) this.nono()						local.get $this						call $nono;; (ReturnStatement) return 						return						));; (SwitchCase)  case 127: this.nono() return 						local.get $temp;; (JSLiteral) 127						i32.const 127						i32.eq						(if (then ;; (ExpressionStatement) this.nono();; (CallExpression) this.nono()						local.get $this						call $nono;; (ReturnStatement) return 						return						)))						(else;; (SwitchStatement) switch (b) { case 128: this.extendedPush...b						local.set $temp;; (SwitchCase)  case 128: this.extendedPush(this.nextBy...						local.get $temp;; (JSLiteral) 128						i32.const 128						i32.eq						(if (then ;; (ExpressionStatement) this.extendedPush(this.nextByte());; (CallExpression) this.extendedPush(this.nextByte())						local.get $this;; (CallExpression) this.nextByte()						local.get $this						call $nextByte						call $extendedPush;; (ReturnStatement) return 						return						));; (SwitchCase)  case 129: this.extendedStore(this.nextB...						local.get $temp;; (JSLiteral) 129						i32.const 129						i32.eq						(if (then ;; (ExpressionStatement) this.extendedStore(this.nextByte());; (CallExpression) this.extendedStore(this.nextByte())						local.get $this;; (CallExpression) this.nextByte()						local.get $this						call $nextByte						call $extendedStore;; (ReturnStatement) return 						return						));; (SwitchCase)  case 130: this.extendedStorePop(this.ne...						local.get $temp;; (JSLiteral) 130						i32.const 130						i32.eq						(if (then ;; (ExpressionStatement) this.extendedStorePop(this.nextByte());; (CallExpression) this.extendedStorePop(this.nextByte())						local.get $this;; (CallExpression) this.nextByte()						local.get $this						call $nextByte						call $extendedStorePop;; (ReturnStatement) return 						return						));; (SwitchCase)  case 131: b2 = this.nextByte() this.sen...						local.get $temp;; (JSLiteral) 131						i32.const 131						i32.eq						(if (then ;; (ExpressionStatement) b2 = this.nextByte();; (AssignmentExpression) b2 = this.nextByte();; (CallExpression) this.nextByte()						local.get $this						call $nextByte						local.set $b2;; (ExpressionStatement) this.send(this.method.methodGetSelector(...;; (CallExpression) this.send(this.method.methodGetSelector(...						local.get $this;; (CallExpression) this.method.methodGetSelector(b2 & 31)						local.get $method;; (BinaryExpression) b2 & 31;; (JSIdentifier) b2						local.get $b2;; (JSLiteral) 31						i32.const 31						i32.and						call $methodGetSelector;; (BinaryExpression) b2 >> 5;; (JSIdentifier) b2						local.get $b2;; (JSLiteral) 5						i32.const 5						i32.shr_s;; (JSLiteral) false						i32.const 0						call $send;; (ReturnStatement) return 						return						));; (SwitchCase)  case 132: this.doubleExtendedDoAnything...						local.get $temp;; (JSLiteral) 132						i32.const 132						i32.eq						(if (then ;; (ExpressionStatement) this.doubleExtendedDoAnything(this.nextB...;; (CallExpression) this.doubleExtendedDoAnything(this.nextB...						local.get $this;; (CallExpression) this.nextByte()						local.get $this						call $nextByte						call $doubleExtendedDoAnything;; (ReturnStatement) return 						return						));; (SwitchCase)  case 133: b2 = this.nextByte() this.sen...						local.get $temp;; (JSLiteral) 133						i32.const 133						i32.eq						(if (then ;; (ExpressionStatement) b2 = this.nextByte();; (AssignmentExpression) b2 = this.nextByte();; (CallExpression) this.nextByte()						local.get $this						call $nextByte						local.set $b2;; (ExpressionStatement) this.send(this.method.methodGetSelector(...;; (CallExpression) this.send(this.method.methodGetSelector(...						local.get $this;; (CallExpression) this.method.methodGetSelector(b2 & 31)						local.get $method;; (BinaryExpression) b2 & 31;; (JSIdentifier) b2						local.get $b2;; (JSLiteral) 31						i32.const 31						i32.and						call $methodGetSelector;; (BinaryExpression) b2 >> 5;; (JSIdentifier) b2						local.get $b2;; (JSLiteral) 5						i32.const 5						i32.shr_s;; (JSLiteral) true						i32.const 1						call $send;; (ReturnStatement) return 						return						));; (SwitchCase)  case 134: b2 = this.nextByte() this.sen...						local.get $temp;; (JSLiteral) 134						i32.const 134						i32.eq						(if (then ;; (ExpressionStatement) b2 = this.nextByte();; (AssignmentExpression) b2 = this.nextByte();; (CallExpression) this.nextByte()						local.get $this						call $nextByte						local.set $b2;; (ExpressionStatement) this.send(this.method.methodGetSelector(...;; (CallExpression) this.send(this.method.methodGetSelector(...						local.get $this;; (CallExpression) this.method.methodGetSelector(b2 & 63)						local.get $method;; (BinaryExpression) b2 & 63;; (JSIdentifier) b2						local.get $b2;; (JSLiteral) 63						i32.const 63						i32.and						call $methodGetSelector;; (BinaryExpression) b2 >> 6;; (JSIdentifier) b2						local.get $b2;; (JSLiteral) 6						i32.const 6						i32.shr_s;; (JSLiteral) false						i32.const 0						call $send;; (ReturnStatement) return 						return						));; (SwitchCase)  case 135: this.pop() return 						local.get $temp;; (JSLiteral) 135						i32.const 135						i32.eq						(if (then ;; (ExpressionStatement) this.pop();; (CallExpression) this.pop()						local.get $this						call $pop;; (ReturnStatement) return 						return						));; (SwitchCase)  case 136: this.push(this.top()) return 						local.get $temp;; (JSLiteral) 136						i32.const 136						i32.eq						(if (then ;; (ExpressionStatement) this.push(this.top());; (CallExpression) this.push(this.top())						local.get $this;; (CallExpression) this.top()						local.get $this						call $top						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 137: this.push(this.exportThisCont...						local.get $temp;; (JSLiteral) 137						i32.const 137						i32.eq						(if (then ;; (ExpressionStatement) this.push(this.exportThisContext());; (CallExpression) this.push(this.exportThisContext())						local.get $this;; (CallExpression) this.exportThisContext()						local.get $this						call $exportThisContext						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 138: this.pushNewArray(this.nextBy...						local.get $temp;; (JSLiteral) 138						i32.const 138						i32.eq						(if (then ;; (ExpressionStatement) this.pushNewArray(this.nextByte());; (CallExpression) this.pushNewArray(this.nextByte())						local.get $this;; (CallExpression) this.nextByte()						local.get $this						call $nextByte						call $pushNewArray;; (ReturnStatement) return 						return						));; (SwitchCase)  case 139: this.callPrimBytecode() retur...						local.get $temp;; (JSLiteral) 139						i32.const 139						i32.eq						(if (then ;; (ExpressionStatement) this.callPrimBytecode();; (CallExpression) this.callPrimBytecode()						local.get $this						call $callPrimBytecode;; (ReturnStatement) return 						return						));; (SwitchCase)  case 140: b2 = this.nextByte() this.pus...						local.get $temp;; (JSLiteral) 140						i32.const 140						i32.eq						(if (then ;; (ExpressionStatement) b2 = this.nextByte();; (AssignmentExpression) b2 = this.nextByte();; (CallExpression) this.nextByte()						local.get $this						call $nextByte						local.set $b2;; (ExpressionStatement) this.push(this.homeContext.pointers[Sque...;; (CallExpression) this.push(this.homeContext.pointers[Sque...						local.get $this;; (ComputedMemberExpression) this.homeContext.pointers[Squeak.Context...;; (StaticMemberExpression) this.homeContext.pointers[Squeak.Context...;; (JSIdentifier) pointers						local.get $pointers;; (JSIdentifier) b2						local.get $b2						i32.const 4						i32.mul						i32.add						call $push;; (ReturnStatement) return 						return						));; (SwitchCase)  case 141: b2 = this.nextByte() this.hom...						local.get $temp;; (JSLiteral) 141						i32.const 141						i32.eq						(if (then ;; (ExpressionStatement) b2 = this.nextByte();; (AssignmentExpression) b2 = this.nextByte();; (CallExpression) this.nextByte()						local.get $this						call $nextByte						local.set $b2;; (ExpressionStatement) this.homeContext.pointers[Squeak.Context...;; (AssignmentExpression) this.homeContext.pointers[Squeak.Context...						local.get $this.homeContext.pointers[Squeak.Context_tempFrameStart + this.nextByte()];; (JSIdentifier) b2						local.get $b2;; (CallExpression) this.top()						local.get $this						call $top						call $atPut;; (ReturnStatement) return 						return						));; (SwitchCase)  case 142: b2 = this.nextByte() this.hom...						local.get $temp;; (JSLiteral) 142						i32.const 142						i32.eq						(if (then ;; (ExpressionStatement) b2 = this.nextByte();; (AssignmentExpression) b2 = this.nextByte();; (CallExpression) this.nextByte()						local.get $this						call $nextByte						local.set $b2;; (ExpressionStatement) this.homeContext.pointers[Squeak.Context...;; (AssignmentExpression) this.homeContext.pointers[Squeak.Context...						local.get $this.homeContext.pointers[Squeak.Context_tempFrameStart + this.nextByte()];; (JSIdentifier) b2						local.get $b2;; (CallExpression) this.pop()						local.get $this						call $pop						call $atPut;; (ReturnStatement) return 						return						));; (SwitchCase)  case 143: this.pushClosureCopy() return...						local.get $temp;; (JSLiteral) 143						i32.const 143						i32.eq						(if (then ;; (ExpressionStatement) this.pushClosureCopy();; (CallExpression) this.pushClosureCopy()						local.get $this						call $pushClosureCopy;; (ReturnStatement) return 						return						));; (SwitchCase)  case 144:						local.get $temp;; (JSLiteral) 144						i32.const 144						i32.eq						(if (then 						));; (SwitchCase)  case 145:						local.get $temp;; (JSLiteral) 145						i32.const 145						i32.eq						(if (then 						));; (SwitchCase)  case 146:						local.get $temp;; (JSLiteral) 146						i32.const 146						i32.eq						(if (then 						));; (SwitchCase)  case 147:						local.get $temp;; (JSLiteral) 147						i32.const 147						i32.eq						(if (then 						));; (SwitchCase)  case 148:						local.get $temp;; (JSLiteral) 148						i32.const 148						i32.eq						(if (then 						));; (SwitchCase)  case 149:						local.get $temp;; (JSLiteral) 149						i32.const 149						i32.eq						(if (then 						));; (SwitchCase)  case 150:						local.get $temp;; (JSLiteral) 150						i32.const 150						i32.eq						(if (then 						));; (SwitchCase)  case 151: this.pc += b & 7 + 1 return 						local.get $temp;; (JSLiteral) 151						i32.const 151						i32.eq						(if (then ;; (ExpressionStatement) this.pc += b & 7 + 1;; (AssignmentExpression) this.pc += b & 7 + 1;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc;; (BinaryExpression) b & 7 + 1;; (BinaryExpression) b & 7;; (JSIdentifier) b						local.get $b;; (JSLiteral) 7						i32.const 7						i32.and;; (JSLiteral) 1						i32.const 1						i32.add						i32.add						local.set $pc;; (ReturnStatement) return 						return						));; (SwitchCase)  case 152:						local.get $temp;; (JSLiteral) 152						i32.const 152						i32.eq						(if (then 						));; (SwitchCase)  case 153:						local.get $temp;; (JSLiteral) 153						i32.const 153						i32.eq						(if (then 						));; (SwitchCase)  case 154:						local.get $temp;; (JSLiteral) 154						i32.const 154						i32.eq						(if (then 						));; (SwitchCase)  case 155:						local.get $temp;; (JSLiteral) 155						i32.const 155						i32.eq						(if (then 						));; (SwitchCase)  case 156:						local.get $temp;; (JSLiteral) 156						i32.const 156						i32.eq						(if (then 						));; (SwitchCase)  case 157:						local.get $temp;; (JSLiteral) 157						i32.const 157						i32.eq						(if (then 						));; (SwitchCase)  case 158:						local.get $temp;; (JSLiteral) 158						i32.const 158						i32.eq						(if (then 						));; (SwitchCase)  case 159: this.jumpIfFalse(b & 7 + 1) r...						local.get $temp;; (JSLiteral) 159						i32.const 159						i32.eq						(if (then ;; (ExpressionStatement) this.jumpIfFalse(b & 7 + 1);; (CallExpression) this.jumpIfFalse(b & 7 + 1)						local.get $this;; (BinaryExpression) b & 7 + 1;; (BinaryExpression) b & 7;; (JSIdentifier) b						local.get $b;; (JSLiteral) 7						i32.const 7						i32.and;; (JSLiteral) 1						i32.const 1						i32.add						call $jumpIfFalse;; (ReturnStatement) return 						return						));; (SwitchCase)  case 160:						local.get $temp;; (JSLiteral) 160						i32.const 160						i32.eq						(if (then 						));; (SwitchCase)  case 161:						local.get $temp;; (JSLiteral) 161						i32.const 161						i32.eq						(if (then 						));; (SwitchCase)  case 162:						local.get $temp;; (JSLiteral) 162						i32.const 162						i32.eq						(if (then 						));; (SwitchCase)  case 163:						local.get $temp;; (JSLiteral) 163						i32.const 163						i32.eq						(if (then 						));; (SwitchCase)  case 164:						local.get $temp;; (JSLiteral) 164						i32.const 164						i32.eq						(if (then 						));; (SwitchCase)  case 165:						local.get $temp;; (JSLiteral) 165						i32.const 165						i32.eq						(if (then 						));; (SwitchCase)  case 166:						local.get $temp;; (JSLiteral) 166						i32.const 166						i32.eq						(if (then 						));; (SwitchCase)  case 167: b2 = this.nextByte() this.pc ...						local.get $temp;; (JSLiteral) 167						i32.const 167						i32.eq						(if (then ;; (ExpressionStatement) b2 = this.nextByte();; (AssignmentExpression) b2 = this.nextByte();; (CallExpression) this.nextByte()						local.get $this						call $nextByte						local.set $b2;; (ExpressionStatement) this.pc += b & 7 - 4 * 256 + b2;; (AssignmentExpression) this.pc += b & 7 - 4 * 256 + b2;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc;; (BinaryExpression) b & 7 - 4 * 256 + b2;; (BinaryExpression) b & 7 - 4 * 256;; (BinaryExpression) b & 7 - 4;; (BinaryExpression) b & 7;; (JSIdentifier) b						local.get $b;; (JSLiteral) 7						i32.const 7						i32.and;; (JSLiteral) 4						i32.const 4						i32.sub;; (JSLiteral) 256						i32.const 256						i32.mul;; (JSIdentifier) b2						local.get $b2						i32.add						i32.add						local.set $pc;; (IfStatement) if (b & 7 < 4) {if (this.interruptCheckC...;; (BinaryExpression) b & 7 < 4;; (BinaryExpression) b & 7;; (JSIdentifier) b						local.get $b;; (JSLiteral) 7						i32.const 7						i32.and;; (JSLiteral) 4						i32.const 4						i32.lt_u						i32.const 0						i32.ne						(if (then;; (IfStatement) if (this.interruptCheckCounter-- <= 0) {...;; (BinaryExpression) this.interruptCheckCounter-- <= 0;; (UpdateExpression) this.interruptCheckCounter--;; (StaticMemberExpression) this.interruptCheckCounter;; (JSIdentifier) interruptCheckCounter						local.get $interruptCheckCounter						i32.const 1						i32.sub;; (JSLiteral) 0						i32.const 0						i32.le_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.checkForInterrupts();; (CallExpression) this.checkForInterrupts()						local.get $this						call $checkForInterrupts))));; (ReturnStatement) return 						return						));; (SwitchCase)  case 168:						local.get $temp;; (JSLiteral) 168						i32.const 168						i32.eq						(if (then 						));; (SwitchCase)  case 169:						local.get $temp;; (JSLiteral) 169						i32.const 169						i32.eq						(if (then 						));; (SwitchCase)  case 170:						local.get $temp;; (JSLiteral) 170						i32.const 170						i32.eq						(if (then 						));; (SwitchCase)  case 171: this.jumpIfTrue(b & 3 * 256 +...						local.get $temp;; (JSLiteral) 171						i32.const 171						i32.eq						(if (then ;; (ExpressionStatement) this.jumpIfTrue(b & 3 * 256 + this.nextB...;; (CallExpression) this.jumpIfTrue(b & 3 * 256 + this.nextB...						local.get $this;; (BinaryExpression) b & 3 * 256 + this.nextByte();; (BinaryExpression) b & 3 * 256;; (BinaryExpression) b & 3;; (JSIdentifier) b						local.get $b;; (JSLiteral) 3						i32.const 3						i32.and;; (JSLiteral) 256						i32.const 256						i32.mul;; (CallExpression) this.nextByte()						local.get $this						call $nextByte						i32.add						call $jumpIfTrue;; (ReturnStatement) return 						return						));; (SwitchCase)  case 172:						local.get $temp;; (JSLiteral) 172						i32.const 172						i32.eq						(if (then 						));; (SwitchCase)  case 173:						local.get $temp;; (JSLiteral) 173						i32.const 173						i32.eq						(if (then 						));; (SwitchCase)  case 174:						local.get $temp;; (JSLiteral) 174						i32.const 174						i32.eq						(if (then 						));; (SwitchCase)  case 175: this.jumpIfFalse(b & 3 * 256 ...						local.get $temp;; (JSLiteral) 175						i32.const 175						i32.eq						(if (then ;; (ExpressionStatement) this.jumpIfFalse(b & 3 * 256 + this.next...;; (CallExpression) this.jumpIfFalse(b & 3 * 256 + this.next...						local.get $this;; (BinaryExpression) b & 3 * 256 + this.nextByte();; (BinaryExpression) b & 3 * 256;; (BinaryExpression) b & 3;; (JSIdentifier) b						local.get $b;; (JSLiteral) 3						i32.const 3						i32.and;; (JSLiteral) 256						i32.const 256						i32.mul;; (CallExpression) this.nextByte()						local.get $this						call $nextByte						i32.add						call $jumpIfFalse;; (ReturnStatement) return 						return						));; (SwitchCase)  case 176: this.success = true this.resu...						local.get $temp;; (JSLiteral) 176						i32.const 176						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (ExpressionStatement) this.resultIsFloat = false;; (AssignmentExpression) this.resultIsFloat = false;; (JSLiteral) false						i32.const 0						local.set $resultIsFloat;; (IfStatement) if (!this.pop2AndPushNumResult(this.stac...;; (UnaryExpression) !this.pop2AndPushNumResult(this.stackInt...;; (CallExpression) this.pop2AndPushNumResult(this.stackIntO...						local.get $this;; (BinaryExpression) this.stackIntOrFloat(1) + this.stackIntO...;; (CallExpression) this.stackIntOrFloat(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackIntOrFloat;; (CallExpression) this.stackIntOrFloat(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackIntOrFloat						i32.add						call $pop2AndPushNumResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 177: this.success = true this.resu...						local.get $temp;; (JSLiteral) 177						i32.const 177						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (ExpressionStatement) this.resultIsFloat = false;; (AssignmentExpression) this.resultIsFloat = false;; (JSLiteral) false						i32.const 0						local.set $resultIsFloat;; (IfStatement) if (!this.pop2AndPushNumResult(this.stac...;; (UnaryExpression) !this.pop2AndPushNumResult(this.stackInt...;; (CallExpression) this.pop2AndPushNumResult(this.stackIntO...						local.get $this;; (BinaryExpression) this.stackIntOrFloat(1) - this.stackIntO...;; (CallExpression) this.stackIntOrFloat(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackIntOrFloat;; (CallExpression) this.stackIntOrFloat(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackIntOrFloat						i32.sub						call $pop2AndPushNumResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 178: this.success = true if (!this...						local.get $temp;; (JSLiteral) 178						i32.const 178						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (IfStatement) if (!this.pop2AndPushBoolResult(this.sta...;; (UnaryExpression) !this.pop2AndPushBoolResult(this.stackIn...;; (CallExpression) this.pop2AndPushBoolResult(this.stackInt...						local.get $this;; (BinaryExpression) this.stackIntOrFloat(1) < this.stackIntO...;; (CallExpression) this.stackIntOrFloat(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackIntOrFloat;; (CallExpression) this.stackIntOrFloat(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackIntOrFloat						i32.lt_u						call $pop2AndPushBoolResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 179: this.success = true if (!this...						local.get $temp;; (JSLiteral) 179						i32.const 179						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (IfStatement) if (!this.pop2AndPushBoolResult(this.sta...;; (UnaryExpression) !this.pop2AndPushBoolResult(this.stackIn...;; (CallExpression) this.pop2AndPushBoolResult(this.stackInt...						local.get $this;; (BinaryExpression) this.stackIntOrFloat(1) > this.stackIntO...;; (CallExpression) this.stackIntOrFloat(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackIntOrFloat;; (CallExpression) this.stackIntOrFloat(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackIntOrFloat						i32.gt_u						call $pop2AndPushBoolResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 180: this.success = true if (!this...						local.get $temp;; (JSLiteral) 180						i32.const 180						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (IfStatement) if (!this.pop2AndPushBoolResult(this.sta...;; (UnaryExpression) !this.pop2AndPushBoolResult(this.stackIn...;; (CallExpression) this.pop2AndPushBoolResult(this.stackInt...						local.get $this;; (BinaryExpression) this.stackIntOrFloat(1) <= this.stackInt...;; (CallExpression) this.stackIntOrFloat(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackIntOrFloat;; (CallExpression) this.stackIntOrFloat(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackIntOrFloat						i32.le_u						call $pop2AndPushBoolResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 181: this.success = true if (!this...						local.get $temp;; (JSLiteral) 181						i32.const 181						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (IfStatement) if (!this.pop2AndPushBoolResult(this.sta...;; (UnaryExpression) !this.pop2AndPushBoolResult(this.stackIn...;; (CallExpression) this.pop2AndPushBoolResult(this.stackInt...						local.get $this;; (BinaryExpression) this.stackIntOrFloat(1) >= this.stackInt...;; (CallExpression) this.stackIntOrFloat(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackIntOrFloat;; (CallExpression) this.stackIntOrFloat(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackIntOrFloat						i32.ge_u						call $pop2AndPushBoolResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 182: this.success = true if (!this...						local.get $temp;; (JSLiteral) 182						i32.const 182						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (IfStatement) if (!this.pop2AndPushBoolResult(this.sta...;; (UnaryExpression) !this.pop2AndPushBoolResult(this.stackIn...;; (CallExpression) this.pop2AndPushBoolResult(this.stackInt...						local.get $this;; (BinaryExpression) this.stackIntOrFloat(1) === this.stackIn...;; (CallExpression) this.stackIntOrFloat(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackIntOrFloat;; (CallExpression) this.stackIntOrFloat(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackIntOrFloat						i32.eq						call $pop2AndPushBoolResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 183: this.success = true if (!this...						local.get $temp;; (JSLiteral) 183						i32.const 183						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (IfStatement) if (!this.pop2AndPushBoolResult(this.sta...;; (UnaryExpression) !this.pop2AndPushBoolResult(this.stackIn...;; (CallExpression) this.pop2AndPushBoolResult(this.stackInt...						local.get $this;; (BinaryExpression) this.stackIntOrFloat(1) !== this.stackIn...;; (CallExpression) this.stackIntOrFloat(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackIntOrFloat;; (CallExpression) this.stackIntOrFloat(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackIntOrFloat						i32.ne						call $pop2AndPushBoolResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 184: this.success = true this.resu...						local.get $temp;; (JSLiteral) 184						i32.const 184						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (ExpressionStatement) this.resultIsFloat = false;; (AssignmentExpression) this.resultIsFloat = false;; (JSLiteral) false						i32.const 0						local.set $resultIsFloat;; (IfStatement) if (!this.pop2AndPushNumResult(this.stac...;; (UnaryExpression) !this.pop2AndPushNumResult(this.stackInt...;; (CallExpression) this.pop2AndPushNumResult(this.stackIntO...						local.get $this;; (BinaryExpression) this.stackIntOrFloat(1) * this.stackIntO...;; (CallExpression) this.stackIntOrFloat(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackIntOrFloat;; (CallExpression) this.stackIntOrFloat(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackIntOrFloat						i32.mul						call $pop2AndPushNumResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 185: this.success = true if (!this...						local.get $temp;; (JSLiteral) 185						i32.const 185						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (IfStatement) if (!this.pop2AndPushIntResult(this.quic...;; (UnaryExpression) !this.pop2AndPushIntResult(this.quickDiv...;; (CallExpression) this.pop2AndPushIntResult(this.quickDivi...						local.get $this;; (CallExpression) this.quickDivide(this.stackInteger(1), t...						local.get $this;; (CallExpression) this.stackInteger(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackInteger;; (CallExpression) this.stackInteger(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackInteger						call $quickDivide						call $pop2AndPushIntResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 186: this.success = true if (!this...						local.get $temp;; (JSLiteral) 186						i32.const 186						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (IfStatement) if (!this.pop2AndPushIntResult(this.mod(...;; (UnaryExpression) !this.pop2AndPushIntResult(this.mod(this...;; (CallExpression) this.pop2AndPushIntResult(this.mod(this....						local.get $this;; (CallExpression) this.mod(this.stackInteger(1), this.stac...						local.get $this;; (CallExpression) this.stackInteger(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackInteger;; (CallExpression) this.stackInteger(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackInteger						call $mod						call $pop2AndPushIntResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 187: this.success = true if (!this...						local.get $temp;; (JSLiteral) 187						i32.const 187						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (IfStatement) if (!this.primHandler.primitiveMakePoint...;; (UnaryExpression) !this.primHandler.primitiveMakePoint(1, ...;; (CallExpression) this.primHandler.primitiveMakePoint(1, t...						local.get $primHandler;; (JSLiteral) 1						i32.const 1;; (JSLiteral) true						i32.const 1						call $primitiveMakePoint						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 188: this.success = true if (!this...						local.get $temp;; (JSLiteral) 188						i32.const 188						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (IfStatement) if (!this.pop2AndPushIntResult(this.safe...;; (UnaryExpression) !this.pop2AndPushIntResult(this.safeShif...;; (CallExpression) this.pop2AndPushIntResult(this.safeShift...						local.get $this;; (CallExpression) this.safeShift(this.stackInteger(1), thi...						local.get $this;; (CallExpression) this.stackInteger(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackInteger;; (CallExpression) this.stackInteger(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackInteger						call $safeShift						call $pop2AndPushIntResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 189: this.success = true if (!this...						local.get $temp;; (JSLiteral) 189						i32.const 189						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (IfStatement) if (!this.pop2AndPushIntResult(this.div(...;; (UnaryExpression) !this.pop2AndPushIntResult(this.div(this...;; (CallExpression) this.pop2AndPushIntResult(this.div(this....						local.get $this;; (CallExpression) this.div(this.stackInteger(1), this.stac...						local.get $this;; (CallExpression) this.stackInteger(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackInteger;; (CallExpression) this.stackInteger(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackInteger						call $div						call $pop2AndPushIntResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 190: this.success = true if (!this...						local.get $temp;; (JSLiteral) 190						i32.const 190						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (IfStatement) if (!this.pop2AndPushIntResult(this.stac...;; (UnaryExpression) !this.pop2AndPushIntResult(this.stackInt...;; (CallExpression) this.pop2AndPushIntResult(this.stackInte...						local.get $this;; (BinaryExpression) this.stackInteger(1) & this.stackInteger...;; (CallExpression) this.stackInteger(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackInteger;; (CallExpression) this.stackInteger(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackInteger						i32.and						call $pop2AndPushIntResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 191: this.success = true if (!this...						local.get $temp;; (JSLiteral) 191						i32.const 191						i32.eq						(if (then ;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (IfStatement) if (!this.pop2AndPushIntResult(this.stac...;; (UnaryExpression) !this.pop2AndPushIntResult(this.stackInt...;; (CallExpression) this.pop2AndPushIntResult(this.stackInte...						local.get $this;; (BinaryExpression) this.stackInteger(1) | this.stackInteger...;; (CallExpression) this.stackInteger(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackInteger;; (CallExpression) this.stackInteger(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackInteger						i32.or						call $pop2AndPushIntResult						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15);; (CallExpression) this.sendSpecial(b & 15)						local.get $this;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 192:						local.get $temp;; (JSLiteral) 192						i32.const 192						i32.eq						(if (then 						));; (SwitchCase)  case 193:						local.get $temp;; (JSLiteral) 193						i32.const 193						i32.eq						(if (then 						));; (SwitchCase)  case 194:						local.get $temp;; (JSLiteral) 194						i32.const 194						i32.eq						(if (then 						));; (SwitchCase)  case 195:						local.get $temp;; (JSLiteral) 195						i32.const 195						i32.eq						(if (then 						));; (SwitchCase)  case 196:						local.get $temp;; (JSLiteral) 196						i32.const 196						i32.eq						(if (then 						));; (SwitchCase)  case 197:						local.get $temp;; (JSLiteral) 197						i32.const 197						i32.eq						(if (then 						));; (SwitchCase)  case 198:						local.get $temp;; (JSLiteral) 198						i32.const 198						i32.eq						(if (then 						));; (SwitchCase)  case 199:						local.get $temp;; (JSLiteral) 199						i32.const 199						i32.eq						(if (then 						));; (SwitchCase)  case 200:						local.get $temp;; (JSLiteral) 200						i32.const 200						i32.eq						(if (then 						));; (SwitchCase)  case 201:						local.get $temp;; (JSLiteral) 201						i32.const 201						i32.eq						(if (then 						));; (SwitchCase)  case 202:						local.get $temp;; (JSLiteral) 202						i32.const 202						i32.eq						(if (then 						));; (SwitchCase)  case 203:						local.get $temp;; (JSLiteral) 203						i32.const 203						i32.eq						(if (then 						));; (SwitchCase)  case 204:						local.get $temp;; (JSLiteral) 204						i32.const 204						i32.eq						(if (then 						));; (SwitchCase)  case 205:						local.get $temp;; (JSLiteral) 205						i32.const 205						i32.eq						(if (then 						));; (SwitchCase)  case 206:						local.get $temp;; (JSLiteral) 206						i32.const 206						i32.eq						(if (then 						));; (SwitchCase)  case 207: if (!this.primHandler.quickSe...						local.get $temp;; (JSLiteral) 207						i32.const 207						i32.eq						(if (then ;; (IfStatement) if (!this.primHandler.quickSendOther(thi...;; (UnaryExpression) !this.primHandler.quickSendOther(this.re...;; (CallExpression) this.primHandler.quickSendOther(this.rec...						local.get $primHandler;; (StaticMemberExpression) this.receiver;; (JSIdentifier) receiver						local.get $receiver;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $quickSendOther						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.sendSpecial(b & 15 + 16);; (CallExpression) this.sendSpecial(b & 15 + 16)						local.get $this;; (BinaryExpression) b & 15 + 16;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and;; (JSLiteral) 16						i32.const 16						i32.add						call $sendSpecial));; (ReturnStatement) return 						return						));; (SwitchCase)  case 208:						local.get $temp;; (JSLiteral) 208						i32.const 208						i32.eq						(if (then 						));; (SwitchCase)  case 209:						local.get $temp;; (JSLiteral) 209						i32.const 209						i32.eq						(if (then 						));; (SwitchCase)  case 210:						local.get $temp;; (JSLiteral) 210						i32.const 210						i32.eq						(if (then 						));; (SwitchCase)  case 211:						local.get $temp;; (JSLiteral) 211						i32.const 211						i32.eq						(if (then 						));; (SwitchCase)  case 212:						local.get $temp;; (JSLiteral) 212						i32.const 212						i32.eq						(if (then 						));; (SwitchCase)  case 213:						local.get $temp;; (JSLiteral) 213						i32.const 213						i32.eq						(if (then 						));; (SwitchCase)  case 214:						local.get $temp;; (JSLiteral) 214						i32.const 214						i32.eq						(if (then 						));; (SwitchCase)  case 215:						local.get $temp;; (JSLiteral) 215						i32.const 215						i32.eq						(if (then 						));; (SwitchCase)  case 216:						local.get $temp;; (JSLiteral) 216						i32.const 216						i32.eq						(if (then 						));; (SwitchCase)  case 217:						local.get $temp;; (JSLiteral) 217						i32.const 217						i32.eq						(if (then 						));; (SwitchCase)  case 218:						local.get $temp;; (JSLiteral) 218						i32.const 218						i32.eq						(if (then 						));; (SwitchCase)  case 219:						local.get $temp;; (JSLiteral) 219						i32.const 219						i32.eq						(if (then 						));; (SwitchCase)  case 220:						local.get $temp;; (JSLiteral) 220						i32.const 220						i32.eq						(if (then 						));; (SwitchCase)  case 221:						local.get $temp;; (JSLiteral) 221						i32.const 221						i32.eq						(if (then 						));; (SwitchCase)  case 222:						local.get $temp;; (JSLiteral) 222						i32.const 222						i32.eq						(if (then 						));; (SwitchCase)  case 223: this.send(this.method.methodG...						local.get $temp;; (JSLiteral) 223						i32.const 223						i32.eq						(if (then ;; (ExpressionStatement) this.send(this.method.methodGetSelector(...;; (CallExpression) this.send(this.method.methodGetSelector(...						local.get $this;; (CallExpression) this.method.methodGetSelector(b & 15)						local.get $method;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $methodGetSelector;; (JSLiteral) 0						i32.const 0;; (JSLiteral) false						i32.const 0						call $send;; (ReturnStatement) return 						return						));; (SwitchCase)  case 224:						local.get $temp;; (JSLiteral) 224						i32.const 224						i32.eq						(if (then 						));; (SwitchCase)  case 225:						local.get $temp;; (JSLiteral) 225						i32.const 225						i32.eq						(if (then 						));; (SwitchCase)  case 226:						local.get $temp;; (JSLiteral) 226						i32.const 226						i32.eq						(if (then 						));; (SwitchCase)  case 227:						local.get $temp;; (JSLiteral) 227						i32.const 227						i32.eq						(if (then 						));; (SwitchCase)  case 228:						local.get $temp;; (JSLiteral) 228						i32.const 228						i32.eq						(if (then 						));; (SwitchCase)  case 229:						local.get $temp;; (JSLiteral) 229						i32.const 229						i32.eq						(if (then 						));; (SwitchCase)  case 230:						local.get $temp;; (JSLiteral) 230						i32.const 230						i32.eq						(if (then 						));; (SwitchCase)  case 231:						local.get $temp;; (JSLiteral) 231						i32.const 231						i32.eq						(if (then 						));; (SwitchCase)  case 232:						local.get $temp;; (JSLiteral) 232						i32.const 232						i32.eq						(if (then 						));; (SwitchCase)  case 233:						local.get $temp;; (JSLiteral) 233						i32.const 233						i32.eq						(if (then 						));; (SwitchCase)  case 234:						local.get $temp;; (JSLiteral) 234						i32.const 234						i32.eq						(if (then 						));; (SwitchCase)  case 235:						local.get $temp;; (JSLiteral) 235						i32.const 235						i32.eq						(if (then 						));; (SwitchCase)  case 236:						local.get $temp;; (JSLiteral) 236						i32.const 236						i32.eq						(if (then 						));; (SwitchCase)  case 237:						local.get $temp;; (JSLiteral) 237						i32.const 237						i32.eq						(if (then 						));; (SwitchCase)  case 238:						local.get $temp;; (JSLiteral) 238						i32.const 238						i32.eq						(if (then 						));; (SwitchCase)  case 239: this.send(this.method.methodG...						local.get $temp;; (JSLiteral) 239						i32.const 239						i32.eq						(if (then ;; (ExpressionStatement) this.send(this.method.methodGetSelector(...;; (CallExpression) this.send(this.method.methodGetSelector(...						local.get $this;; (CallExpression) this.method.methodGetSelector(b & 15)						local.get $method;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $methodGetSelector;; (JSLiteral) 1						i32.const 1;; (JSLiteral) false						i32.const 0						call $send;; (ReturnStatement) return 						return						));; (SwitchCase)  case 240:						local.get $temp;; (JSLiteral) 240						i32.const 240						i32.eq						(if (then 						));; (SwitchCase)  case 241:						local.get $temp;; (JSLiteral) 241						i32.const 241						i32.eq						(if (then 						));; (SwitchCase)  case 242:						local.get $temp;; (JSLiteral) 242						i32.const 242						i32.eq						(if (then 						));; (SwitchCase)  case 243:						local.get $temp;; (JSLiteral) 243						i32.const 243						i32.eq						(if (then 						));; (SwitchCase)  case 244:						local.get $temp;; (JSLiteral) 244						i32.const 244						i32.eq						(if (then 						));; (SwitchCase)  case 245:						local.get $temp;; (JSLiteral) 245						i32.const 245						i32.eq						(if (then 						));; (SwitchCase)  case 246:						local.get $temp;; (JSLiteral) 246						i32.const 246						i32.eq						(if (then 						));; (SwitchCase)  case 247:						local.get $temp;; (JSLiteral) 247						i32.const 247						i32.eq						(if (then 						));; (SwitchCase)  case 248:						local.get $temp;; (JSLiteral) 248						i32.const 248						i32.eq						(if (then 						));; (SwitchCase)  case 249:						local.get $temp;; (JSLiteral) 249						i32.const 249						i32.eq						(if (then 						));; (SwitchCase)  case 250:						local.get $temp;; (JSLiteral) 250						i32.const 250						i32.eq						(if (then 						));; (SwitchCase)  case 251:						local.get $temp;; (JSLiteral) 251						i32.const 251						i32.eq						(if (then 						));; (SwitchCase)  case 252:						local.get $temp;; (JSLiteral) 252						i32.const 252						i32.eq						(if (then 						));; (SwitchCase)  case 253:						local.get $temp;; (JSLiteral) 253						i32.const 253						i32.eq						(if (then 						));; (SwitchCase)  case 254:						local.get $temp;; (JSLiteral) 254						i32.const 254						i32.eq						(if (then 						));; (SwitchCase)  case 255: this.send(this.method.methodG...						local.get $temp;; (JSLiteral) 255						i32.const 255						i32.eq						(if (then ;; (ExpressionStatement) this.send(this.method.methodGetSelector(...;; (CallExpression) this.send(this.method.methodGetSelector(...						local.get $this;; (CallExpression) this.method.methodGetSelector(b & 15)						local.get $method;; (BinaryExpression) b & 15;; (JSIdentifier) b						local.get $b;; (JSLiteral) 15						i32.const 15						i32.and						call $methodGetSelector;; (JSLiteral) 2						i32.const 2;; (JSLiteral) false						i32.const 0						call $send;; (ReturnStatement) return 						return						))));; (DebuggerStatement) an active DebuggerStatement with propert...;; (ThrowStatement) throw Error('not a bytecode: ' + b)						unreachable);; (JSProperty) property: useWASM -> function() { 	this....;; (FunctionExpression) function() { 	this.currentInterpretOne =...(func $useWASM						(local $temp i32)						;; (ExpressionStatement) this.currentInterpretOne = this.interpre...;; (AssignmentExpression) this.currentInterpretOne = this.interpre...;; (StaticMemberExpression) this.interpretOneWASM;; (JSIdentifier) interpretOneWASM						local.get $interpretOneWASM						local.set $currentInterpretOne);; (JSProperty) property: doNotUseWASM -> function() { 	...;; (FunctionExpression) function() { 	this.currentInterpretOne =...(func $doNotUseWASM						(local $temp i32)						;; (ExpressionStatement) this.currentInterpretOne = this.interpre...;; (AssignmentExpression) this.currentInterpretOne = this.interpre...;; (StaticMemberExpression) this.interpretOne;; (JSIdentifier) interpretOne						local.get $interpretOne						local.set $currentInterpretOne);; (JSProperty) property: interpret -> function(forMilli...;; (FunctionExpression) function(forMilliseconds, thenDo) { 	if ...(func $interpret						(local $forMilliseconds i32)						(local $temp i32)						(local $thenDo i32)						(local $result i32)												;; unwritable: (IfStatement) if (this.frozen) {return 'frozen'};; (ExpressionStatement) this.isIdle = false;; (AssignmentExpression) this.isIdle = false;; (JSLiteral) false						i32.const 0						local.set $isIdle;; (ExpressionStatement) this.breakOutOfInterpreter = false;; (AssignmentExpression) this.breakOutOfInterpreter = false;; (JSLiteral) false						i32.const 0						local.set $breakOutOfInterpreter;; (ExpressionStatement) this.breakOutTick = this.primHandler.mil...;; (AssignmentExpression) this.breakOutTick = this.primHandler.mil...;; (BinaryExpression) this.primHandler.millisecondClockValue()...;; (CallExpression) this.primHandler.millisecondClockValue()						local.get $primHandler						call $millisecondClockValue;; (BinaryExpression) forMilliseconds || 500;; (JSIdentifier) forMilliseconds						local.get $forMilliseconds;; (JSLiteral) 500						i32.const 500						i32.or						i32.add						local.set $breakOutTick;; (WhileStatement) while (this.breakOutOfInterpreter === fa...						(loop $loop_1;; (BlockStatement) if (this.method.compiled) {this.method.c...;; (IfStatement) if (this.method.compiled) {this.method.c...;; (StaticMemberExpression) this.method.compiled;; (JSIdentifier) compiled						local.get $compiled						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.method.compiled(this) ;; (ExpressionStatement) this.method.compiled(this);; (CallExpression) this.method.compiled(this)						local.get $method;; (ThisExpression) this						call $compiled)						(else;; (BlockStatement) this.currentInterpretOne() ;; (ExpressionStatement) this.currentInterpretOne();; (CallExpression) this.currentInterpretOne()						local.get $this						call $currentInterpretOne));; (BinaryExpression) this.breakOutOfInterpreter === false;; (StaticMemberExpression) this.breakOutOfInterpreter;; (JSIdentifier) breakOutOfInterpreter						local.get $breakOutOfInterpreter;; (JSLiteral) false						i32.const 0						i32.eq						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue)						;; unwritable: (IfStatement) if (typeof this.breakOutOfInterpreter ==;; (IfStatement) if (thenDo) {thenDo(result)};; (JSIdentifier) thenDo						local.get $thenDo						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) thenDo(result);; (CallExpression) thenDo(result);; (JSIdentifier) result						local.get $result						call $thenDo));; (ReturnStatement) return result;; (JSIdentifier) result						local.get $result						return);; (JSProperty) property: goIdle -> function() { 	var ha...;; (FunctionExpression) function() { 	var hadTimer = this.nextWa...(func $goIdle						(local $temp i32)						(local $hadTimer i32)						(local $hasTimer i32)						;; (ExpressionStatement) this.forceInterruptCheck();; (CallExpression) this.forceInterruptCheck()						local.get $this						call $forceInterruptCheck;; (ExpressionStatement) this.checkForInterrupts();; (CallExpression) this.checkForInterrupts()						local.get $this						call $checkForInterrupts;; (ExpressionStatement) this.isIdle = hasTimer || !hadTimer;; (AssignmentExpression) this.isIdle = hasTimer || !hadTimer;; (BinaryExpression) hasTimer || !hadTimer;; (JSIdentifier) hasTimer						local.get $hasTimer;; (UnaryExpression) !hadTimer;; (JSIdentifier) hadTimer						local.get $hadTimer						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						local.set $isIdle;; (ExpressionStatement) this.breakOut();; (CallExpression) this.breakOut()						local.get $this						call $breakOut);; (JSProperty) property: freeze -> function(frozenDo) {...;; (FunctionExpression) function(frozenDo) { 	var continueFunc t...(func $freeze						(local $unfreeze i32)						(local $frozenDo i32)						(local $temp i32)						(local $continueFunc i32)						;; (ExpressionStatement) this.frozen = true;; (AssignmentExpression) this.frozen = true;; (JSLiteral) true						i32.const 1						local.set $frozen						;; unwritable: (ExpressionStatement) this.breakOutOfInterpreter = function(th						;; unwritable: (IfStatement) if (frozenDo) {self.setTimeout(function(;; (ReturnStatement) return unfreeze;; (JSIdentifier) unfreeze						local.get $unfreeze						return);; (JSProperty) property: breakOut -> function() { 	this...;; (FunctionExpression) function() { 	this.breakOutOfInterpreter...(func $breakOut						(local $temp i32)						;; (ExpressionStatement) this.breakOutOfInterpreter = this.breakO...;; (AssignmentExpression) this.breakOutOfInterpreter = this.breakO...;; (BinaryExpression) this.breakOutOfInterpreter || true;; (StaticMemberExpression) this.breakOutOfInterpreter;; (JSIdentifier) breakOutOfInterpreter						local.get $breakOutOfInterpreter;; (JSLiteral) true						i32.const 1						i32.or						local.set $breakOutOfInterpreter);; (JSProperty) property: nextByte -> function() { 	retu...;; (FunctionExpression) function() { 	return this.method.bytes[t...(func $nextByte						(local $temp i32)						;; (ReturnStatement) return this.method.bytes[this.pc++];; (ComputedMemberExpression) this.method.bytes[this.pc++];; (StaticMemberExpression) this.method.bytes;; (JSIdentifier) bytes						local.get $bytes;; (UpdateExpression) this.pc++;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc						i32.const 1						i32.add						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: nono -> function() { 	throw Er...;; (FunctionExpression) function() { 	throw Error('Oh No!') }(func $nono						(local $temp i32)						;; (ThrowStatement) throw Error('Oh No!')						unreachable);; (JSProperty) property: forceInterruptCheck -> functio...;; (FunctionExpression) function() { 	this.interruptCheckCounter...(func $forceInterruptCheck						(local $temp i32)												;; unwritable: (ExpressionStatement) this.interruptCheckCounter = -1000);; (JSProperty) property: checkForInterrupts -> function...;; (FunctionExpression) function() { 	var now = this.primHandler...(func $checkForInterrupts						(local $now i32)						(local $sema i32)						(local $temp i32)						;; (IfStatement) if (now < this.lastTick) {this.nextPollT...;; (BinaryExpression) now < this.lastTick;; (JSIdentifier) now						local.get $now;; (StaticMemberExpression) this.lastTick;; (JSIdentifier) lastTick						local.get $lastTick						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.nextPollTick = now + this.nextPollT...;; (ExpressionStatement) this.nextPollTick = now + this.nextPollT...;; (AssignmentExpression) this.nextPollTick = now + this.nextPollT...;; (BinaryExpression) now + this.nextPollTick - this.lastTick;; (JSIdentifier) now						local.get $now;; (BinaryExpression) this.nextPollTick - this.lastTick;; (StaticMemberExpression) this.nextPollTick;; (JSIdentifier) nextPollTick						local.get $nextPollTick;; (StaticMemberExpression) this.lastTick;; (JSIdentifier) lastTick						local.get $lastTick						i32.sub						i32.add						local.set $nextPollTick;; (ExpressionStatement) this.breakOutTick = now + this.breakOutT...;; (AssignmentExpression) this.breakOutTick = now + this.breakOutT...;; (BinaryExpression) now + this.breakOutTick - this.lastTick;; (JSIdentifier) now						local.get $now;; (BinaryExpression) this.breakOutTick - this.lastTick;; (StaticMemberExpression) this.breakOutTick;; (JSIdentifier) breakOutTick						local.get $breakOutTick;; (StaticMemberExpression) this.lastTick;; (JSIdentifier) lastTick						local.get $lastTick						i32.sub						i32.add						local.set $breakOutTick;; (IfStatement) if (this.nextWakeupTick !== 0) {this.nex...;; (BinaryExpression) this.nextWakeupTick !== 0;; (StaticMemberExpression) this.nextWakeupTick;; (JSIdentifier) nextWakeupTick						local.get $nextWakeupTick;; (JSLiteral) 0						i32.const 0						i32.ne						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.nextWakeupTick = now + this.nextWak...;; (AssignmentExpression) this.nextWakeupTick = now + this.nextWak...;; (BinaryExpression) now + this.nextWakeupTick - this.lastTic...;; (JSIdentifier) now						local.get $now;; (BinaryExpression) this.nextWakeupTick - this.lastTick;; (StaticMemberExpression) this.nextWakeupTick;; (JSIdentifier) nextWakeupTick						local.get $nextWakeupTick;; (StaticMemberExpression) this.lastTick;; (JSIdentifier) lastTick						local.get $lastTick						i32.sub						i32.add						local.set $nextWakeupTick))));; (IfStatement) if (this.interruptCheckCounter > -100) {...;; (BinaryExpression) this.interruptCheckCounter > -100;; (StaticMemberExpression) this.interruptCheckCounter;; (JSIdentifier) interruptCheckCounter						local.get $interruptCheckCounter;; (UnaryExpression) -100;; (JSLiteral) 100						i32.const 100						local.set $temp						i32.const 0						local.get $temp						i32.sub						i32.gt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (now - this.lastTick < this.interrupt...;; (IfStatement) if (now - this.lastTick < this.interrupt...;; (BinaryExpression) now - this.lastTick < this.interruptChec...;; (BinaryExpression) now - this.lastTick;; (JSIdentifier) now						local.get $now;; (StaticMemberExpression) this.lastTick;; (JSIdentifier) lastTick						local.get $lastTick						i32.sub;; (StaticMemberExpression) this.interruptChecksEveryNms;; (JSIdentifier) interruptChecksEveryNms						local.get $interruptChecksEveryNms						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.interruptCheckCounterFeedBackReset ...;; (ExpressionStatement) this.interruptCheckCounterFeedBackReset ...;; (AssignmentExpression) this.interruptCheckCounterFeedBackReset ...;; (StaticMemberExpression) this.interruptCheckCounterFeedBackReset;; (JSIdentifier) interruptCheckCounterFeedBackReset						local.get $interruptCheckCounterFeedBackReset;; (JSLiteral) 10						i32.const 10						i32.add						local.set $interruptCheckCounterFeedBackReset)						(else;; (BlockStatement) if (this.interruptCheckCounterFeedBackRe...;; (IfStatement) if (this.interruptCheckCounterFeedBackRe...;; (BinaryExpression) this.interruptCheckCounterFeedBackReset ...;; (StaticMemberExpression) this.interruptCheckCounterFeedBackReset;; (JSIdentifier) interruptCheckCounterFeedBackReset						local.get $interruptCheckCounterFeedBackReset;; (JSLiteral) 1000						i32.const 1000						i32.le_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.interruptCheckCounterFeedBackReset ...;; (AssignmentExpression) this.interruptCheckCounterFeedBackReset ...;; (JSLiteral) 1000						i32.const 1000						local.set $interruptCheckCounterFeedBackReset)						(else;; (ExpressionStatement) this.interruptCheckCounterFeedBackReset ...;; (AssignmentExpression) this.interruptCheckCounterFeedBackReset ...;; (StaticMemberExpression) this.interruptCheckCounterFeedBackReset;; (JSIdentifier) interruptCheckCounterFeedBackReset						local.get $interruptCheckCounterFeedBackReset;; (JSLiteral) 12						i32.const 12						i32.sub						local.set $interruptCheckCounterFeedBackReset))))));; (ExpressionStatement) this.interruptCheckCounter = this.interr...;; (AssignmentExpression) this.interruptCheckCounter = this.interr...;; (StaticMemberExpression) this.interruptCheckCounterFeedBackReset;; (JSIdentifier) interruptCheckCounterFeedBackReset						local.get $interruptCheckCounterFeedBackReset						local.set $interruptCheckCounter;; (ExpressionStatement) this.lastTick = now;; (AssignmentExpression) this.lastTick = now;; (JSIdentifier) now						local.get $now						local.set $lastTick;; (IfStatement) if (this.interruptPending) {this.interru...;; (StaticMemberExpression) this.interruptPending;; (JSIdentifier) interruptPending						local.get $interruptPending						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.interruptPending = false var sema =...;; (ExpressionStatement) this.interruptPending = false;; (AssignmentExpression) this.interruptPending = false;; (JSLiteral) false						i32.const 0						local.set $interruptPending;; (VariableDeclaration) var sema = this.specialObjects[Squeak.sp...;; (VariableDeclarator) sema = this.specialObjects[Squeak.splOb_...;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_TheInte...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_TheInterruptSemaphore;; (JSIdentifier) splOb_TheInterruptSemaphore						local.get $splOb_TheInterruptSemaphore						i32.const 4						i32.mul						i32.add						local.set $sema;; (IfStatement) if (!sema.isNil) {this.primHandler.synch...;; (UnaryExpression) !sema.isNil;; (StaticMemberExpression) sema.isNil;; (JSIdentifier) isNil						local.get $isNil						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.primHandler.synchronousSignal(sema);; (CallExpression) this.primHandler.synchronousSignal(sema)						local.get $primHandler;; (JSIdentifier) sema						local.get $sema						call $synchronousSignal))));; (IfStatement) if (this.nextWakeupTick !== 0 && now >= ...;; (BinaryExpression) this.nextWakeupTick !== 0 && now >= this...;; (BinaryExpression) this.nextWakeupTick !== 0;; (StaticMemberExpression) this.nextWakeupTick;; (JSIdentifier) nextWakeupTick						local.get $nextWakeupTick;; (JSLiteral) 0						i32.const 0						i32.ne;; (BinaryExpression) now >= this.nextWakeupTick;; (JSIdentifier) now						local.get $now;; (StaticMemberExpression) this.nextWakeupTick;; (JSIdentifier) nextWakeupTick						local.get $nextWakeupTick						i32.ge_u						i32.and						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.nextWakeupTick = 0 var sema = this....;; (ExpressionStatement) this.nextWakeupTick = 0;; (AssignmentExpression) this.nextWakeupTick = 0;; (JSLiteral) 0						i32.const 0						local.set $nextWakeupTick;; (VariableDeclaration) var sema = this.specialObjects[Squeak.sp...;; (VariableDeclarator) sema = this.specialObjects[Squeak.splOb_...;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_TheTime...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_TheTimerSemaphore;; (JSIdentifier) splOb_TheTimerSemaphore						local.get $splOb_TheTimerSemaphore						i32.const 4						i32.mul						i32.add						local.set $sema;; (IfStatement) if (!sema.isNil) {this.primHandler.synch...;; (UnaryExpression) !sema.isNil;; (StaticMemberExpression) sema.isNil;; (JSIdentifier) isNil						local.get $isNil						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.primHandler.synchronousSignal(sema);; (CallExpression) this.primHandler.synchronousSignal(sema)						local.get $primHandler;; (JSIdentifier) sema						local.get $sema						call $synchronousSignal))));; (IfStatement) if (this.pendingFinalizationSignals > 0)...;; (BinaryExpression) this.pendingFinalizationSignals > 0;; (StaticMemberExpression) this.pendingFinalizationSignals;; (JSIdentifier) pendingFinalizationSignals						local.get $pendingFinalizationSignals;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) var sema = this.specialObjects[Squeak.sp...;; (VariableDeclaration) var sema = this.specialObjects[Squeak.sp...;; (VariableDeclarator) sema = this.specialObjects[Squeak.splOb_...;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_TheFina...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_TheFinalizationSemaphore;; (JSIdentifier) splOb_TheFinalizationSemaphore						local.get $splOb_TheFinalizationSemaphore						i32.const 4						i32.mul						i32.add						local.set $sema;; (ExpressionStatement) this.pendingFinalizationSignals = 0;; (AssignmentExpression) this.pendingFinalizationSignals = 0;; (JSLiteral) 0						i32.const 0						local.set $pendingFinalizationSignals;; (IfStatement) if (!sema.isNil) {this.primHandler.synch...;; (UnaryExpression) !sema.isNil;; (StaticMemberExpression) sema.isNil;; (JSIdentifier) isNil						local.get $isNil						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.primHandler.synchronousSignal(sema);; (CallExpression) this.primHandler.synchronousSignal(sema)						local.get $primHandler;; (JSIdentifier) sema						local.get $sema						call $synchronousSignal))));; (IfStatement) if (this.primHandler.semaphoresToSignal....;; (BinaryExpression) this.primHandler.semaphoresToSignal.leng...;; (StaticMemberExpression) this.primHandler.semaphoresToSignal.leng...;; (JSIdentifier) length						local.get $length;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.primHandler.signalExternalSemaphore...;; (CallExpression) this.primHandler.signalExternalSemaphore...						local.get $primHandler						call $signalExternalSemaphores));; (IfStatement) if (!this.method.compiled && this.compil...;; (BinaryExpression) !this.method.compiled && this.compiler &...;; (BinaryExpression) !this.method.compiled && this.compiler;; (UnaryExpression) !this.method.compiled;; (StaticMemberExpression) this.method.compiled;; (JSIdentifier) compiled						local.get $compiled						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (StaticMemberExpression) this.compiler;; (JSIdentifier) compiler						local.get $compiler						i32.and;; (UnaryExpression) !this.method === this.specialObjects[Squ...;; (BinaryExpression) this.method === this.specialObjects[Sque...;; (StaticMemberExpression) this.method;; (JSIdentifier) method						local.get $method;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_Reloadi...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ReloadingMethod;; (JSIdentifier) splOb_ReloadingMethod						local.get $splOb_ReloadingMethod						i32.const 4						i32.mul						i32.add						i32.eq						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.and						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.compiler.compile(this.method);; (CallExpression) this.compiler.compile(this.method)						local.get $compiler;; (StaticMemberExpression) this.method;; (JSIdentifier) method						local.get $method						call $compile));; (IfStatement) if (now >= this.breakOutTick) {this.brea...;; (BinaryExpression) now >= this.breakOutTick;; (JSIdentifier) now						local.get $now;; (StaticMemberExpression) this.breakOutTick;; (JSIdentifier) breakOutTick						local.get $breakOutTick						i32.ge_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.breakOut();; (CallExpression) this.breakOut()						local.get $this						call $breakOut)));; (JSProperty) property: extendedPush -> function(nextB...;; (FunctionExpression) function(nextByte) { 	var lobits = nextB...(func $extendedPush						(local $nextByte i32)						(local $temp i32)						(local $lobits i32)						;; (SwitchStatement) switch (nextByte >> 6) { case 0: this.pu...nextByte >> 6						local.set $temp;; (SwitchCase)  case 0: this.push(this.receiver.pointer...						local.get $temp;; (JSLiteral) 0						i32.const 0						i32.eq						(if (then ;; (ExpressionStatement) this.push(this.receiver.pointers[lobits]...;; (CallExpression) this.push(this.receiver.pointers[lobits]...						local.get $this;; (ComputedMemberExpression) this.receiver.pointers[lobits];; (StaticMemberExpression) this.receiver.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSIdentifier) lobits						local.get $lobits						i32.const 4						i32.mul						i32.add						call $push;; (BreakStatement) break						));; (SwitchCase)  case 1: this.push(this.homeContext.poin...						local.get $temp;; (JSLiteral) 1						i32.const 1						i32.eq						(if (then ;; (ExpressionStatement) this.push(this.homeContext.pointers[Sque...;; (CallExpression) this.push(this.homeContext.pointers[Sque...						local.get $this;; (ComputedMemberExpression) this.homeContext.pointers[Squeak.Context...;; (StaticMemberExpression) this.homeContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) Squeak.Context_tempFrameStart + lobits;; (StaticMemberExpression) Squeak.Context_tempFrameStart;; (JSIdentifier) Context_tempFrameStart						local.get $Context_tempFrameStart;; (JSIdentifier) lobits						local.get $lobits						i32.add						i32.const 4						i32.mul						i32.add						call $push;; (BreakStatement) break						));; (SwitchCase)  case 2: this.push(this.method.methodGet...						local.get $temp;; (JSLiteral) 2						i32.const 2						i32.eq						(if (then ;; (ExpressionStatement) this.push(this.method.methodGetLiteral(l...;; (CallExpression) this.push(this.method.methodGetLiteral(l...						local.get $this;; (CallExpression) this.method.methodGetLiteral(lobits)						local.get $method;; (JSIdentifier) lobits						local.get $lobits						call $methodGetLiteral						call $push;; (BreakStatement) break						));; (SwitchCase)  case 3: this.push(this.method.methodGet...						local.get $temp;; (JSLiteral) 3						i32.const 3						i32.eq						(if (then ;; (ExpressionStatement) this.push(this.method.methodGetLiteral(l...;; (CallExpression) this.push(this.method.methodGetLiteral(l...						local.get $this;; (ComputedMemberExpression) this.method.methodGetLiteral(lobits).poi...;; (StaticMemberExpression) this.method.methodGetLiteral(lobits).poi...;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Assn_value;; (JSIdentifier) Assn_value						local.get $Assn_value						i32.const 4						i32.mul						i32.add						call $push;; (BreakStatement) break						)));; (JSProperty) property: extendedStore -> function(next...;; (FunctionExpression) function(nextByte) { 	var lobits = nextB...(func $extendedStore						(local $nextByte i32)						(local $temp i32)						(local $lobits i32)												;; unwritable: (SwitchStatement) switch (nextByte >> 6) { case 0: this.re);; (JSProperty) property: extendedStorePop -> function(n...;; (FunctionExpression) function(nextByte) { 	var lobits = nextB...(func $extendedStorePop						(local $nextByte i32)						(local $temp i32)						(local $lobits i32)												;; unwritable: (SwitchStatement) switch (nextByte >> 6) { case 0: this.re);; (JSProperty) property: doubleExtendedDoAnything -> fu...;; (FunctionExpression) function(byte2) { 	var byte3 = this.next...(func $doubleExtendedDoAnything						(local $temp i32)						(local $byte2 i32)						(local $byte3 i32)												;; unwritable: (SwitchStatement) switch (byte2 >> 5) { case 0: this.send();; (JSProperty) property: jumpIfTrue -> function(delta) ...;; (FunctionExpression) function(delta) { 	var top = this.pop() ...(func $jumpIfTrue						(local $delta i32)						(local $top i32)						(local $temp i32)						;; (IfStatement) if (top.isTrue) {this.pc += delta return...;; (StaticMemberExpression) top.isTrue;; (JSIdentifier) isTrue						local.get $isTrue						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.pc += delta return  ;; (ExpressionStatement) this.pc += delta;; (AssignmentExpression) this.pc += delta;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc;; (JSIdentifier) delta						local.get $delta						i32.add						local.set $pc;; (ReturnStatement) return 						return));; (IfStatement) if (top.isFalse) {return };; (StaticMemberExpression) top.isFalse;; (JSIdentifier) isFalse						local.get $isFalse						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 						return));; (ExpressionStatement) this.push(top);; (CallExpression) this.push(top)						local.get $this;; (JSIdentifier) top						local.get $top						call $push;; (ExpressionStatement) this.send(this.specialObjects[Squeak.spl...;; (CallExpression) this.send(this.specialObjects[Squeak.spl...						local.get $this;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_Selecto...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_SelectorMustBeBoolean;; (JSIdentifier) splOb_SelectorMustBeBoolean						local.get $splOb_SelectorMustBeBoolean						i32.const 4						i32.mul						i32.add;; (JSLiteral) 0						i32.const 0;; (JSLiteral) false						i32.const 0						call $send);; (JSProperty) property: jumpIfFalse -> function(delta)...;; (FunctionExpression) function(delta) { 	var top = this.pop() ...(func $jumpIfFalse						(local $delta i32)						(local $top i32)						(local $temp i32)						;; (IfStatement) if (top.isFalse) {this.pc += delta retur...;; (StaticMemberExpression) top.isFalse;; (JSIdentifier) isFalse						local.get $isFalse						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.pc += delta return  ;; (ExpressionStatement) this.pc += delta;; (AssignmentExpression) this.pc += delta;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc;; (JSIdentifier) delta						local.get $delta						i32.add						local.set $pc;; (ReturnStatement) return 						return));; (IfStatement) if (top.isTrue) {return };; (StaticMemberExpression) top.isTrue;; (JSIdentifier) isTrue						local.get $isTrue						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 						return));; (ExpressionStatement) this.push(top);; (CallExpression) this.push(top)						local.get $this;; (JSIdentifier) top						local.get $top						call $push;; (ExpressionStatement) this.send(this.specialObjects[Squeak.spl...;; (CallExpression) this.send(this.specialObjects[Squeak.spl...						local.get $this;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_Selecto...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_SelectorMustBeBoolean;; (JSIdentifier) splOb_SelectorMustBeBoolean						local.get $splOb_SelectorMustBeBoolean						i32.const 4						i32.mul						i32.add;; (JSLiteral) 0						i32.const 0;; (JSLiteral) false						i32.const 0						call $send);; (JSProperty) property: sendSpecial -> function(lobits...;; (FunctionExpression) function(lobits) { 	this.send(this.speci...(func $sendSpecial						(local $temp i32)						(local $lobits i32)						;; (ExpressionStatement) this.send(this.specialSelectors[lobits *...;; (CallExpression) this.send(this.specialSelectors[lobits *...						local.get $this;; (ComputedMemberExpression) this.specialSelectors[lobits * 2];; (StaticMemberExpression) this.specialSelectors;; (JSIdentifier) specialSelectors						local.get $specialSelectors;; (BinaryExpression) lobits * 2;; (JSIdentifier) lobits						local.get $lobits;; (JSLiteral) 2						i32.const 2						i32.mul						i32.const 4						i32.mul						i32.add;; (ComputedMemberExpression) this.specialSelectors[lobits * 2 + 1];; (StaticMemberExpression) this.specialSelectors;; (JSIdentifier) specialSelectors						local.get $specialSelectors;; (BinaryExpression) lobits * 2 + 1;; (BinaryExpression) lobits * 2;; (JSIdentifier) lobits						local.get $lobits;; (JSLiteral) 2						i32.const 2						i32.mul;; (JSLiteral) 1						i32.const 1						i32.add						i32.const 4						i32.mul						i32.add;; (JSLiteral) false						i32.const 0						call $send);; (JSProperty) property: callPrimBytecode -> function()...;; (FunctionExpression) function() { 	this.pc += 2 if (this.prim...(func $callPrimBytecode						(local $temp i32)						;; (ExpressionStatement) this.pc += 2;; (AssignmentExpression) this.pc += 2;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc;; (JSLiteral) 2						i32.const 2						i32.add						local.set $pc;; (IfStatement) if (this.primFailCode) {if (this.method....;; (StaticMemberExpression) this.primFailCode;; (JSIdentifier) primFailCode						local.get $primFailCode						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (this.method.bytes[this.pc] === 129) ...;; (IfStatement) if (this.method.bytes[this.pc] === 129) ...;; (BinaryExpression) this.method.bytes[this.pc] === 129;; (ComputedMemberExpression) this.method.bytes[this.pc];; (StaticMemberExpression) this.method.bytes;; (JSIdentifier) bytes						local.get $bytes;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc						i32.const 4						i32.mul						i32.add;; (JSLiteral) 129						i32.const 129						i32.eq						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.stackTopPut(this.getErrorObjectFrom...;; (CallExpression) this.stackTopPut(this.getErrorObjectFrom...						local.get $this;; (CallExpression) this.getErrorObjectFromPrimFailCode()						local.get $this						call $getErrorObjectFromPrimFailCode						call $stackTopPut));; (ExpressionStatement) this.primFailCode = 0;; (AssignmentExpression) this.primFailCode = 0;; (JSLiteral) 0						i32.const 0						local.set $primFailCode)));; (JSProperty) property: getErrorObjectFromPrimFailCode...;; (FunctionExpression) function() { 	var primErrTable = this.sp...(func $getErrorObjectFromPrimFailCode						(local $primErrTable i32)						(local $errorObject i32)						(local $temp i32)						;; (IfStatement) if (primErrTable && primErrTable.pointer...;; (BinaryExpression) primErrTable && primErrTable.pointers;; (JSIdentifier) primErrTable						local.get $primErrTable;; (StaticMemberExpression) primErrTable.pointers;; (JSIdentifier) pointers						local.get $pointers						i32.and						i32.const 0						i32.ne						(if (then;; (BlockStatement) var errorObject = primErrTable.pointers[...;; (VariableDeclaration) var errorObject = primErrTable.pointers[...;; (VariableDeclarator) errorObject = primErrTable.pointers[this...;; (ComputedMemberExpression) primErrTable.pointers[this.primFailCode ...;; (StaticMemberExpression) primErrTable.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) this.primFailCode - 1;; (StaticMemberExpression) this.primFailCode;; (JSIdentifier) primFailCode						local.get $primFailCode;; (JSLiteral) 1						i32.const 1						i32.sub						i32.const 4						i32.mul						i32.add						local.set $errorObject;; (IfStatement) if (errorObject) {return errorObject};; (JSIdentifier) errorObject						local.get $errorObject						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return errorObject;; (JSIdentifier) errorObject						local.get $errorObject						return))));; (ReturnStatement) return this.primFailCode;; (StaticMemberExpression) this.primFailCode;; (JSIdentifier) primFailCode						local.get $primFailCode						return);; (JSProperty) property: pushNewArray -> function(nextB...;; (FunctionExpression) function(nextByte) { 	var popValues = ne...(func $pushNewArray						(local $nextByte i32)						(local $popValues i32)						(local $array i32)						(local $count i32)						(local $i i32)						(local $temp i32)						;; (IfStatement) if (popValues) {for (var i = 0; i < coun...;; (JSIdentifier) popValues						local.get $popValues						i32.const 0						i32.ne						(if (then;; (BlockStatement) for (var i = 0; i < count; i++) {array.p...;; (ForStatement) for (var i = 0; i < count; i++) {array.p...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) array.pointers[i] = this.stackValue(coun...;; (AssignmentExpression) array.pointers[i] = this.stackValue(coun...						local.get $array;; (JSIdentifier) i						local.get $i;; (CallExpression) this.stackValue(count - i - 1)						local.get $this;; (BinaryExpression) count - i - 1;; (BinaryExpression) count - i;; (JSIdentifier) count						local.get $count;; (JSIdentifier) i						local.get $i						i32.sub;; (JSLiteral) 1						i32.const 1						i32.sub						call $stackValue						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < count;; (JSIdentifier) i						local.get $i;; (JSIdentifier) count						local.get $count						i32.lt_u						i32.const 0						br_if $loop_1);; (ExpressionStatement) this.popN(count);; (CallExpression) this.popN(count)						local.get $this;; (JSIdentifier) count						local.get $count						call $popN));; (ExpressionStatement) this.push(array);; (CallExpression) this.push(array)						local.get $this;; (JSIdentifier) array						local.get $array						call $push);; (JSProperty) property: pushClosureCopy -> function() ...;; (FunctionExpression) function() { 	var numArgsNumCopied = thi...(func $pushClosureCopy						(local $temp i32)						(local $numCopied i32)						(local $blockSizeHigh i32)						(local $closure i32)						(local $i i32)						(local $blockSize i32)						(local $initialPC i32)						(local $numArgs i32)						(local $numArgsNumCopied i32)						;; (ExpressionStatement) closure.pointers[Squeak.Closure_outerCon...;; (AssignmentExpression) closure.pointers[Squeak.Closure_outerCon...						local.get $closure;; (StaticMemberExpression) Squeak.Closure_outerContext;; (JSIdentifier) Closure_outerContext						local.get $Closure_outerContext;; (StaticMemberExpression) this.activeContext;; (JSIdentifier) activeContext						local.get $activeContext						call $atPut;; (ExpressionStatement) this.reclaimableContextCount = 0;; (AssignmentExpression) this.reclaimableContextCount = 0;; (JSLiteral) 0						i32.const 0						local.set $reclaimableContextCount;; (IfStatement) if (numCopied > 0) {for (var i = 0; i < ...;; (BinaryExpression) numCopied > 0;; (JSIdentifier) numCopied						local.get $numCopied;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) for (var i = 0; i < numCopied; i++) {clo...;; (ForStatement) for (var i = 0; i < numCopied; i++) {clo...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) closure.pointers[Squeak.Closure_firstCop...;; (AssignmentExpression) closure.pointers[Squeak.Closure_firstCop...						local.get $closure;; (BinaryExpression) Squeak.Closure_firstCopiedValue + i;; (StaticMemberExpression) Squeak.Closure_firstCopiedValue;; (JSIdentifier) Closure_firstCopiedValue						local.get $Closure_firstCopiedValue;; (JSIdentifier) i						local.get $i						i32.add;; (CallExpression) this.stackValue(numCopied - i - 1)						local.get $this;; (BinaryExpression) numCopied - i - 1;; (BinaryExpression) numCopied - i;; (JSIdentifier) numCopied						local.get $numCopied;; (JSIdentifier) i						local.get $i						i32.sub;; (JSLiteral) 1						i32.const 1						i32.sub						call $stackValue						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < numCopied;; (JSIdentifier) i						local.get $i;; (JSIdentifier) numCopied						local.get $numCopied						i32.lt_u						i32.const 0						br_if $loop_1);; (ExpressionStatement) this.popN(numCopied);; (CallExpression) this.popN(numCopied)						local.get $this;; (JSIdentifier) numCopied						local.get $numCopied						call $popN));; (ExpressionStatement) this.pc += blockSize;; (AssignmentExpression) this.pc += blockSize;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc;; (JSIdentifier) blockSize						local.get $blockSize						i32.add						local.set $pc;; (ExpressionStatement) this.push(closure);; (CallExpression) this.push(closure)						local.get $this;; (JSIdentifier) closure						local.get $closure						call $push);; (JSProperty) property: newClosure -> function(numArgs...;; (FunctionExpression) function(numArgs, initialPC, numCopied) ...(func $newClosure						(local $initialPC i32)						(local $numCopied i32)						(local $closure i32)						(local $numArgs i32)						(local $temp i32)						;; (ExpressionStatement) closure.pointers[Squeak.Closure_startpc]...;; (AssignmentExpression) closure.pointers[Squeak.Closure_startpc]...						local.get $closure;; (StaticMemberExpression) Squeak.Closure_startpc;; (JSIdentifier) Closure_startpc						local.get $Closure_startpc;; (JSIdentifier) initialPC						local.get $initialPC						call $atPut;; (ExpressionStatement) closure.pointers[Squeak.Closure_numArgs]...;; (AssignmentExpression) closure.pointers[Squeak.Closure_numArgs]...						local.get $closure;; (StaticMemberExpression) Squeak.Closure_numArgs;; (JSIdentifier) Closure_numArgs						local.get $Closure_numArgs;; (JSIdentifier) numArgs						local.get $numArgs						call $atPut;; (ReturnStatement) return closure;; (JSIdentifier) closure						local.get $closure						return);; (JSProperty) property: send -> function(selector, arg...;; (FunctionExpression) function(selector, argCount, doSuper) { ...(func $send						(local $lookupClass i32)						(local $newRcvr i32)						(local $selector i32)						(local $argCount i32)						(local $temp i32)						(local $doSuper i32)						(local $entry i32)						;; (IfStatement) if (doSuper) {lookupClass = this.method....;; (JSIdentifier) doSuper						local.get $doSuper						i32.const 0						i32.ne						(if (then;; (BlockStatement) lookupClass = this.method.methodClassFor...;; (ExpressionStatement) lookupClass = this.method.methodClassFor...;; (AssignmentExpression) lookupClass = this.method.methodClassFor...;; (CallExpression) this.method.methodClassForSuper()						local.get $method						call $methodClassForSuper						local.set $lookupClass;; (ExpressionStatement) lookupClass = lookupClass.pointers[Squea...;; (AssignmentExpression) lookupClass = lookupClass.pointers[Squea...;; (ComputedMemberExpression) lookupClass.pointers[Squeak.Class_superc...;; (StaticMemberExpression) lookupClass.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Class_superclass;; (JSIdentifier) Class_superclass						local.get $Class_superclass						i32.const 4						i32.mul						i32.add						local.set $lookupClass));; (IfStatement) if (entry.primIndex) {this.verifyAtSelec...;; (StaticMemberExpression) entry.primIndex;; (JSIdentifier) primIndex						local.get $primIndex						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.verifyAtSelector = selector this.ve...;; (ExpressionStatement) this.verifyAtSelector = selector;; (AssignmentExpression) this.verifyAtSelector = selector;; (JSIdentifier) selector						local.get $selector						local.set $verifyAtSelector;; (ExpressionStatement) this.verifyAtClass = lookupClass;; (AssignmentExpression) this.verifyAtClass = lookupClass;; (JSIdentifier) lookupClass						local.get $lookupClass						local.set $verifyAtClass));; (ExpressionStatement) this.executeNewMethod(newRcvr, entry.met...;; (CallExpression) this.executeNewMethod(newRcvr, entry.met...						local.get $this;; (JSIdentifier) newRcvr						local.get $newRcvr;; (StaticMemberExpression) entry.method;; (JSIdentifier) method						local.get $method;; (StaticMemberExpression) entry.argCount;; (JSIdentifier) argCount						local.get $argCount;; (StaticMemberExpression) entry.primIndex;; (JSIdentifier) primIndex						local.get $primIndex;; (StaticMemberExpression) entry.mClass;; (JSIdentifier) mClass						local.get $mClass;; (JSIdentifier) selector						local.get $selector						call $executeNewMethod);; (JSProperty) property: sendAsPrimitiveFailure -> func...;; (FunctionExpression) function(rcvr, method, argCount) { 	this...(func $sendAsPrimitiveFailure						(local $rcvr i32)						(local $method i32)						(local $argCount i32)						(local $temp i32)						;; (ExpressionStatement) this.executeNewMethod(rcvr, method, argC...;; (CallExpression) this.executeNewMethod(rcvr, method, argC...						local.get $this;; (JSIdentifier) rcvr						local.get $rcvr;; (JSIdentifier) method						local.get $method;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 0						i32.const 0						call $executeNewMethod);; (JSProperty) property: shouldForward -> function(sele...;; (FunctionExpression) function(selector, theClass) { 	return f...(func $shouldForward						(local $temp i32)						(local $theClass i32)						(local $selector i32)						;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: findSelectorInClass -> functio...;; (FunctionExpression) function(selector, argCount, startingCla...(func $findSelectorInClass						(local $message i32)						(local $currentClass i32)						(local $temp i32)						(local $dnuMsg i32)						(local $cantInterpMsg i32)						(local $selector i32)						(local $newMethod i32)						(local $dnuSel i32)						(local $cantInterpSel i32)						(local $startingClass i32)						(local $argCount i32)						(local $cacheEntry i32)						(local $mDict i32)						;; (IfStatement) if (this.shouldForward(selector, startin...;; (CallExpression) this.shouldForward(selector, startingCla...						local.get $this;; (JSIdentifier) selector						local.get $selector;; (JSIdentifier) startingClass						local.get $startingClass						call $shouldForward						i32.const 0						i32.ne						(if (then;; (BlockStatement) var message = this.createActualMessage(s...;; (VariableDeclaration) var message = this.createActualMessage(s...;; (VariableDeclarator) message = this.createActualMessage(selec...;; (CallExpression) this.createActualMessage(selector, argCo...						local.get $this;; (JSIdentifier) selector						local.get $selector;; (JSIdentifier) argCount						local.get $argCount;; (JSIdentifier) startingClass						local.get $startingClass						call $createActualMessage						local.set $message;; (ExpressionStatement) this.popNandPush(argCount, message);; (CallExpression) this.popNandPush(argCount, message)						local.get $this;; (JSIdentifier) argCount						local.get $argCount;; (JSIdentifier) message						local.get $message						call $popNandPush;; (ReturnStatement) return this.findSelectorInClass(this.spe...;; (CallExpression) this.findSelectorInClass(this.specialObj...						local.get $this;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_Selecto...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_SelectorForward;; (JSIdentifier) splOb_SelectorForward						local.get $splOb_SelectorForward						i32.const 4						i32.mul						i32.add						call $findSelectorInClass						return));; (IfStatement) if (cacheEntry.method) {return cacheEntr...;; (StaticMemberExpression) cacheEntry.method;; (JSIdentifier) method						local.get $method						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return cacheEntry;; (JSIdentifier) cacheEntry						local.get $cacheEntry						return));; (WhileStatement) while (!currentClass.isNil) {mDict = cur...						(loop $loop_1;; (BlockStatement) mDict = currentClass.pointers[Squeak.Cla...;; (ExpressionStatement) mDict = currentClass.pointers[Squeak.Cla...;; (AssignmentExpression) mDict = currentClass.pointers[Squeak.Cla...;; (ComputedMemberExpression) currentClass.pointers[Squeak.Class_mdict...;; (StaticMemberExpression) currentClass.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Class_mdict;; (JSIdentifier) Class_mdict						local.get $Class_mdict						i32.const 4						i32.mul						i32.add						local.set $mDict;; (IfStatement) if (mDict.isNil) {var cantInterpSel = th...;; (StaticMemberExpression) mDict.isNil;; (JSIdentifier) isNil						local.get $isNil						i32.const 0						i32.ne						(if (then;; (BlockStatement) var cantInterpSel = this.specialObjects[...;; (VariableDeclaration) var cantInterpSel = this.specialObjects[...;; (VariableDeclarator) cantInterpSel = this.specialObjects[Sque...;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_Selecto...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_SelectorCannotInterpret;; (JSIdentifier) splOb_SelectorCannotInterpret						local.get $splOb_SelectorCannotInterpret						i32.const 4						i32.mul						i32.add						local.set $cantInterpSel;; (VariableDeclarator) cantInterpMsg = this.createActualMessage...;; (CallExpression) this.createActualMessage(selector, argCo...						local.get $this;; (JSIdentifier) selector						local.get $selector;; (JSIdentifier) argCount						local.get $argCount;; (JSIdentifier) startingClass						local.get $startingClass						call $createActualMessage						local.set $cantInterpMsg;; (ExpressionStatement) this.popNandPush(argCount, cantInterpMsg...;; (CallExpression) this.popNandPush(argCount, cantInterpMsg...						local.get $this;; (JSIdentifier) argCount						local.get $argCount;; (JSIdentifier) cantInterpMsg						local.get $cantInterpMsg						call $popNandPush;; (ReturnStatement) return this.findSelectorInClass(cantInte...;; (CallExpression) this.findSelectorInClass(cantInterpSel, ...						local.get $this;; (JSIdentifier) cantInterpSel						local.get $cantInterpSel;; (JSLiteral) 1						i32.const 1;; (CallExpression) currentClass.superclass()						local.get $currentClass						call $superclass						call $findSelectorInClass						return));; (VariableDeclaration) var newMethod = this.lookupSelectorInDic...;; (VariableDeclarator) newMethod = this.lookupSelectorInDict(mD...;; (CallExpression) this.lookupSelectorInDict(mDict, selecto...						local.get $this;; (JSIdentifier) mDict						local.get $mDict;; (JSIdentifier) selector						local.get $selector						call $lookupSelectorInDict						local.set $newMethod;; (IfStatement) if (!newMethod) {an active DebuggerState...;; (UnaryExpression) !newMethod;; (JSIdentifier) newMethod						local.get $newMethod						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (DebuggerStatement) an active DebuggerStatement with propert...));; (IfStatement) if (!newMethod.isNil) {this.currentSelec...;; (UnaryExpression) !newMethod.isNil;; (StaticMemberExpression) newMethod.isNil;; (JSIdentifier) isNil						local.get $isNil						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.currentSelector = selector this.cur...;; (ExpressionStatement) this.currentSelector = selector;; (AssignmentExpression) this.currentSelector = selector;; (JSIdentifier) selector						local.get $selector						local.set $currentSelector;; (ExpressionStatement) this.currentLookupClass = startingClass;; (AssignmentExpression) this.currentLookupClass = startingClass;; (JSIdentifier) startingClass						local.get $startingClass						local.set $currentLookupClass;; (ExpressionStatement) cacheEntry.method = newMethod;; (AssignmentExpression) cacheEntry.method = newMethod;; (JSIdentifier) newMethod						local.get $newMethod						local.set $method;; (ExpressionStatement) cacheEntry.primIndex = newMethod.isMetho...;; (AssignmentExpression) cacheEntry.primIndex = newMethod.isMetho...;; (ConditionalExpression) newMethod.isMethod() ? newMethod.methodP...;; (CallExpression) newMethod.isMethod()						local.get $newMethod						call $isMethod						i32.const 1						i32.eq						(if (then;; (CallExpression) newMethod.methodPrimitiveIndex()						local.get $newMethod						call $methodPrimitiveIndex)						(else;; (JSLiteral) 248						i32.const 248						))						local.set $primIndex;; (ExpressionStatement) cacheEntry.argCount = argCount;; (AssignmentExpression) cacheEntry.argCount = argCount;; (JSIdentifier) argCount						local.get $argCount						local.set $argCount;; (ExpressionStatement) cacheEntry.mClass = currentClass;; (AssignmentExpression) cacheEntry.mClass = currentClass;; (JSIdentifier) currentClass						local.get $currentClass						local.set $mClass;; (ReturnStatement) return cacheEntry;; (JSIdentifier) cacheEntry						local.get $cacheEntry						return));; (ExpressionStatement) currentClass = currentClass.superclass();; (AssignmentExpression) currentClass = currentClass.superclass();; (CallExpression) currentClass.superclass()						local.get $currentClass						call $superclass						local.set $currentClass;; (UnaryExpression) !currentClass.isNil;; (StaticMemberExpression) currentClass.isNil;; (JSIdentifier) isNil						local.get $isNil						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (IfStatement) if (selector === dnuSel) {an active Debu...;; (BinaryExpression) selector === dnuSel;; (JSIdentifier) selector						local.get $selector;; (JSIdentifier) dnuSel						local.get $dnuSel						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) an active DebuggerStatement with propert...;; (DebuggerStatement) an active DebuggerStatement with propert...;; (ThrowStatement) throw Error('Recursive not understood er...						unreachable));; (ExpressionStatement) this.popNandPush(argCount, dnuMsg);; (CallExpression) this.popNandPush(argCount, dnuMsg)						local.get $this;; (JSIdentifier) argCount						local.get $argCount;; (JSIdentifier) dnuMsg						local.get $dnuMsg						call $popNandPush;; (ReturnStatement) return this.findSelectorInClass(dnuSel, ...;; (CallExpression) this.findSelectorInClass(dnuSel, 1, star...						local.get $this;; (JSIdentifier) dnuSel						local.get $dnuSel;; (JSLiteral) 1						i32.const 1;; (JSIdentifier) startingClass						local.get $startingClass						call $findSelectorInClass						return);; (JSProperty) property: lookupSelectorInDict -> functi...;; (FunctionExpression) function(mDict, messageSelector) { 	var ...(func $lookupSelectorInDict						(local $temp i32)						(local $nextSelector i32)						(local $dictSize i32)						(local $messageSelector i32)						(local $mask i32)						(local $index i32)						(local $hasWrapped i32)						(local $methArray i32)						(local $mDict i32)												;; unwritable: (WhileStatement) while (true) {var nextSelector = mDict.p);; (JSProperty) property: executeNewMethod -> function(n...;; (FunctionExpression) function(newRcvr, newMethod, argumentCou...(func $executeNewMethod						(local $temp i32)						(local $newSP i32)						(local $newMethod i32)						(local $optSel i32)						(local $newRcvr i32)						(local $argumentCount i32)						(local $tempCount i32)						(local $primitiveIndex i32)						(local $newContext i32)						(local $specialTemporaryVariableIndex i32)						(local $cachedArguments i32)						(local $newPC i32)						(local $optClass i32)						;; (ExpressionStatement) this.sendCount++;; (UpdateExpression) this.sendCount++;; (StaticMemberExpression) this.sendCount;; (JSIdentifier) sendCount						local.get $sendCount						i32.const 1						i32.add						;; unwritable: (IfStatement) if (newMethod === this.breakOnMethod) {t						;; unwritable: (IfStatement) if (this.logSends) {console.log(this.sen;; (IfStatement) if (this.breakOnContextChanged) {this.br...;; (StaticMemberExpression) this.breakOnContextChanged;; (JSIdentifier) breakOnContextChanged						local.get $breakOnContextChanged						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.breakOnContextChanged = false this....;; (ExpressionStatement) this.breakOnContextChanged = false;; (AssignmentExpression) this.breakOnContextChanged = false;; (JSLiteral) false						i32.const 0						local.set $breakOnContextChanged;; (ExpressionStatement) this.breakNow();; (CallExpression) this.breakNow()						local.get $this						call $breakNow));; (IfStatement) if (primitiveIndex > 0) {if (this.tryPri...;; (BinaryExpression) primitiveIndex > 0;; (JSIdentifier) primitiveIndex						local.get $primitiveIndex;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (this.tryPrimitive(primitiveIndex, ar...;; (IfStatement) if (this.tryPrimitive(primitiveIndex, ar...;; (CallExpression) this.tryPrimitive(primitiveIndex, argume...						local.get $this;; (JSIdentifier) primitiveIndex						local.get $primitiveIndex;; (JSIdentifier) argumentCount						local.get $argumentCount;; (JSIdentifier) newMethod						local.get $newMethod						call $tryPrimitive						i32.const 0						i32.ne						(if (then;; (BlockStatement) newMethod.fused = true return  ;; (ExpressionStatement) newMethod.fused = true;; (AssignmentExpression) newMethod.fused = true;; (JSLiteral) true						i32.const 1						local.set $fused;; (ReturnStatement) return 						return))));; (ExpressionStatement) newContext.pointers[Squeak.Context_metho...;; (AssignmentExpression) newContext.pointers[Squeak.Context_metho...						local.get $newContext;; (StaticMemberExpression) Squeak.Context_method;; (JSIdentifier) Context_method						local.get $Context_method;; (JSIdentifier) newMethod						local.get $newMethod						call $atPut;; (ExpressionStatement) newContext.pointers[Squeak.BlockContext_...;; (AssignmentExpression) newContext.pointers[Squeak.BlockContext_...						local.get $newContext;; (StaticMemberExpression) Squeak.BlockContext_initialIP;; (JSIdentifier) BlockContext_initialIP						local.get $BlockContext_initialIP;; (StaticMemberExpression) this.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut;; (ExpressionStatement) newContext.pointers[Squeak.Context_sende...;; (AssignmentExpression) newContext.pointers[Squeak.Context_sende...						local.get $newContext;; (StaticMemberExpression) Squeak.Context_sender;; (JSIdentifier) Context_sender						local.get $Context_sender;; (StaticMemberExpression) this.activeContext;; (JSIdentifier) activeContext						local.get $activeContext						call $atPut;; (ExpressionStatement) this.arrayCopy(this.activeContext.pointe...;; (CallExpression) this.arrayCopy(this.activeContext.pointe...						local.get $this;; (StaticMemberExpression) this.activeContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) this.sp - argumentCount;; (StaticMemberExpression) this.sp;; (JSIdentifier) sp						local.get $sp;; (JSIdentifier) argumentCount						local.get $argumentCount						i32.sub;; (StaticMemberExpression) newContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) Squeak.Context_tempFrameStart - 1;; (StaticMemberExpression) Squeak.Context_tempFrameStart;; (JSIdentifier) Context_tempFrameStart						local.get $Context_tempFrameStart;; (JSLiteral) 1						i32.const 1						i32.sub;; (BinaryExpression) argumentCount + 1;; (JSIdentifier) argumentCount						local.get $argumentCount;; (JSLiteral) 1						i32.const 1						i32.add						call $arrayCopy;; (ExpressionStatement) this.arrayFill(newContext.pointers, Sque...;; (CallExpression) this.arrayFill(newContext.pointers, Sque...						local.get $this;; (StaticMemberExpression) newContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) Squeak.Context_tempFrameStart + argument...;; (StaticMemberExpression) Squeak.Context_tempFrameStart;; (JSIdentifier) Context_tempFrameStart						local.get $Context_tempFrameStart;; (JSIdentifier) argumentCount						local.get $argumentCount						i32.add;; (BinaryExpression) Squeak.Context_tempFrameStart + tempCoun...;; (StaticMemberExpression) Squeak.Context_tempFrameStart;; (JSIdentifier) Context_tempFrameStart						local.get $Context_tempFrameStart;; (JSIdentifier) tempCount						local.get $tempCount						i32.add;; (StaticMemberExpression) this.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $arrayFill						;; unwritable: (IfStatement) if (newMethod === this.specialObjects[Sq;; (ExpressionStatement) this.popN(argumentCount + 1);; (CallExpression) this.popN(argumentCount + 1)						local.get $this;; (BinaryExpression) argumentCount + 1;; (JSIdentifier) argumentCount						local.get $argumentCount;; (JSLiteral) 1						i32.const 1						i32.add						call $popN;; (ExpressionStatement) this.reclaimableContextCount++;; (UpdateExpression) this.reclaimableContextCount++;; (StaticMemberExpression) this.reclaimableContextCount;; (JSIdentifier) reclaimableContextCount						local.get $reclaimableContextCount						i32.const 1						i32.add;; (ExpressionStatement) this.storeContextRegisters();; (CallExpression) this.storeContextRegisters()						local.get $this						call $storeContextRegisters;; (ExpressionStatement) this.activeContext = newContext;; (AssignmentExpression) this.activeContext = newContext;; (JSIdentifier) newContext						local.get $newContext						local.set $activeContext;; (ExpressionStatement) this.activeContext.dirty = true;; (AssignmentExpression) this.activeContext.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty;; (ExpressionStatement) this.homeContext = newContext;; (AssignmentExpression) this.homeContext = newContext;; (JSIdentifier) newContext						local.get $newContext						local.set $homeContext;; (ExpressionStatement) this.method = newMethod;; (AssignmentExpression) this.method = newMethod;; (JSIdentifier) newMethod						local.get $newMethod						local.set $method;; (ExpressionStatement) this.method.fused = true;; (AssignmentExpression) this.method.fused = true;; (JSLiteral) true						i32.const 1						local.set $fused;; (ExpressionStatement) this.pc = newPC;; (AssignmentExpression) this.pc = newPC;; (JSIdentifier) newPC						local.get $newPC						local.set $pc;; (ExpressionStatement) this.sp = newSP;; (AssignmentExpression) this.sp = newSP;; (JSIdentifier) newSP						local.get $newSP						local.set $sp;; (ExpressionStatement) this.receiver = newContext.pointers[Sque...;; (AssignmentExpression) this.receiver = newContext.pointers[Sque...;; (ComputedMemberExpression) newContext.pointers[Squeak.Context_recei...;; (StaticMemberExpression) newContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_receiver;; (JSIdentifier) Context_receiver						local.get $Context_receiver						i32.const 4						i32.mul						i32.add						local.set $receiver;; (IfStatement) if (this.receiver !== newRcvr) {an activ...;; (BinaryExpression) this.receiver !== newRcvr;; (StaticMemberExpression) this.receiver;; (JSIdentifier) receiver						local.get $receiver;; (JSIdentifier) newRcvr						local.get $newRcvr						i32.ne						i32.const 0						i32.ne						(if (then;; (BlockStatement) an active DebuggerStatement with propert...;; (DebuggerStatement) an active DebuggerStatement with propert...;; (ThrowStatement) throw Error('receivers don''t match')						unreachable));; (IfStatement) if (!newMethod.compiled && this.compiler...;; (BinaryExpression) !newMethod.compiled && this.compiler && ...;; (BinaryExpression) !newMethod.compiled && this.compiler;; (UnaryExpression) !newMethod.compiled;; (StaticMemberExpression) newMethod.compiled;; (JSIdentifier) compiled						local.get $compiled						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (StaticMemberExpression) this.compiler;; (JSIdentifier) compiler						local.get $compiler						i32.and;; (UnaryExpression) !this.method === this.specialObjects[Squ...;; (BinaryExpression) this.method === this.specialObjects[Sque...;; (StaticMemberExpression) this.method;; (JSIdentifier) method						local.get $method;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_Reloadi...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ReloadingMethod;; (JSIdentifier) splOb_ReloadingMethod						local.get $splOb_ReloadingMethod						i32.const 4						i32.mul						i32.add						i32.eq						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.and						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.compiler.compile(newMethod, optClas...;; (CallExpression) this.compiler.compile(newMethod, optClas...						local.get $compiler;; (JSIdentifier) newMethod						local.get $newMethod;; (JSIdentifier) optClass						local.get $optClass;; (JSIdentifier) optSel						local.get $optSel						call $compile));; (IfStatement) if (this.interruptCheckCounter-- <= 0) {...;; (BinaryExpression) this.interruptCheckCounter-- <= 0;; (UpdateExpression) this.interruptCheckCounter--;; (StaticMemberExpression) this.interruptCheckCounter;; (JSIdentifier) interruptCheckCounter						local.get $interruptCheckCounter						i32.const 1						i32.sub;; (JSLiteral) 0						i32.const 0						i32.le_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.checkForInterrupts();; (CallExpression) this.checkForInterrupts()						local.get $this						call $checkForInterrupts)));; (JSProperty) property: doReturn -> function(returnVal...;; (FunctionExpression) function(returnValue, targetContext) { 	...(func $doReturn						(local $nextContext i32)						(local $returnValue i32)						(local $ctx i32)						(local $targetContext i32)						(local $closure i32)						(local $thisContext i32)						(local $temp i32)						;; (IfStatement) if (!targetContext) {var ctx = this.home...;; (UnaryExpression) !targetContext;; (JSIdentifier) targetContext						local.get $targetContext						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) var ctx = this.homeContext if (this.hasC...;; (VariableDeclaration) var ctx = this.homeContext;; (VariableDeclarator) ctx = this.homeContext;; (StaticMemberExpression) this.homeContext;; (JSIdentifier) homeContext						local.get $homeContext						local.set $ctx;; (IfStatement) if (this.hasClosures) {var closure while...;; (StaticMemberExpression) this.hasClosures;; (JSIdentifier) hasClosures						local.get $hasClosures						i32.const 0						i32.ne						(if (then;; (BlockStatement) var closure while (!closure = ctx.pointe...;; (VariableDeclaration) var closure;; (VariableDeclarator) closure;; (WhileStatement) while (!closure = ctx.pointers[Squeak.Co...						(loop $loop_1;; (ExpressionStatement) ctx = closure.pointers[Squeak.Closure_ou...;; (AssignmentExpression) ctx = closure.pointers[Squeak.Closure_ou...;; (ComputedMemberExpression) closure.pointers[Squeak.Closure_outerCon...;; (StaticMemberExpression) closure.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Closure_outerContext;; (JSIdentifier) Closure_outerContext						local.get $Closure_outerContext						i32.const 4						i32.mul						i32.add						local.set $ctx;; (UnaryExpression) !closure = ctx.pointers[Squeak.Context_c...;; (StaticMemberExpression) closure = ctx.pointers[Squeak.Context_cl...;; (JSIdentifier) isNil						local.get $isNil						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue)));; (ExpressionStatement) targetContext = ctx.pointers[Squeak.Cont...;; (AssignmentExpression) targetContext = ctx.pointers[Squeak.Cont...;; (ComputedMemberExpression) ctx.pointers[Squeak.Context_sender];; (StaticMemberExpression) ctx.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_sender;; (JSIdentifier) Context_sender						local.get $Context_sender						i32.const 4						i32.mul						i32.add						local.set $targetContext));; (IfStatement) if (targetContext.isNil || targetContext...;; (BinaryExpression) targetContext.isNil || targetContext.poi...;; (StaticMemberExpression) targetContext.isNil;; (JSIdentifier) isNil						local.get $isNil;; (StaticMemberExpression) targetContext.pointers[Squeak.Context_in...;; (JSIdentifier) isNil						local.get $isNil						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.cannotReturn(returnValue);; (CallExpression) this.cannotReturn(returnValue)						local.get $this;; (JSIdentifier) returnValue						local.get $returnValue						call $cannotReturn						return));; (WhileStatement) while (thisContext !== targetContext) {i...						(loop $loop_2;; (BlockStatement) if (thisContext.isNil) {return this.cann...;; (IfStatement) if (thisContext.isNil) {return this.cann...;; (StaticMemberExpression) thisContext.isNil;; (JSIdentifier) isNil						local.get $isNil						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.cannotReturn(returnValue);; (CallExpression) this.cannotReturn(returnValue)						local.get $this;; (JSIdentifier) returnValue						local.get $returnValue						call $cannotReturn						return));; (IfStatement) if (this.isUnwindMarked(thisContext)) {r...;; (CallExpression) this.isUnwindMarked(thisContext)						local.get $this;; (JSIdentifier) thisContext						local.get $thisContext						call $isUnwindMarked						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.aboutToReturnThrough(returnV...;; (CallExpression) this.aboutToReturnThrough(returnValue, t...						local.get $this;; (JSIdentifier) returnValue						local.get $returnValue;; (JSIdentifier) thisContext						local.get $thisContext						call $aboutToReturnThrough						return));; (ExpressionStatement) thisContext = thisContext.pointers[Squea...;; (AssignmentExpression) thisContext = thisContext.pointers[Squea...;; (ComputedMemberExpression) thisContext.pointers[Squeak.Context_send...;; (StaticMemberExpression) thisContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_sender;; (JSIdentifier) Context_sender						local.get $Context_sender						i32.const 4						i32.mul						i32.add						local.set $thisContext;; (BinaryExpression) thisContext !== targetContext;; (JSIdentifier) thisContext						local.get $thisContext;; (JSIdentifier) targetContext						local.get $targetContext						i32.ne						i32.const 0						i32.eq						br_if $loop_2)						(block $loop_2_continue);; (ExpressionStatement) thisContext = this.activeContext;; (AssignmentExpression) thisContext = this.activeContext;; (StaticMemberExpression) this.activeContext;; (JSIdentifier) activeContext						local.get $activeContext						local.set $thisContext;; (WhileStatement) while (thisContext !== targetContext) {i...						(loop $loop_3;; (BlockStatement) if (this.breakOnContextReturned === this...;; (IfStatement) if (this.breakOnContextReturned === this...;; (BinaryExpression) this.breakOnContextReturned === thisCont...;; (StaticMemberExpression) this.breakOnContextReturned;; (JSIdentifier) breakOnContextReturned						local.get $breakOnContextReturned;; (JSIdentifier) thisContext						local.get $thisContext						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.breakOnContextReturned = nil this.b...;; (ExpressionStatement) this.breakOnContextReturned = nil;; (AssignmentExpression) this.breakOnContextReturned = nil;; (JSLiteral) nil						i32.const 0						local.set $breakOnContextReturned;; (ExpressionStatement) this.breakNow();; (CallExpression) this.breakNow()						local.get $this						call $breakNow));; (ExpressionStatement) nextContext = thisContext.pointers[Squea...;; (AssignmentExpression) nextContext = thisContext.pointers[Squea...;; (ComputedMemberExpression) thisContext.pointers[Squeak.Context_send...;; (StaticMemberExpression) thisContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_sender;; (JSIdentifier) Context_sender						local.get $Context_sender						i32.const 4						i32.mul						i32.add						local.set $nextContext;; (ExpressionStatement) thisContext.pointers[Squeak.Context_send...;; (AssignmentExpression) thisContext.pointers[Squeak.Context_send...						local.get $thisContext;; (StaticMemberExpression) Squeak.Context_sender;; (JSIdentifier) Context_sender						local.get $Context_sender;; (StaticMemberExpression) this.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut;; (ExpressionStatement) thisContext.pointers[Squeak.Context_inst...;; (AssignmentExpression) thisContext.pointers[Squeak.Context_inst...						local.get $thisContext;; (StaticMemberExpression) Squeak.Context_instructionPointer;; (JSIdentifier) Context_instructionPointer						local.get $Context_instructionPointer;; (StaticMemberExpression) this.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut;; (IfStatement) if (this.reclaimableContextCount > 0) {t...;; (BinaryExpression) this.reclaimableContextCount > 0;; (StaticMemberExpression) this.reclaimableContextCount;; (JSIdentifier) reclaimableContextCount						local.get $reclaimableContextCount;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.reclaimableContextCount-- this.recy...;; (ExpressionStatement) this.reclaimableContextCount--;; (UpdateExpression) this.reclaimableContextCount--;; (StaticMemberExpression) this.reclaimableContextCount;; (JSIdentifier) reclaimableContextCount						local.get $reclaimableContextCount						i32.const 1						i32.sub;; (ExpressionStatement) this.recycleIfPossible(thisContext);; (CallExpression) this.recycleIfPossible(thisContext)						local.get $this;; (JSIdentifier) thisContext						local.get $thisContext						call $recycleIfPossible));; (ExpressionStatement) thisContext = nextContext;; (AssignmentExpression) thisContext = nextContext;; (JSIdentifier) nextContext						local.get $nextContext						local.set $thisContext;; (BinaryExpression) thisContext !== targetContext;; (JSIdentifier) thisContext						local.get $thisContext;; (JSIdentifier) targetContext						local.get $targetContext						i32.ne						i32.const 0						i32.eq						br_if $loop_3)						(block $loop_3_continue);; (ExpressionStatement) this.activeContext = thisContext;; (AssignmentExpression) this.activeContext = thisContext;; (JSIdentifier) thisContext						local.get $thisContext						local.set $activeContext;; (ExpressionStatement) this.activeContext.dirty = true;; (AssignmentExpression) this.activeContext.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty;; (ExpressionStatement) this.fetchContextRegisters(this.activeCo...;; (CallExpression) this.fetchContextRegisters(this.activeCo...						local.get $this;; (StaticMemberExpression) this.activeContext;; (JSIdentifier) activeContext						local.get $activeContext						call $fetchContextRegisters;; (ExpressionStatement) this.push(returnValue);; (CallExpression) this.push(returnValue)						local.get $this;; (JSIdentifier) returnValue						local.get $returnValue						call $push;; (IfStatement) if (this.breakOnContextChanged) {this.br...;; (StaticMemberExpression) this.breakOnContextChanged;; (JSIdentifier) breakOnContextChanged						local.get $breakOnContextChanged						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.breakOnContextChanged = false this....;; (ExpressionStatement) this.breakOnContextChanged = false;; (AssignmentExpression) this.breakOnContextChanged = false;; (JSLiteral) false						i32.const 0						local.set $breakOnContextChanged;; (ExpressionStatement) this.breakNow();; (CallExpression) this.breakNow()						local.get $this						call $breakNow)));; (JSProperty) property: aboutToReturnThrough -> functi...;; (FunctionExpression) function(resultObj, aContext) { 	this.pu...(func $aboutToReturnThrough						(local $aContext i32)						(local $aboutToReturnSel i32)						(local $temp i32)						(local $resultObj i32)						;; (ExpressionStatement) this.push(this.exportThisContext());; (CallExpression) this.push(this.exportThisContext())						local.get $this;; (CallExpression) this.exportThisContext()						local.get $this						call $exportThisContext						call $push;; (ExpressionStatement) this.push(resultObj);; (CallExpression) this.push(resultObj)						local.get $this;; (JSIdentifier) resultObj						local.get $resultObj						call $push;; (ExpressionStatement) this.push(aContext);; (CallExpression) this.push(aContext)						local.get $this;; (JSIdentifier) aContext						local.get $aContext						call $push;; (ExpressionStatement) this.send(aboutToReturnSel, 2);; (CallExpression) this.send(aboutToReturnSel, 2)						local.get $this;; (JSIdentifier) aboutToReturnSel						local.get $aboutToReturnSel;; (JSLiteral) 2						i32.const 2						call $send);; (JSProperty) property: cannotReturn -> function(resul...;; (FunctionExpression) function(resultObj) { 	this.push(this.ex...(func $cannotReturn						(local $cannotReturnSel i32)						(local $temp i32)						(local $resultObj i32)						;; (ExpressionStatement) this.push(this.exportThisContext());; (CallExpression) this.push(this.exportThisContext())						local.get $this;; (CallExpression) this.exportThisContext()						local.get $this						call $exportThisContext						call $push;; (ExpressionStatement) this.push(resultObj);; (CallExpression) this.push(resultObj)						local.get $this;; (JSIdentifier) resultObj						local.get $resultObj						call $push;; (ExpressionStatement) this.send(cannotReturnSel, 1);; (CallExpression) this.send(cannotReturnSel, 1)						local.get $this;; (JSIdentifier) cannotReturnSel						local.get $cannotReturnSel;; (JSLiteral) 1						i32.const 1						call $send);; (JSProperty) property: tryPrimitive -> function(primI...;; (FunctionExpression) function(primIndex, argCount, newMethod)...(func $tryPrimitive						(local $primIndex i32)						(local $argCount i32)						(local $success i32)						(local $newMethod i32)						(local $temp i32)						;; (IfStatement) if (primIndex > 255 && primIndex < 520) ...;; (BinaryExpression) primIndex > 255 && primIndex < 520;; (BinaryExpression) primIndex > 255;; (JSIdentifier) primIndex						local.get $primIndex;; (JSLiteral) 255						i32.const 255						i32.gt_u;; (BinaryExpression) primIndex < 520;; (JSIdentifier) primIndex						local.get $primIndex;; (JSLiteral) 520						i32.const 520						i32.lt_u						i32.and						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (primIndex >= 264) {this.popNandPush(...;; (IfStatement) if (primIndex >= 264) {this.popNandPush(...;; (BinaryExpression) primIndex >= 264;; (JSIdentifier) primIndex						local.get $primIndex;; (JSLiteral) 264						i32.const 264						i32.ge_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.popNandPush(1, this.top().pointers[...;; (ExpressionStatement) this.popNandPush(1, this.top().pointers[...;; (CallExpression) this.popNandPush(1, this.top().pointers[...						local.get $this;; (JSLiteral) 1						i32.const 1;; (ComputedMemberExpression) this.top().pointers[primIndex - 264];; (StaticMemberExpression) this.top().pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) primIndex - 264;; (JSIdentifier) primIndex						local.get $primIndex;; (JSLiteral) 264						i32.const 264						i32.sub						i32.const 4						i32.mul						i32.add						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return));; (SwitchStatement) switch (primIndex) { case 256: return tr...primIndex						local.set $temp;; (SwitchCase)  case 256: return true						local.get $temp;; (JSLiteral) 256						i32.const 256						i32.eq						(if (then ;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return						));; (SwitchCase)  case 257: this.popNandPush(1, this.true...						local.get $temp;; (JSLiteral) 257						i32.const 257						i32.eq						(if (then ;; (ExpressionStatement) this.popNandPush(1, this.trueObj);; (CallExpression) this.popNandPush(1, this.trueObj)						local.get $this;; (JSLiteral) 1						i32.const 1;; (StaticMemberExpression) this.trueObj;; (JSIdentifier) trueObj						local.get $trueObj						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return						));; (SwitchCase)  case 258: this.popNandPush(1, this.fals...						local.get $temp;; (JSLiteral) 258						i32.const 258						i32.eq						(if (then ;; (ExpressionStatement) this.popNandPush(1, this.falseObj);; (CallExpression) this.popNandPush(1, this.falseObj)						local.get $this;; (JSLiteral) 1						i32.const 1;; (StaticMemberExpression) this.falseObj;; (JSIdentifier) falseObj						local.get $falseObj						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return						));; (SwitchCase)  case 259: this.popNandPush(1, this.nilO...						local.get $temp;; (JSLiteral) 259						i32.const 259						i32.eq						(if (then ;; (ExpressionStatement) this.popNandPush(1, this.nilObj);; (CallExpression) this.popNandPush(1, this.nilObj)						local.get $this;; (JSLiteral) 1						i32.const 1;; (StaticMemberExpression) this.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return						));; (ExpressionStatement) this.popNandPush(1, primIndex - 261);; (CallExpression) this.popNandPush(1, primIndex - 261)						local.get $this;; (JSLiteral) 1						i32.const 1;; (BinaryExpression) primIndex - 261;; (JSIdentifier) primIndex						local.get $primIndex;; (JSLiteral) 261						i32.const 261						i32.sub						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return));; (ReturnStatement) return success;; (JSIdentifier) success						local.get $success						return);; (JSProperty) property: createActualMessage -> functio...;; (FunctionExpression) function(selector, argCount, cls) { 	var...(func $createActualMessage						(local $message i32)						(local $selector i32)						(local $cls i32)						(local $argCount i32)						(local $argArray i32)						(local $temp i32)						;; (ExpressionStatement) this.arrayCopy(this.activeContext.pointe...;; (CallExpression) this.arrayCopy(this.activeContext.pointe...						local.get $this;; (StaticMemberExpression) this.activeContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) this.sp - argCount + 1;; (BinaryExpression) this.sp - argCount;; (StaticMemberExpression) this.sp;; (JSIdentifier) sp						local.get $sp;; (JSIdentifier) argCount						local.get $argCount						i32.sub;; (JSLiteral) 1						i32.const 1						i32.add;; (StaticMemberExpression) argArray.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0;; (JSIdentifier) argCount						local.get $argCount						call $arrayCopy;; (ExpressionStatement) message.pointers[Squeak.Message_selector...;; (AssignmentExpression) message.pointers[Squeak.Message_selector...						local.get $message;; (StaticMemberExpression) Squeak.Message_selector;; (JSIdentifier) Message_selector						local.get $Message_selector;; (JSIdentifier) selector						local.get $selector						call $atPut;; (ExpressionStatement) message.pointers[Squeak.Message_argument...;; (AssignmentExpression) message.pointers[Squeak.Message_argument...						local.get $message;; (StaticMemberExpression) Squeak.Message_arguments;; (JSIdentifier) Message_arguments						local.get $Message_arguments;; (JSIdentifier) argArray						local.get $argArray						call $atPut;; (IfStatement) if (message.pointers.length > Squeak.Mes...;; (BinaryExpression) message.pointers.length > Squeak.Message...;; (StaticMemberExpression) message.pointers.length;; (JSIdentifier) length						local.get $length;; (StaticMemberExpression) Squeak.Message_lookupClass;; (JSIdentifier) Message_lookupClass						local.get $Message_lookupClass						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) message.pointers[Squeak.Message_lookupCl...;; (AssignmentExpression) message.pointers[Squeak.Message_lookupCl...						local.get $message;; (StaticMemberExpression) Squeak.Message_lookupClass;; (JSIdentifier) Message_lookupClass						local.get $Message_lookupClass;; (JSIdentifier) cls						local.get $cls						call $atPut));; (ReturnStatement) return message;; (JSIdentifier) message						local.get $message						return);; (JSProperty) property: primitivePerform -> function(a...;; (FunctionExpression) function(argCount) { 	var selector = thi...(func $primitivePerform						(local $trueArgCount i32)						(local $rcvr i32)						(local $selector i32)						(local $argCount i32)						(local $temp i32)						(local $selectorIndex i32)						(local $entry i32)						(local $stack i32)						;; (ExpressionStatement) this.activeContext.performSelector = sel...;; (AssignmentExpression) this.activeContext.performSelector = sel...;; (JSIdentifier) selector						local.get $selector						local.set $performSelector;; (ExpressionStatement) this.arrayCopy(stack, selectorIndex + 1,...;; (CallExpression) this.arrayCopy(stack, selectorIndex + 1,...						local.get $this;; (JSIdentifier) stack						local.get $stack;; (BinaryExpression) selectorIndex + 1;; (JSIdentifier) selectorIndex						local.get $selectorIndex;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) stack						local.get $stack;; (JSIdentifier) selectorIndex						local.get $selectorIndex;; (JSIdentifier) trueArgCount						local.get $trueArgCount						call $arrayCopy;; (ExpressionStatement) this.sp--;; (UpdateExpression) this.sp--;; (StaticMemberExpression) this.sp;; (JSIdentifier) sp						local.get $sp						i32.const 1						i32.sub;; (ExpressionStatement) this.executeNewMethod(rcvr, entry.method...;; (CallExpression) this.executeNewMethod(rcvr, entry.method...						local.get $this;; (JSIdentifier) rcvr						local.get $rcvr;; (StaticMemberExpression) entry.method;; (JSIdentifier) method						local.get $method;; (StaticMemberExpression) entry.argCount;; (JSIdentifier) argCount						local.get $argCount;; (StaticMemberExpression) entry.primIndex;; (JSIdentifier) primIndex						local.get $primIndex;; (StaticMemberExpression) entry.mClass;; (JSIdentifier) mClass						local.get $mClass;; (JSIdentifier) selector						local.get $selector						call $executeNewMethod;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitivePerformWithArgs -> fu...;; (FunctionExpression) function(argCount, supered) { 	var rcvr ...(func $primitivePerformWithArgs						(local $stack i32)						(local $temp i32)						(local $supered i32)						(local $rcvr i32)						(local $cls i32)						(local $selector i32)						(local $argCount i32)						(local $trueArgCount i32)						(local $lookupClass i32)						(local $args i32)						(local $startingStackPositionOfArguments i32)						(local $entry i32)						;; (IfStatement) if (args.sqClass !== this.specialObjects...;; (BinaryExpression) args.sqClass !== this.specialObjects[Squ...;; (StaticMemberExpression) args.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_ClassAr...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassArray;; (JSIdentifier) splOb_ClassArray						local.get $splOb_ClassArray						i32.const 4						i32.mul						i32.add						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (supered) {var cls = this.getClass(rc...;; (JSIdentifier) supered						local.get $supered						i32.const 0						i32.ne						(if (then;; (BlockStatement) var cls = this.getClass(rcvr) while (cls...;; (VariableDeclaration) var cls = this.getClass(rcvr);; (VariableDeclarator) cls = this.getClass(rcvr);; (CallExpression) this.getClass(rcvr)						local.get $this;; (JSIdentifier) rcvr						local.get $rcvr						call $getClass						local.set $cls;; (WhileStatement) while (cls !== lookupClass) {cls = cls.p...						(loop $loop_1;; (BlockStatement) cls = cls.pointers[Squeak.Class_supercla...;; (ExpressionStatement) cls = cls.pointers[Squeak.Class_supercla...;; (AssignmentExpression) cls = cls.pointers[Squeak.Class_supercla...;; (ComputedMemberExpression) cls.pointers[Squeak.Class_superclass];; (StaticMemberExpression) cls.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Class_superclass;; (JSIdentifier) Class_superclass						local.get $Class_superclass						i32.const 4						i32.mul						i32.add						local.set $cls;; (IfStatement) if (cls.isNil) {return false};; (StaticMemberExpression) cls.isNil;; (JSIdentifier) isNil						local.get $isNil						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (BinaryExpression) cls !== lookupClass;; (JSIdentifier) cls						local.get $cls;; (JSIdentifier) lookupClass						local.get $lookupClass						i32.ne						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue)));; (IfStatement) if (supered) {startingStackPositionOfArg...;; (JSIdentifier) supered						local.get $supered						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) startingStackPositionOfArguments = this....;; (AssignmentExpression) startingStackPositionOfArguments = this....;; (BinaryExpression) this.sp - 2;; (StaticMemberExpression) this.sp;; (JSIdentifier) sp						local.get $sp;; (JSLiteral) 2						i32.const 2						i32.sub						local.set $startingStackPositionOfArguments)						(else;; (ExpressionStatement) startingStackPositionOfArguments = this....;; (AssignmentExpression) startingStackPositionOfArguments = this....;; (BinaryExpression) this.sp - 1;; (StaticMemberExpression) this.sp;; (JSIdentifier) sp						local.get $sp;; (JSLiteral) 1						i32.const 1						i32.sub						local.set $startingStackPositionOfArguments));; (ExpressionStatement) this.arrayCopy(args.pointers, 0, stack, ...;; (CallExpression) this.arrayCopy(args.pointers, 0, stack, ...						local.get $this;; (StaticMemberExpression) args.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0;; (JSIdentifier) stack						local.get $stack;; (JSIdentifier) startingStackPositionOfArguments						local.get $startingStackPositionOfArguments;; (JSIdentifier) trueArgCount						local.get $trueArgCount						call $arrayCopy;; (ExpressionStatement) this.sp += trueArgCount - argCount;; (AssignmentExpression) this.sp += trueArgCount - argCount;; (StaticMemberExpression) this.sp;; (JSIdentifier) sp						local.get $sp;; (BinaryExpression) trueArgCount - argCount;; (JSIdentifier) trueArgCount						local.get $trueArgCount;; (JSIdentifier) argCount						local.get $argCount						i32.sub						i32.add						local.set $sp;; (ExpressionStatement) this.activeContext.performSelector = sel...;; (AssignmentExpression) this.activeContext.performSelector = sel...;; (JSIdentifier) selector						local.get $selector						local.set $performSelector;; (ExpressionStatement) this.executeNewMethod(rcvr, entry.method...;; (CallExpression) this.executeNewMethod(rcvr, entry.method...						local.get $this;; (JSIdentifier) rcvr						local.get $rcvr;; (StaticMemberExpression) entry.method;; (JSIdentifier) method						local.get $method;; (StaticMemberExpression) entry.argCount;; (JSIdentifier) argCount						local.get $argCount;; (StaticMemberExpression) entry.primIndex;; (JSIdentifier) primIndex						local.get $primIndex;; (StaticMemberExpression) entry.mClass;; (JSIdentifier) mClass						local.get $mClass;; (JSIdentifier) selector						local.get $selector						call $executeNewMethod;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveInvokeObjectAsMethod ...;; (FunctionExpression) function(argCount, method) { 	var orgArg...(func $primitiveInvokeObjectAsMethod						(local $orgReceiver i32)						(local $orgSelector i32)						(local $orgArgs i32)						(local $i i32)						(local $method i32)						(local $argCount i32)						(local $runWithIn i32)						(local $temp i32)						;; (ForStatement) for (var i = 0; i < argCount; i++) {orgA...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) orgArgs.pointers[argCount - i - 1] = thi...;; (AssignmentExpression) orgArgs.pointers[argCount - i - 1] = thi...						local.get $orgArgs;; (BinaryExpression) argCount - i - 1;; (BinaryExpression) argCount - i;; (JSIdentifier) argCount						local.get $argCount;; (JSIdentifier) i						local.get $i						i32.sub;; (JSLiteral) 1						i32.const 1						i32.sub;; (CallExpression) this.pop()						local.get $this						call $pop						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < argCount;; (JSIdentifier) i						local.get $i;; (JSIdentifier) argCount						local.get $argCount						i32.lt_u						i32.const 0						br_if $loop_1);; (ExpressionStatement) this.push(method);; (CallExpression) this.push(method)						local.get $this;; (JSIdentifier) method						local.get $method						call $push;; (ExpressionStatement) this.push(orgSelector);; (CallExpression) this.push(orgSelector)						local.get $this;; (JSIdentifier) orgSelector						local.get $orgSelector						call $push;; (ExpressionStatement) this.push(orgArgs);; (CallExpression) this.push(orgArgs)						local.get $this;; (JSIdentifier) orgArgs						local.get $orgArgs						call $push;; (ExpressionStatement) this.push(orgReceiver);; (CallExpression) this.push(orgReceiver)						local.get $this;; (JSIdentifier) orgReceiver						local.get $orgReceiver						call $push;; (ExpressionStatement) this.send(runWithIn, 3, false);; (CallExpression) this.send(runWithIn, 3, false)						local.get $this;; (JSIdentifier) runWithIn						local.get $runWithIn;; (JSLiteral) 3						i32.const 3;; (JSLiteral) false						i32.const 0						call $send;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: findMethodCacheEntry -> functi...;; (FunctionExpression) function(selector, lkupClass) { 	var ent...(func $findMethodCacheEntry						(local $lkupClass i32)						(local $probe i32)						(local $selector i32)						(local $i i32)						(local $temp i32)						(local $entry i32)						(local $firstProbe i32)						;; (ExpressionStatement) this.methodCacheRandomish = this.methodC...;; (AssignmentExpression) this.methodCacheRandomish = this.methodC...;; (BinaryExpression) this.methodCacheRandomish + 1 & 3;; (BinaryExpression) this.methodCacheRandomish + 1;; (StaticMemberExpression) this.methodCacheRandomish;; (JSIdentifier) methodCacheRandomish						local.get $methodCacheRandomish;; (JSLiteral) 1						i32.const 1						i32.add;; (JSLiteral) 3						i32.const 3						i32.and						local.set $methodCacheRandomish;; (ForStatement) for (var i = 0; i < 4; i++) {entry = thi...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (BlockStatement) entry = this.methodCache[probe] if (entr...;; (ExpressionStatement) entry = this.methodCache[probe];; (AssignmentExpression) entry = this.methodCache[probe];; (ComputedMemberExpression) this.methodCache[probe];; (StaticMemberExpression) this.methodCache;; (JSIdentifier) methodCache						local.get $methodCache;; (JSIdentifier) probe						local.get $probe						i32.const 4						i32.mul						i32.add						local.set $entry;; (IfStatement) if (entry.selector === selector && entry...;; (BinaryExpression) entry.selector === selector && entry.lku...;; (BinaryExpression) entry.selector === selector;; (StaticMemberExpression) entry.selector;; (JSIdentifier) selector						local.get $selector;; (JSIdentifier) selector						local.get $selector						i32.eq;; (BinaryExpression) entry.lkupClass === lkupClass;; (StaticMemberExpression) entry.lkupClass;; (JSIdentifier) lkupClass						local.get $lkupClass;; (JSIdentifier) lkupClass						local.get $lkupClass						i32.eq						i32.and						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return entry;; (JSIdentifier) entry						local.get $entry						return));; (IfStatement) if (i === this.methodCacheRandomish) {fi...;; (BinaryExpression) i === this.methodCacheRandomish;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) this.methodCacheRandomish;; (JSIdentifier) methodCacheRandomish						local.get $methodCacheRandomish						i32.eq						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) firstProbe = probe;; (AssignmentExpression) firstProbe = probe;; (JSIdentifier) probe						local.get $probe						local.set $firstProbe));; (ExpressionStatement) probe = probe + selector.hash & this.met...;; (AssignmentExpression) probe = probe + selector.hash & this.met...;; (BinaryExpression) probe + selector.hash & this.methodCache...;; (BinaryExpression) probe + selector.hash;; (JSIdentifier) probe						local.get $probe;; (StaticMemberExpression) selector.hash;; (JSIdentifier) hash						local.get $hash						i32.add;; (StaticMemberExpression) this.methodCacheMask;; (JSIdentifier) methodCacheMask						local.get $methodCacheMask						i32.and						local.set $probe;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.lt_u						i32.const 0						br_if $loop_1);; (ExpressionStatement) entry = this.methodCache[firstProbe];; (AssignmentExpression) entry = this.methodCache[firstProbe];; (ComputedMemberExpression) this.methodCache[firstProbe];; (StaticMemberExpression) this.methodCache;; (JSIdentifier) methodCache						local.get $methodCache;; (JSIdentifier) firstProbe						local.get $firstProbe						i32.const 4						i32.mul						i32.add						local.set $entry;; (ExpressionStatement) entry.lkupClass = lkupClass;; (AssignmentExpression) entry.lkupClass = lkupClass;; (JSIdentifier) lkupClass						local.get $lkupClass						local.set $lkupClass;; (ExpressionStatement) entry.selector = selector;; (AssignmentExpression) entry.selector = selector;; (JSIdentifier) selector						local.get $selector						local.set $selector;; (ExpressionStatement) entry.method = nil;; (AssignmentExpression) entry.method = nil;; (JSLiteral) nil						i32.const 0						local.set $method;; (ReturnStatement) return entry;; (JSIdentifier) entry						local.get $entry						return);; (JSProperty) property: flushMethodCache -> function()...;; (FunctionExpression) function() { 	for (var i = 0; i < this.m...(func $flushMethodCache						(local $temp i32)						(local $i i32)						;; (ForStatement) for (var i = 0; i < this.methodCacheSize...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (BlockStatement) this.methodCache[i].selector = nil this....;; (ExpressionStatement) this.methodCache[i].selector = nil;; (AssignmentExpression) this.methodCache[i].selector = nil						local.get $this.methodCache[i];; (JSIdentifier) selector						local.get $selector;; (JSLiteral) nil						i32.const 0						call $atPut;; (ExpressionStatement) this.methodCache[i].method = nil;; (AssignmentExpression) this.methodCache[i].method = nil						local.get $this.methodCache[i];; (JSIdentifier) method						local.get $method;; (JSLiteral) nil						i32.const 0						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < this.methodCacheSize;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) this.methodCacheSize;; (JSIdentifier) methodCacheSize						local.get $methodCacheSize						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: flushMethodCacheForSelector ->...;; (FunctionExpression) function(selector) { 	for (var i = 0; i ...(func $flushMethodCacheForSelector						(local $i i32)						(local $temp i32)						(local $selector i32)						;; (ForStatement) for (var i = 0; i < this.methodCacheSize...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (IfStatement) if (this.methodCache[i].selector === sel...;; (BinaryExpression) this.methodCache[i].selector === selecto...;; (StaticMemberExpression) this.methodCache[i].selector;; (JSIdentifier) selector						local.get $selector;; (JSIdentifier) selector						local.get $selector						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.methodCache[i].selector = nil this....;; (ExpressionStatement) this.methodCache[i].selector = nil;; (AssignmentExpression) this.methodCache[i].selector = nil						local.get $this.methodCache[i];; (JSIdentifier) selector						local.get $selector;; (JSLiteral) nil						i32.const 0						call $atPut;; (ExpressionStatement) this.methodCache[i].method = nil;; (AssignmentExpression) this.methodCache[i].method = nil						local.get $this.methodCache[i];; (JSIdentifier) method						local.get $method;; (JSLiteral) nil						i32.const 0						call $atPut));; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < this.methodCacheSize;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) this.methodCacheSize;; (JSIdentifier) methodCacheSize						local.get $methodCacheSize						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: flushMethodCacheForMethod -> f...;; (FunctionExpression) function(method) { 	for (var i = 0; i < ...(func $flushMethodCacheForMethod						(local $i i32)						(local $temp i32)						(local $method i32)						;; (ForStatement) for (var i = 0; i < this.methodCacheSize...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (IfStatement) if (this.methodCache[i].method === metho...;; (BinaryExpression) this.methodCache[i].method === method;; (StaticMemberExpression) this.methodCache[i].method;; (JSIdentifier) method						local.get $method;; (JSIdentifier) method						local.get $method						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.methodCache[i].selector = nil this....;; (ExpressionStatement) this.methodCache[i].selector = nil;; (AssignmentExpression) this.methodCache[i].selector = nil						local.get $this.methodCache[i];; (JSIdentifier) selector						local.get $selector;; (JSLiteral) nil						i32.const 0						call $atPut;; (ExpressionStatement) this.methodCache[i].method = nil;; (AssignmentExpression) this.methodCache[i].method = nil						local.get $this.methodCache[i];; (JSIdentifier) method						local.get $method;; (JSLiteral) nil						i32.const 0						call $atPut));; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < this.methodCacheSize;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) this.methodCacheSize;; (JSIdentifier) methodCacheSize						local.get $methodCacheSize						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: flushMethodCacheAfterBecome ->...;; (FunctionExpression) function(mutations) { 	this.flushMethodC...(func $flushMethodCacheAfterBecome						(local $mutations i32)						(local $temp i32)						;; (ExpressionStatement) this.flushMethodCache();; (CallExpression) this.flushMethodCache()						local.get $this						call $flushMethodCache);; (JSProperty) property: isUnwindMarked -> function(ctx...;; (FunctionExpression) function(ctx) { 	if (!this.isMethodConte...(func $isUnwindMarked						(local $temp i32)						(local $ctx i32)						(local $method i32)						;; (IfStatement) if (!this.isMethodContext(ctx)) {return ...;; (UnaryExpression) !this.isMethodContext(ctx);; (CallExpression) this.isMethodContext(ctx)						local.get $this;; (JSIdentifier) ctx						local.get $ctx						call $isMethodContext						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ReturnStatement) return method.methodPrimitiveIndex() == ...;; (BinaryExpression) method.methodPrimitiveIndex() == 198;; (CallExpression) method.methodPrimitiveIndex()						local.get $method						call $methodPrimitiveIndex;; (JSLiteral) 198						i32.const 198						i32.eq						return);; (JSProperty) property: newActiveContext -> function(n...;; (FunctionExpression) function(newContext) { 	this.storeContex...(func $newActiveContext						(local $newContext i32)						(local $temp i32)						;; (ExpressionStatement) this.storeContextRegisters();; (CallExpression) this.storeContextRegisters()						local.get $this						call $storeContextRegisters;; (ExpressionStatement) this.activeContext = newContext;; (AssignmentExpression) this.activeContext = newContext;; (JSIdentifier) newContext						local.get $newContext						local.set $activeContext;; (ExpressionStatement) this.activeContext.dirty = true;; (AssignmentExpression) this.activeContext.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty;; (ExpressionStatement) this.fetchContextRegisters(newContext);; (CallExpression) this.fetchContextRegisters(newContext)						local.get $this;; (JSIdentifier) newContext						local.get $newContext						call $fetchContextRegisters);; (JSProperty) property: exportThisContext -> function(...;; (FunctionExpression) function() { 	this.storeContextRegisters...(func $exportThisContext						(local $temp i32)						;; (ExpressionStatement) this.storeContextRegisters();; (CallExpression) this.storeContextRegisters()						local.get $this						call $storeContextRegisters;; (ExpressionStatement) this.reclaimableContextCount = 0;; (AssignmentExpression) this.reclaimableContextCount = 0;; (JSLiteral) 0						i32.const 0						local.set $reclaimableContextCount;; (ReturnStatement) return this.activeContext;; (StaticMemberExpression) this.activeContext;; (JSIdentifier) activeContext						local.get $activeContext						return);; (JSProperty) property: fetchContextRegisters -> funct...;; (FunctionExpression) function(ctxt) { 	var meth = ctxt.pointe...(func $fetchContextRegisters						(local $meth i32)						(local $ctxt i32)						(local $temp i32)						;; (IfStatement) if (this.isSmallInt(meth)) {this.homeCon...;; (CallExpression) this.isSmallInt(meth)						local.get $this;; (JSIdentifier) meth						local.get $meth						call $isSmallInt						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.homeContext = ctxt.pointers[Squeak....;; (ExpressionStatement) this.homeContext = ctxt.pointers[Squeak....;; (AssignmentExpression) this.homeContext = ctxt.pointers[Squeak....;; (ComputedMemberExpression) ctxt.pointers[Squeak.BlockContext_home];; (StaticMemberExpression) ctxt.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.BlockContext_home;; (JSIdentifier) BlockContext_home						local.get $BlockContext_home						i32.const 4						i32.mul						i32.add						local.set $homeContext;; (ExpressionStatement) meth = this.homeContext.pointers[Squeak....;; (AssignmentExpression) meth = this.homeContext.pointers[Squeak....;; (ComputedMemberExpression) this.homeContext.pointers[Squeak.Context...;; (StaticMemberExpression) this.homeContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_method;; (JSIdentifier) Context_method						local.get $Context_method						i32.const 4						i32.mul						i32.add						local.set $meth)						(else;; (BlockStatement) this.homeContext = ctxt ;; (ExpressionStatement) this.homeContext = ctxt;; (AssignmentExpression) this.homeContext = ctxt;; (JSIdentifier) ctxt						local.get $ctxt						local.set $homeContext));; (ExpressionStatement) this.receiver = this.homeContext.pointer...;; (AssignmentExpression) this.receiver = this.homeContext.pointer...;; (ComputedMemberExpression) this.homeContext.pointers[Squeak.Context...;; (StaticMemberExpression) this.homeContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_receiver;; (JSIdentifier) Context_receiver						local.get $Context_receiver						i32.const 4						i32.mul						i32.add						local.set $receiver;; (ExpressionStatement) this.method = meth;; (AssignmentExpression) this.method = meth;; (JSIdentifier) meth						local.get $meth						local.set $method;; (ExpressionStatement) this.pc = this.decodeSqueakPC(ctxt.point...;; (AssignmentExpression) this.pc = this.decodeSqueakPC(ctxt.point...;; (CallExpression) this.decodeSqueakPC(ctxt.pointers[Squeak...						local.get $this;; (ComputedMemberExpression) ctxt.pointers[Squeak.Context_instruction...;; (StaticMemberExpression) ctxt.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_instructionPointer;; (JSIdentifier) Context_instructionPointer						local.get $Context_instructionPointer						i32.const 4						i32.mul						i32.add;; (JSIdentifier) meth						local.get $meth						call $decodeSqueakPC						local.set $pc;; (ExpressionStatement) this.sp = this.decodeSqueakSP(ctxt.point...;; (AssignmentExpression) this.sp = this.decodeSqueakSP(ctxt.point...;; (CallExpression) this.decodeSqueakSP(ctxt.pointers[Squeak...						local.get $this;; (ComputedMemberExpression) ctxt.pointers[Squeak.Context_stackPointe...;; (StaticMemberExpression) ctxt.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_stackPointer;; (JSIdentifier) Context_stackPointer						local.get $Context_stackPointer						i32.const 4						i32.mul						i32.add						call $decodeSqueakSP						local.set $sp);; (JSProperty) property: storeContextRegisters -> funct...;; (FunctionExpression) function() { 	this.activeContext.pointer...(func $storeContextRegisters						(local $temp i32)						;; (ExpressionStatement) this.activeContext.pointers[Squeak.Conte...;; (AssignmentExpression) this.activeContext.pointers[Squeak.Conte...						local.get $this.activeContext;; (StaticMemberExpression) Squeak.Context_instructionPointer;; (JSIdentifier) Context_instructionPointer						local.get $Context_instructionPointer;; (CallExpression) this.encodeSqueakPC(this.pc, this.method...						local.get $this;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc;; (StaticMemberExpression) this.method;; (JSIdentifier) method						local.get $method						call $encodeSqueakPC						call $atPut;; (ExpressionStatement) this.activeContext.pointers[Squeak.Conte...;; (AssignmentExpression) this.activeContext.pointers[Squeak.Conte...						local.get $this.activeContext;; (StaticMemberExpression) Squeak.Context_stackPointer;; (JSIdentifier) Context_stackPointer						local.get $Context_stackPointer;; (CallExpression) this.encodeSqueakSP(this.sp)						local.get $this;; (StaticMemberExpression) this.sp;; (JSIdentifier) sp						local.get $sp						call $encodeSqueakSP						call $atPut);; (JSProperty) property: encodeSqueakPC -> function(int...;; (FunctionExpression) function(intPC, method) { 	return intPC ...(func $encodeSqueakPC						(local $temp i32)						(local $intPC i32)						(local $method i32)						;; (ReturnStatement) return intPC + method.pointers.length * ...;; (BinaryExpression) intPC + method.pointers.length * 4 + 1;; (BinaryExpression) intPC + method.pointers.length * 4;; (JSIdentifier) intPC						local.get $intPC;; (BinaryExpression) method.pointers.length * 4;; (StaticMemberExpression) method.pointers.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 4						i32.const 4						i32.mul						i32.add;; (JSLiteral) 1						i32.const 1						i32.add						return);; (JSProperty) property: decodeSqueakPC -> function(squ...;; (FunctionExpression) function(squeakPC, method) { 	if (method...(func $decodeSqueakPC						(local $temp i32)						(local $squeakPC i32)						(local $method i32)						;; (IfStatement) if (method === this.nilObj) {an active D...;; (BinaryExpression) method === this.nilObj;; (JSIdentifier) method						local.get $method;; (StaticMemberExpression) this.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) an active DebuggerStatement with propert...;; (DebuggerStatement) an active DebuggerStatement with propert...));; (ReturnStatement) return squeakPC - method.pointers.length...;; (BinaryExpression) squeakPC - method.pointers.length * 4 - ...;; (BinaryExpression) squeakPC - method.pointers.length * 4;; (JSIdentifier) squeakPC						local.get $squeakPC;; (BinaryExpression) method.pointers.length * 4;; (StaticMemberExpression) method.pointers.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 4						i32.const 4						i32.mul						i32.sub;; (JSLiteral) 1						i32.const 1						i32.sub						return);; (JSProperty) property: encodeSqueakSP -> function(int...;; (FunctionExpression) function(intSP) { 	return intSP - Squeak...(func $encodeSqueakSP						(local $intSP i32)						(local $temp i32)						;; (ReturnStatement) return intSP - Squeak.Context_tempFrameS...;; (BinaryExpression) intSP - Squeak.Context_tempFrameStart - ...;; (JSIdentifier) intSP						local.get $intSP;; (BinaryExpression) Squeak.Context_tempFrameStart - 1;; (StaticMemberExpression) Squeak.Context_tempFrameStart;; (JSIdentifier) Context_tempFrameStart						local.get $Context_tempFrameStart;; (JSLiteral) 1						i32.const 1						i32.sub						i32.sub						return);; (JSProperty) property: decodeSqueakSP -> function(squ...;; (FunctionExpression) function(squeakSP) { 	return squeakSP + ...(func $decodeSqueakSP						(local $squeakSP i32)						(local $temp i32)						;; (ReturnStatement) return squeakSP + Squeak.Context_tempFra...;; (BinaryExpression) squeakSP + Squeak.Context_tempFrameStart...;; (JSIdentifier) squeakSP						local.get $squeakSP;; (BinaryExpression) Squeak.Context_tempFrameStart - 1;; (StaticMemberExpression) Squeak.Context_tempFrameStart;; (JSIdentifier) Context_tempFrameStart						local.get $Context_tempFrameStart;; (JSLiteral) 1						i32.const 1						i32.sub						i32.add						return);; (JSProperty) property: recycleIfPossible -> function(...;; (FunctionExpression) function(ctxt) { 	if (!this.isMethodCont...(func $recycleIfPossible						(local $ctxt i32)						(local $temp i32)						;; (IfStatement) if (!this.isMethodContext(ctxt)) {return...;; (UnaryExpression) !this.isMethodContext(ctxt);; (CallExpression) this.isMethodContext(ctxt)						local.get $this;; (JSIdentifier) ctxt						local.get $ctxt						call $isMethodContext						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 						return));; (IfStatement) if (ctxt.pointersSize() === Squeak.Conte...;; (BinaryExpression) ctxt.pointersSize() === Squeak.Context_t...;; (CallExpression) ctxt.pointersSize()						local.get $ctxt						call $pointersSize;; (BinaryExpression) Squeak.Context_tempFrameStart + Squeak.C...;; (StaticMemberExpression) Squeak.Context_tempFrameStart;; (JSIdentifier) Context_tempFrameStart						local.get $Context_tempFrameStart;; (StaticMemberExpression) Squeak.Context_smallFrameSize;; (JSIdentifier) Context_smallFrameSize						local.get $Context_smallFrameSize						i32.add						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) ctxt.pointers[0] = this.freeContexts thi...;; (ExpressionStatement) ctxt.pointers[0] = this.freeContexts;; (AssignmentExpression) ctxt.pointers[0] = this.freeContexts						local.get $ctxt;; (JSLiteral) 0						i32.const 0;; (StaticMemberExpression) this.freeContexts;; (JSIdentifier) freeContexts						local.get $freeContexts						call $atPut;; (ExpressionStatement) this.freeContexts = ctxt;; (AssignmentExpression) this.freeContexts = ctxt;; (JSIdentifier) ctxt						local.get $ctxt						local.set $freeContexts)						(else;; (BlockStatement) if (ctxt.pointersSize() !== Squeak.Conte...;; (IfStatement) if (ctxt.pointersSize() !== Squeak.Conte...;; (BinaryExpression) ctxt.pointersSize() !== Squeak.Context_t...;; (CallExpression) ctxt.pointersSize()						local.get $ctxt						call $pointersSize;; (BinaryExpression) Squeak.Context_tempFrameStart + Squeak.C...;; (StaticMemberExpression) Squeak.Context_tempFrameStart;; (JSIdentifier) Context_tempFrameStart						local.get $Context_tempFrameStart;; (StaticMemberExpression) Squeak.Context_largeFrameSize;; (JSIdentifier) Context_largeFrameSize						local.get $Context_largeFrameSize						i32.add						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 						return));; (ExpressionStatement) ctxt.pointers[0] = this.freeLargeContext...;; (AssignmentExpression) ctxt.pointers[0] = this.freeLargeContext...						local.get $ctxt;; (JSLiteral) 0						i32.const 0;; (StaticMemberExpression) this.freeLargeContexts;; (JSIdentifier) freeLargeContexts						local.get $freeLargeContexts						call $atPut;; (ExpressionStatement) this.freeLargeContexts = ctxt;; (AssignmentExpression) this.freeLargeContexts = ctxt;; (JSIdentifier) ctxt						local.get $ctxt						local.set $freeLargeContexts)));; (JSProperty) property: allocateOrRecycleContext -> fu...;; (FunctionExpression) function(needsLarge) { 	var freebie if (...(func $allocateOrRecycleContext						(local $needsLarge i32)						(local $freebie i32)						(local $temp i32)						;; (IfStatement) if (needsLarge) {if (!this.freeLargeCont...;; (JSIdentifier) needsLarge						local.get $needsLarge						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (!this.freeLargeContexts.isNil) {free...;; (IfStatement) if (!this.freeLargeContexts.isNil) {free...;; (UnaryExpression) !this.freeLargeContexts.isNil;; (StaticMemberExpression) this.freeLargeContexts.isNil;; (JSIdentifier) isNil						local.get $isNil						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) freebie = this.freeLargeContexts this.fr...;; (ExpressionStatement) freebie = this.freeLargeContexts;; (AssignmentExpression) freebie = this.freeLargeContexts;; (StaticMemberExpression) this.freeLargeContexts;; (JSIdentifier) freeLargeContexts						local.get $freeLargeContexts						local.set $freebie;; (ExpressionStatement) this.freeLargeContexts = freebie.pointer...;; (AssignmentExpression) this.freeLargeContexts = freebie.pointer...;; (ComputedMemberExpression) freebie.pointers[0];; (StaticMemberExpression) freebie.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add						local.set $freeLargeContexts;; (ExpressionStatement) this.nRecycledContexts++;; (UpdateExpression) this.nRecycledContexts++;; (StaticMemberExpression) this.nRecycledContexts;; (JSIdentifier) nRecycledContexts						local.get $nRecycledContexts						i32.const 1						i32.add;; (ReturnStatement) return freebie;; (JSIdentifier) freebie						local.get $freebie						return));; (ExpressionStatement) this.nAllocatedContexts++;; (UpdateExpression) this.nAllocatedContexts++;; (StaticMemberExpression) this.nAllocatedContexts;; (JSIdentifier) nAllocatedContexts						local.get $nAllocatedContexts						i32.const 1						i32.add;; (ReturnStatement) return this.instantiateClass(this.specia...;; (CallExpression) this.instantiateClass(this.specialObject...						local.get $this;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_ClassMe...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassMethodContext;; (JSIdentifier) splOb_ClassMethodContext						local.get $splOb_ClassMethodContext						i32.const 4						i32.mul						i32.add;; (StaticMemberExpression) Squeak.Context_largeFrameSize;; (JSIdentifier) Context_largeFrameSize						local.get $Context_largeFrameSize						call $instantiateClass						return)						(else;; (BlockStatement) if (!this.freeContexts.isNil) {freebie =...;; (IfStatement) if (!this.freeContexts.isNil) {freebie =...;; (UnaryExpression) !this.freeContexts.isNil;; (StaticMemberExpression) this.freeContexts.isNil;; (JSIdentifier) isNil						local.get $isNil						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) freebie = this.freeContexts this.freeCon...;; (ExpressionStatement) freebie = this.freeContexts;; (AssignmentExpression) freebie = this.freeContexts;; (StaticMemberExpression) this.freeContexts;; (JSIdentifier) freeContexts						local.get $freeContexts						local.set $freebie;; (ExpressionStatement) this.freeContexts = freebie.pointers[0];; (AssignmentExpression) this.freeContexts = freebie.pointers[0];; (ComputedMemberExpression) freebie.pointers[0];; (StaticMemberExpression) freebie.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add						local.set $freeContexts;; (ExpressionStatement) this.nRecycledContexts++;; (UpdateExpression) this.nRecycledContexts++;; (StaticMemberExpression) this.nRecycledContexts;; (JSIdentifier) nRecycledContexts						local.get $nRecycledContexts						i32.const 1						i32.add;; (ReturnStatement) return freebie;; (JSIdentifier) freebie						local.get $freebie						return));; (ExpressionStatement) this.nAllocatedContexts++;; (UpdateExpression) this.nAllocatedContexts++;; (StaticMemberExpression) this.nAllocatedContexts;; (JSIdentifier) nAllocatedContexts						local.get $nAllocatedContexts						i32.const 1						i32.add;; (ReturnStatement) return this.instantiateClass(this.specia...;; (CallExpression) this.instantiateClass(this.specialObject...						local.get $this;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_ClassMe...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassMethodContext;; (JSIdentifier) splOb_ClassMethodContext						local.get $splOb_ClassMethodContext						i32.const 4						i32.mul						i32.add;; (StaticMemberExpression) Squeak.Context_smallFrameSize;; (JSIdentifier) Context_smallFrameSize						local.get $Context_smallFrameSize						call $instantiateClass						return)));; (JSProperty) property: pop -> function() { 	return th...;; (FunctionExpression) function() { 	return this.activeContext....(func $pop						(local $temp i32)						;; (ReturnStatement) return this.activeContext.pointers[this....;; (ComputedMemberExpression) this.activeContext.pointers[this.sp--];; (StaticMemberExpression) this.activeContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (UpdateExpression) this.sp--;; (StaticMemberExpression) this.sp;; (JSIdentifier) sp						local.get $sp						i32.const 1						i32.sub						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: popN -> function(nToPop) { 	th...;; (FunctionExpression) function(nToPop) { 	this.sp -= nToPop }(func $popN						(local $nToPop i32)						(local $temp i32)						;; (ExpressionStatement) this.sp -= nToPop;; (AssignmentExpression) this.sp -= nToPop;; (StaticMemberExpression) this.sp;; (JSIdentifier) sp						local.get $sp;; (JSIdentifier) nToPop						local.get $nToPop						i32.sub						local.set $sp);; (JSProperty) property: push -> function(object) { 	th...;; (FunctionExpression) function(object) { 	this.activeContext.p...(func $push						(local $object i32)						(local $temp i32)						;; (ExpressionStatement) this.activeContext.pointers[++this.sp] =...;; (AssignmentExpression) this.activeContext.pointers[++this.sp] =...						local.get $this.activeContext;; (UpdateExpression) ++this.sp;; (StaticMemberExpression) this.sp;; (JSIdentifier) sp						local.get $sp						i32.const 1						i32.add;; (JSIdentifier) object						local.get $object						call $atPut);; (JSProperty) property: popNandPush -> function(nToPop...;; (FunctionExpression) function(nToPop, object) { 	this.activeC...(func $popNandPush						(local $nToPop i32)						(local $object i32)						(local $temp i32)						;; (ExpressionStatement) this.activeContext.pointers[this.sp -= n...;; (AssignmentExpression) this.activeContext.pointers[this.sp -= n...						local.get $this.activeContext;; (AssignmentExpression) this.sp -= nToPop - 1;; (StaticMemberExpression) this.sp;; (JSIdentifier) sp						local.get $sp;; (BinaryExpression) nToPop - 1;; (JSIdentifier) nToPop						local.get $nToPop;; (JSLiteral) 1						i32.const 1						i32.sub						i32.sub						local.set $sp;; (JSIdentifier) object						local.get $object						call $atPut);; (JSProperty) property: top -> function() { 	return th...;; (FunctionExpression) function() { 	return this.activeContext....(func $top						(local $temp i32)						;; (ReturnStatement) return this.activeContext.pointers[this....;; (ComputedMemberExpression) this.activeContext.pointers[this.sp];; (StaticMemberExpression) this.activeContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) this.sp;; (JSIdentifier) sp						local.get $sp						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: stackTopPut -> function(object...;; (FunctionExpression) function(object) { 	this.activeContext.p...(func $stackTopPut						(local $object i32)						(local $temp i32)						;; (ExpressionStatement) this.activeContext.pointers[this.sp] = o...;; (AssignmentExpression) this.activeContext.pointers[this.sp] = o...						local.get $this.activeContext;; (StaticMemberExpression) this.sp;; (JSIdentifier) sp						local.get $sp;; (JSIdentifier) object						local.get $object						call $atPut);; (JSProperty) property: stackValue -> function(depthIn...;; (FunctionExpression) function(depthIntoStack) { 	return this....(func $stackValue						(local $depthIntoStack i32)						(local $temp i32)						;; (ReturnStatement) return this.activeContext.pointers[this....;; (ComputedMemberExpression) this.activeContext.pointers[this.sp - de...;; (StaticMemberExpression) this.activeContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) this.sp - depthIntoStack;; (StaticMemberExpression) this.sp;; (JSIdentifier) sp						local.get $sp;; (JSIdentifier) depthIntoStack						local.get $depthIntoStack						i32.sub						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: stackInteger -> function(depth...;; (FunctionExpression) function(depthIntoStack) { 	return this....(func $stackInteger						(local $depthIntoStack i32)						(local $temp i32)						;; (ReturnStatement) return this.checkSmallInt(this.stackValu...;; (CallExpression) this.checkSmallInt(this.stackValue(depth...						local.get $this;; (CallExpression) this.stackValue(depthIntoStack)						local.get $this;; (JSIdentifier) depthIntoStack						local.get $depthIntoStack						call $stackValue						call $checkSmallInt						return);; (JSProperty) property: stackIntOrFloat -> function(de...;; (FunctionExpression) function(depthIntoStack) { 	var num = th...(func $stackIntOrFloat						(local $bytes i32)						(local $value i32)						(local $i i32)						(local $depthIntoStack i32)						(local $temp i32)						(local $num i32)												;; unwritable: (IfStatement) if (typeof num === 'number') {return num;; (IfStatement) if (num.isFloat) {this.resultIsFloat = t...;; (StaticMemberExpression) num.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.resultIsFloat = true return num.flo...;; (ExpressionStatement) this.resultIsFloat = true;; (AssignmentExpression) this.resultIsFloat = true;; (JSLiteral) true						i32.const 1						local.set $resultIsFloat;; (ReturnStatement) return num.float;; (StaticMemberExpression) num.float;; (JSIdentifier) float						local.get $float						return));; (IfStatement) if (bytes && bytes.length == 4) {var val...;; (BinaryExpression) bytes && bytes.length == 4;; (JSIdentifier) bytes						local.get $bytes;; (BinaryExpression) bytes.length == 4;; (StaticMemberExpression) bytes.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 4						i32.const 4						i32.eq						i32.and						i32.const 0						i32.ne						(if (then;; (BlockStatement) var value = 0 for (var i = 3; i >= 0; i-...;; (VariableDeclaration) var value = 0;; (VariableDeclarator) value = 0;; (JSLiteral) 0						i32.const 0						local.set $value;; (ForStatement) for (var i = 3; i >= 0; i--) {value = va...;; (VariableDeclaration) var i = 3;; (VariableDeclarator) i = 3;; (JSLiteral) 3						i32.const 3						local.set $i						(loop $loop_1;; (ExpressionStatement) value = value * 256 + bytes[i];; (AssignmentExpression) value = value * 256 + bytes[i];; (BinaryExpression) value * 256 + bytes[i];; (BinaryExpression) value * 256;; (JSIdentifier) value						local.get $value;; (JSLiteral) 256						i32.const 256						i32.mul;; (ComputedMemberExpression) bytes[i];; (JSIdentifier) bytes						local.get $bytes;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						i32.add						local.set $value;; (UpdateExpression) i--;; (JSIdentifier) i						local.get $i						i32.const 1						i32.sub;; (BinaryExpression) i >= 0;; (JSIdentifier) i						local.get $i;; (JSLiteral) 0						i32.const 0						i32.ge_u						i32.const 0						br_if $loop_1);; (IfStatement) if (num.sqClass === this.specialObjects[...;; (BinaryExpression) num.sqClass === this.specialObjects[Sque...;; (StaticMemberExpression) num.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_ClassLa...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassLargePositiveInteger;; (JSIdentifier) splOb_ClassLargePositiveInteger						local.get $splOb_ClassLargePositiveInteger						i32.const 4						i32.mul						i32.add						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return value;; (JSIdentifier) value						local.get $value						return));; (IfStatement) if (num.sqClass === this.specialObjects[...;; (BinaryExpression) num.sqClass === this.specialObjects[Sque...;; (StaticMemberExpression) num.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_ClassLa...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassLargeNegativeInteger;; (JSIdentifier) splOb_ClassLargeNegativeInteger						local.get $splOb_ClassLargeNegativeInteger						i32.const 4						i32.mul						i32.add						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return -value;; (UnaryExpression) -value;; (JSIdentifier) value						local.get $value						local.set $temp						i32.const 0						local.get $temp						i32.sub						return))));; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return);; (JSProperty) property: pop2AndPushIntResult -> functi...;; (FunctionExpression) function(intResult) { 	if (this.success ...(func $pop2AndPushIntResult						(local $temp i32)						(local $intResult i32)						;; (IfStatement) if (this.success && this.canBeSmallInt(i...;; (BinaryExpression) this.success && this.canBeSmallInt(intRe...;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success;; (CallExpression) this.canBeSmallInt(intResult)						local.get $this;; (JSIdentifier) intResult						local.get $intResult						call $canBeSmallInt						i32.and						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.popNandPush(2, intResult) return tr...;; (ExpressionStatement) this.popNandPush(2, intResult);; (CallExpression) this.popNandPush(2, intResult)						local.get $this;; (JSLiteral) 2						i32.const 2;; (JSIdentifier) intResult						local.get $intResult						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return));; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: pop2AndPushNumResult -> functi...;; (FunctionExpression) function(numResult) { 	if (this.success)...(func $pop2AndPushNumResult						(local $temp i32)						(local $bytes i32)						(local $negative i32)						(local $lgIntClass i32)						(local $numResult i32)						(local $unsigned i32)						(local $lgIntObj i32)						;; (IfStatement) if (this.success) {if (this.resultIsFloa...;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (this.resultIsFloat) {this.popNandPus...;; (IfStatement) if (this.resultIsFloat) {this.popNandPus...;; (StaticMemberExpression) this.resultIsFloat;; (JSIdentifier) resultIsFloat						local.get $resultIsFloat						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.popNandPush(2, this.primHandler.mak...;; (ExpressionStatement) this.popNandPush(2, this.primHandler.mak...;; (CallExpression) this.popNandPush(2, this.primHandler.mak...						local.get $this;; (JSLiteral) 2						i32.const 2;; (CallExpression) this.primHandler.makeFloat(numResult)						local.get $primHandler;; (JSIdentifier) numResult						local.get $numResult						call $makeFloat						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return));; (IfStatement) if (numResult >= Squeak.MinSmallInt && n...;; (BinaryExpression) numResult >= Squeak.MinSmallInt && numRe...;; (BinaryExpression) numResult >= Squeak.MinSmallInt;; (JSIdentifier) numResult						local.get $numResult;; (StaticMemberExpression) Squeak.MinSmallInt;; (JSIdentifier) MinSmallInt						local.get $MinSmallInt						i32.ge_u;; (BinaryExpression) numResult <= Squeak.MaxSmallInt;; (JSIdentifier) numResult						local.get $numResult;; (StaticMemberExpression) Squeak.MaxSmallInt;; (JSIdentifier) MaxSmallInt						local.get $MaxSmallInt						i32.le_u						i32.and						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.popNandPush(2, numResult) return tr...;; (ExpressionStatement) this.popNandPush(2, numResult);; (CallExpression) this.popNandPush(2, numResult)						local.get $this;; (JSLiteral) 2						i32.const 2;; (JSIdentifier) numResult						local.get $numResult						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return));; (IfStatement) if (numResult >= -4.294967295e9 && numRe...;; (BinaryExpression) numResult >= -4.294967295e9 && numResult...;; (BinaryExpression) numResult >= -4.294967295e9;; (JSIdentifier) numResult						local.get $numResult;; (UnaryExpression) -4.294967295e9;; (JSLiteral) 4.294967295e9						i32.const 4294967295						local.set $temp						i32.const 0						local.get $temp						i32.sub						i32.ge_u;; (BinaryExpression) numResult <= 4.294967295e9;; (JSIdentifier) numResult						local.get $numResult;; (JSLiteral) 4.294967295e9						i32.const 4294967295						i32.le_u						i32.and						i32.const 0						i32.ne						(if (then;; (BlockStatement) var negative = numResult < 0, unsigned =...;; (VariableDeclaration) var negative = numResult < 0, unsigned =...;; (VariableDeclarator) negative = numResult < 0;; (BinaryExpression) numResult < 0;; (JSIdentifier) numResult						local.get $numResult;; (JSLiteral) 0						i32.const 0						i32.lt_u						local.set $negative;; (VariableDeclarator) unsigned = negative ? -numResult : numRe...;; (ConditionalExpression) negative ? -numResult : numResult;; (JSIdentifier) negative						local.get $negative						i32.const 1						i32.eq						(if (then;; (UnaryExpression) -numResult;; (JSIdentifier) numResult						local.get $numResult						local.set $temp						i32.const 0						local.get $temp						i32.sub)						(else;; (JSIdentifier) numResult						local.get $numResult						))						local.set $unsigned;; (VariableDeclarator) lgIntClass = negative ? Squeak.splOb_Cla...;; (ConditionalExpression) negative ? Squeak.splOb_ClassLargeNegati...;; (JSIdentifier) negative						local.get $negative						i32.const 1						i32.eq						(if (then;; (StaticMemberExpression) Squeak.splOb_ClassLargeNegativeInteger;; (JSIdentifier) splOb_ClassLargeNegativeInteger						local.get $splOb_ClassLargeNegativeInteger)						(else;; (StaticMemberExpression) Squeak.splOb_ClassLargePositiveInteger;; (JSIdentifier) splOb_ClassLargePositiveInteger						local.get $splOb_ClassLargePositiveInteger						))						local.set $lgIntClass;; (VariableDeclarator) lgIntObj = this.instantiateClass(this.sp...;; (CallExpression) this.instantiateClass(this.specialObject...						local.get $this;; (ComputedMemberExpression) this.specialObjects[lgIntClass];; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (JSIdentifier) lgIntClass						local.get $lgIntClass						i32.const 4						i32.mul						i32.add;; (JSLiteral) 4						i32.const 4						call $instantiateClass						local.set $lgIntObj;; (VariableDeclarator) bytes = lgIntObj.bytes;; (StaticMemberExpression) lgIntObj.bytes;; (JSIdentifier) bytes						local.get $bytes						local.set $bytes;; (ExpressionStatement) bytes[0] = unsigned & 255;; (AssignmentExpression) bytes[0] = unsigned & 255						local.get $'bytes';; (JSLiteral) 0						i32.const 0;; (BinaryExpression) unsigned & 255;; (JSIdentifier) unsigned						local.get $unsigned;; (JSLiteral) 255						i32.const 255						i32.and						call $atPut;; (ExpressionStatement) bytes[1] = unsigned >> 8 & 255;; (AssignmentExpression) bytes[1] = unsigned >> 8 & 255						local.get $'bytes';; (JSLiteral) 1						i32.const 1;; (BinaryExpression) unsigned >> 8 & 255;; (BinaryExpression) unsigned >> 8;; (JSIdentifier) unsigned						local.get $unsigned;; (JSLiteral) 8						i32.const 8						i32.shr_s;; (JSLiteral) 255						i32.const 255						i32.and						call $atPut;; (ExpressionStatement) bytes[2] = unsigned >> 16 & 255;; (AssignmentExpression) bytes[2] = unsigned >> 16 & 255						local.get $'bytes';; (JSLiteral) 2						i32.const 2;; (BinaryExpression) unsigned >> 16 & 255;; (BinaryExpression) unsigned >> 16;; (JSIdentifier) unsigned						local.get $unsigned;; (JSLiteral) 16						i32.const 16						i32.shr_s;; (JSLiteral) 255						i32.const 255						i32.and						call $atPut;; (ExpressionStatement) bytes[3] = unsigned >> 24 & 255;; (AssignmentExpression) bytes[3] = unsigned >> 24 & 255						local.get $'bytes';; (JSLiteral) 3						i32.const 3;; (BinaryExpression) unsigned >> 24 & 255;; (BinaryExpression) unsigned >> 24;; (JSIdentifier) unsigned						local.get $unsigned;; (JSLiteral) 24						i32.const 24						i32.shr_s;; (JSLiteral) 255						i32.const 255						i32.and						call $atPut;; (ExpressionStatement) this.popNandPush(2, lgIntObj);; (CallExpression) this.popNandPush(2, lgIntObj)						local.get $this;; (JSLiteral) 2						i32.const 2;; (JSIdentifier) lgIntObj						local.get $lgIntObj						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return))));; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: pop2AndPushBoolResult -> funct...;; (FunctionExpression) function(boolResult) { 	if (!this.succes...(func $pop2AndPushBoolResult						(local $boolResult i32)						(local $temp i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.popNandPush(2, boolResult ? this.tr...;; (CallExpression) this.popNandPush(2, boolResult ? this.tr...						local.get $this;; (JSLiteral) 2						i32.const 2;; (ConditionalExpression) boolResult ? this.trueObj : this.falseOb...;; (JSIdentifier) boolResult						local.get $boolResult						i32.const 1						i32.eq						(if (then;; (StaticMemberExpression) this.trueObj;; (JSIdentifier) trueObj						local.get $trueObj)						(else;; (StaticMemberExpression) this.falseObj;; (JSIdentifier) falseObj						local.get $falseObj						))						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: getClass -> function(obj) { 	i...;; (FunctionExpression) function(obj) { 	if (this.isSmallInt(obj...(func $getClass						(local $obj i32)						(local $temp i32)						;; (IfStatement) if (this.isSmallInt(obj)) {return this.s...;; (CallExpression) this.isSmallInt(obj)						local.get $this;; (JSIdentifier) obj						local.get $obj						call $isSmallInt						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.specialObjects[Squeak.splOb_...;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_ClassIn...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassInteger;; (JSIdentifier) splOb_ClassInteger						local.get $splOb_ClassInteger						i32.const 4						i32.mul						i32.add						return));; (ReturnStatement) return obj.sqClass;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass						return);; (JSProperty) property: canBeSmallInt -> function(anIn...;; (FunctionExpression) function(anInt) { 	return anInt >= Squea...(func $canBeSmallInt						(local $anInt i32)						(local $temp i32)						;; (ReturnStatement) return anInt >= Squeak.MinSmallInt && an...;; (BinaryExpression) anInt >= Squeak.MinSmallInt && anInt <= ...;; (BinaryExpression) anInt >= Squeak.MinSmallInt;; (JSIdentifier) anInt						local.get $anInt;; (StaticMemberExpression) Squeak.MinSmallInt;; (JSIdentifier) MinSmallInt						local.get $MinSmallInt						i32.ge_u;; (BinaryExpression) anInt <= Squeak.MaxSmallInt;; (JSIdentifier) anInt						local.get $anInt;; (StaticMemberExpression) Squeak.MaxSmallInt;; (JSIdentifier) MaxSmallInt						local.get $MaxSmallInt						i32.le_u						i32.and						return);; (JSProperty) property: isSmallInt -> function(object)...;; (FunctionExpression) function(object) { 	return typeof object...(func $isSmallInt						(local $object i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return typeof object === 'number');; (JSProperty) property: checkSmallInt -> function(mayb...;; (FunctionExpression) function(maybeSmallInt) { 	if (typeof ma...(func $checkSmallInt						(local $maybeSmallInt i32)						(local $temp i32)												;; unwritable: (IfStatement) if (typeof maybeSmallInt === 'number') {;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return 1;; (JSLiteral) 1						i32.const 1						return);; (JSProperty) property: quickDivide -> function(rcvr, ...;; (FunctionExpression) function(rcvr, arg) { 	if (arg === 0) {r...(func $quickDivide						(local $rcvr i32)						(local $temp i32)						(local $result i32)						(local $arg i32)						;; (IfStatement) if (arg === 0) {return Squeak.NonSmallIn...;; (BinaryExpression) arg === 0;; (JSIdentifier) arg						local.get $arg;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return Squeak.NonSmallInt;; (StaticMemberExpression) Squeak.NonSmallInt;; (JSIdentifier) NonSmallInt						local.get $NonSmallInt						return));; (IfStatement) if (result * arg === rcvr) {return resul...;; (BinaryExpression) result * arg === rcvr;; (BinaryExpression) result * arg;; (JSIdentifier) result						local.get $result;; (JSIdentifier) arg						local.get $arg						i32.mul;; (JSIdentifier) rcvr						local.get $rcvr						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return result;; (JSIdentifier) result						local.get $result						return));; (ReturnStatement) return Squeak.NonSmallInt;; (StaticMemberExpression) Squeak.NonSmallInt;; (JSIdentifier) NonSmallInt						local.get $NonSmallInt						return);; (JSProperty) property: div -> function(rcvr, arg) { 	...;; (FunctionExpression) function(rcvr, arg) { 	if (arg === 0) {r...(func $div						(local $arg i32)						(local $rcvr i32)						(local $temp i32)						;; (IfStatement) if (arg === 0) {return Squeak.NonSmallIn...;; (BinaryExpression) arg === 0;; (JSIdentifier) arg						local.get $arg;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return Squeak.NonSmallInt;; (StaticMemberExpression) Squeak.NonSmallInt;; (JSIdentifier) NonSmallInt						local.get $NonSmallInt						return))						;; unwritable: (ReturnStatement) return Math.floor(rcvr / arg));; (JSProperty) property: mod -> function(rcvr, arg) { 	...;; (FunctionExpression) function(rcvr, arg) { 	if (arg === 0) {r...(func $mod						(local $arg i32)						(local $rcvr i32)						(local $temp i32)						;; (IfStatement) if (arg === 0) {return Squeak.NonSmallIn...;; (BinaryExpression) arg === 0;; (JSIdentifier) arg						local.get $arg;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return Squeak.NonSmallInt;; (StaticMemberExpression) Squeak.NonSmallInt;; (JSIdentifier) NonSmallInt						local.get $NonSmallInt						return))						;; unwritable: (ReturnStatement) return rcvr - Math.floor(rcvr / arg) * a);; (JSProperty) property: safeShift -> function(smallInt...;; (FunctionExpression) function(smallInt, shiftCount) { 	if (sh...(func $safeShift						(local $smallInt i32)						(local $temp i32)						(local $shifted i32)						(local $shiftCount i32)						;; (IfStatement) if (shiftCount < 0) {if (shiftCount < -3...;; (BinaryExpression) shiftCount < 0;; (JSIdentifier) shiftCount						local.get $shiftCount;; (JSLiteral) 0						i32.const 0						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (shiftCount < -31) {return smallInt <...;; (IfStatement) if (shiftCount < -31) {return smallInt <...;; (BinaryExpression) shiftCount < -31;; (JSIdentifier) shiftCount						local.get $shiftCount;; (UnaryExpression) -31;; (JSLiteral) 31						i32.const 31						local.set $temp						i32.const 0						local.get $temp						i32.sub						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return smallInt < 0 ? -1 : 0;; (ConditionalExpression) smallInt < 0 ? -1 : 0;; (BinaryExpression) smallInt < 0;; (JSIdentifier) smallInt						local.get $smallInt;; (JSLiteral) 0						i32.const 0						i32.lt_u						i32.const 1						i32.eq						(if (then;; (UnaryExpression) -1;; (JSLiteral) 1						i32.const 1						local.set $temp						i32.const 0						local.get $temp						i32.sub)						(else;; (JSLiteral) 0						i32.const 0						))						return));; (ReturnStatement) return smallInt >> -shiftCount;; (BinaryExpression) smallInt >> -shiftCount;; (JSIdentifier) smallInt						local.get $smallInt;; (UnaryExpression) -shiftCount;; (JSIdentifier) shiftCount						local.get $shiftCount						local.set $temp						i32.const 0						local.get $temp						i32.sub						i32.shr_s						return));; (IfStatement) if (shiftCount > 31) {return smallInt ==...;; (BinaryExpression) shiftCount > 31;; (JSIdentifier) shiftCount						local.get $shiftCount;; (JSLiteral) 31						i32.const 31						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return smallInt == 0 ? 0 : Squeak.NonSma...;; (ConditionalExpression) smallInt == 0 ? 0 : Squeak.NonSmallInt;; (BinaryExpression) smallInt == 0;; (JSIdentifier) smallInt						local.get $smallInt;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 1						i32.eq						(if (then;; (JSLiteral) 0						i32.const 0)						(else;; (StaticMemberExpression) Squeak.NonSmallInt;; (JSIdentifier) NonSmallInt						local.get $NonSmallInt						))						return));; (IfStatement) if (shifted >> shiftCount === smallInt) ...;; (BinaryExpression) shifted >> shiftCount === smallInt;; (BinaryExpression) shifted >> shiftCount;; (JSIdentifier) shifted						local.get $shifted;; (JSIdentifier) shiftCount						local.get $shiftCount						i32.shr_s;; (JSIdentifier) smallInt						local.get $smallInt						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return shifted;; (JSIdentifier) shifted						local.get $shifted						return));; (ReturnStatement) return Squeak.NonSmallInt;; (StaticMemberExpression) Squeak.NonSmallInt;; (JSIdentifier) NonSmallInt						local.get $NonSmallInt						return);; (JSProperty) property: isContext -> function(obj) { 	...;; (FunctionExpression) function(obj) { 	if (obj.sqClass === thi...(func $isContext						(local $obj i32)						(local $temp i32)						;; (IfStatement) if (obj.sqClass === this.specialObjects[...;; (BinaryExpression) obj.sqClass === this.specialObjects[Sque...;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_ClassMe...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassMethodContext;; (JSIdentifier) splOb_ClassMethodContext						local.get $splOb_ClassMethodContext						i32.const 4						i32.mul						i32.add						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return));; (IfStatement) if (obj.sqClass === this.specialObjects[...;; (BinaryExpression) obj.sqClass === this.specialObjects[Sque...;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_ClassBl...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassBlockContext;; (JSIdentifier) splOb_ClassBlockContext						local.get $splOb_ClassBlockContext						i32.const 4						i32.mul						i32.add						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return));; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: isMethodContext -> function(ob...;; (FunctionExpression) function(obj) { 	return obj.sqClass === ...(func $isMethodContext						(local $obj i32)						(local $temp i32)						;; (ReturnStatement) return obj.sqClass === this.specialObjec...;; (BinaryExpression) obj.sqClass === this.specialObjects[Sque...;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) this.specialObjects[Squeak.splOb_ClassMe...;; (StaticMemberExpression) this.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassMethodContext;; (JSIdentifier) splOb_ClassMethodContext						local.get $splOb_ClassMethodContext						i32.const 4						i32.mul						i32.add						i32.eq						return);; (JSProperty) property: instantiateClass -> function(a...;; (FunctionExpression) function(aClass, indexableSize) { 	retur...(func $instantiateClass						(local $indexableSize i32)						(local $aClass i32)						(local $temp i32)						;; (ReturnStatement) return this.image.instantiateClass(aClas...;; (CallExpression) this.image.instantiateClass(aClass, inde...						local.get $image;; (JSIdentifier) aClass						local.get $aClass;; (JSIdentifier) indexableSize						local.get $indexableSize;; (StaticMemberExpression) this.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $instantiateClass						return);; (JSProperty) property: arrayFill -> function(array, f...;; (FunctionExpression) function(array, fromIndex, toIndex, valu...(func $arrayFill						(local $value i32)						(local $fromIndex i32)						(local $array i32)						(local $toIndex i32)						(local $i i32)						(local $temp i32)						;; (ForStatement) for (var i = fromIndex; i < toIndex; i++...;; (VariableDeclaration) var i = fromIndex;; (VariableDeclarator) i = fromIndex;; (JSIdentifier) fromIndex						local.get $fromIndex						local.set $i						(loop $loop_1;; (ExpressionStatement) array[i] = value;; (AssignmentExpression) array[i] = value						local.get $'array';; (JSIdentifier) i						local.get $i;; (JSIdentifier) value						local.get $value						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < toIndex;; (JSIdentifier) i						local.get $i;; (JSIdentifier) toIndex						local.get $toIndex						i32.lt_u						i32.const 0						br_if $loop_1));; (JSProperty) property: arrayCopy -> function(src, src...;; (FunctionExpression) function(src, srcPos, dest, destPos, len...(func $arrayCopy						(local $length i32)						(local $srcPos i32)						(local $src i32)						(local $i i32)						(local $temp i32)						(local $dest i32)						(local $destPos i32)						;; (IfStatement) if (src === dest && srcPos < destPos) {f...;; (BinaryExpression) src === dest && srcPos < destPos;; (BinaryExpression) src === dest;; (JSIdentifier) src						local.get $src;; (JSIdentifier) dest						local.get $dest						i32.eq;; (BinaryExpression) srcPos < destPos;; (JSIdentifier) srcPos						local.get $srcPos;; (JSIdentifier) destPos						local.get $destPos						i32.lt_u						i32.and						i32.const 0						i32.ne						(if (then;; (ForStatement) for (var i = length - 1; i >= 0; i--) {d...;; (VariableDeclaration) var i = length - 1;; (VariableDeclarator) i = length - 1;; (BinaryExpression) length - 1;; (JSIdentifier) length						local.get $length;; (JSLiteral) 1						i32.const 1						i32.sub						local.set $i						(loop $loop_1;; (ExpressionStatement) dest[destPos + i] = src[srcPos + i];; (AssignmentExpression) dest[destPos + i] = src[srcPos + i]						local.get $'dest';; (BinaryExpression) destPos + i;; (JSIdentifier) destPos						local.get $destPos;; (JSIdentifier) i						local.get $i						i32.add;; (ComputedMemberExpression) src[srcPos + i];; (JSIdentifier) src						local.get $src;; (BinaryExpression) srcPos + i;; (JSIdentifier) srcPos						local.get $srcPos;; (JSIdentifier) i						local.get $i						i32.add						i32.const 4						i32.mul						i32.add						call $atPut;; (UpdateExpression) i--;; (JSIdentifier) i						local.get $i						i32.const 1						i32.sub;; (BinaryExpression) i >= 0;; (JSIdentifier) i						local.get $i;; (JSLiteral) 0						i32.const 0						i32.ge_u						i32.const 0						br_if $loop_1))						(else;; (ForStatement) for (var i = 0; i < length; i++) {dest[d...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_2;; (ExpressionStatement) dest[destPos + i] = src[srcPos + i];; (AssignmentExpression) dest[destPos + i] = src[srcPos + i]						local.get $'dest';; (BinaryExpression) destPos + i;; (JSIdentifier) destPos						local.get $destPos;; (JSIdentifier) i						local.get $i						i32.add;; (ComputedMemberExpression) src[srcPos + i];; (JSIdentifier) src						local.get $src;; (BinaryExpression) srcPos + i;; (JSIdentifier) srcPos						local.get $srcPos;; (JSIdentifier) i						local.get $i						i32.add						i32.const 4						i32.mul						i32.add						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < length;; (JSIdentifier) i						local.get $i;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_2))));; (JSProperty) property: status -> function(string) { 	...;; (FunctionExpression) function(string) { 	}(func $status						(local $string i32)						(local $temp i32)						);; (JSProperty) property: addMessage -> function(message...;; (FunctionExpression) function(message) { 	return this.message...(func $addMessage						(local $message i32)						(local $temp i32)						;; (ReturnStatement) return this.messages[message] ? ++this.m...;; (ConditionalExpression) this.messages[message] ? ++this.messages...;; (ComputedMemberExpression) this.messages[message];; (StaticMemberExpression) this.messages;; (JSIdentifier) messages						local.get $messages;; (JSIdentifier) message						local.get $message						i32.const 4						i32.mul						i32.add						i32.const 1						i32.eq						(if (then;; (UpdateExpression) ++this.messages[message];; (ComputedMemberExpression) this.messages[message];; (StaticMemberExpression) this.messages;; (JSIdentifier) messages						local.get $messages;; (JSIdentifier) message						local.get $message						i32.const 4						i32.mul						i32.add						i32.const 1						i32.add)						(else;; (AssignmentExpression) this.messages[message] = 1						local.get $this;; (JSIdentifier) message						local.get $message;; (JSLiteral) 1						i32.const 1						call $atPut						))						return);; (JSProperty) property: warnOnce -> function(message) ...;; (FunctionExpression) function(message) { 	if (this.addMessage...(func $warnOnce						(local $message i32)						(local $temp i32)												;; unwritable: (IfStatement) if (this.addMessage(message) == 1) {cons);; (JSProperty) property: printMethod -> function(aMetho...;; (FunctionExpression) function(aMethod, optContext, optSel) { ...(func $printMethod						(local $found i32)						(local $rcvr i32)						(local $optContext i32)						(local $temp i32)						(local $optSel i32)						(local $aMethod i32)												;; unwritable: (IfStatement) if (optSel) {return optContext.className;; (IfStatement) if (!aMethod) {aMethod = this.activeCont...;; (UnaryExpression) !aMethod;; (JSIdentifier) aMethod						local.get $aMethod						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) aMethod = this.activeContext.contextMeth...;; (AssignmentExpression) aMethod = this.activeContext.contextMeth...;; (CallExpression) this.activeContext.contextMethod()						local.get $activeContext						call $contextMethod						local.set $aMethod));; (ExpressionStatement) this.allMethodsDo(function(classObj, met...;; (CallExpression) this.allMethodsDo(function(classObj, met...						local.get $this;; (FunctionExpression) function(classObj, methodObj, selectorOb...(func $nil						(local $classObj i32)						(local $temp i32)						(local $selectorObj i32)						(local $methodObj i32)												;; unwritable: (IfStatement) if (methodObj === aMethod) {return found)						call $allMethodsDo;; (IfStatement) if (found) {return found};; (JSIdentifier) found						local.get $found						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return found;; (JSIdentifier) found						local.get $found						return))						;; unwritable: (IfStatement) if (optContext) {var rcvr = optContext.p						;; unwritable: (ReturnStatement) return '?>>?');; (JSProperty) property: allInstancesOf -> function(cla...;; (FunctionExpression) function(classObj, callback) { 	if (type...(func $allInstancesOf						(local $inst i32)						(local $classObj i32)						(local $instances i32)						(local $callback i32)						(local $temp i32)												;; unwritable: (IfStatement) if (typeof classObj === 'string') {class;; (WhileStatement) while (inst) {if (callback) {callback(in...						(loop $loop_1;; (BlockStatement) if (callback) {callback(inst)} else {ins...;; (IfStatement) if (callback) {callback(inst)} else {ins...;; (JSIdentifier) callback						local.get $callback						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) callback(inst);; (CallExpression) callback(inst);; (JSIdentifier) inst						local.get $inst						call $callback)						(else;; (ExpressionStatement) instances.push(inst);; (CallExpression) instances.push(inst)						local.get $instances;; (JSIdentifier) inst						local.get $inst						call $push));; (ExpressionStatement) inst = this.image.nextInstanceAfter(inst...;; (AssignmentExpression) inst = this.image.nextInstanceAfter(inst...;; (CallExpression) this.image.nextInstanceAfter(inst)						local.get $image;; (JSIdentifier) inst						local.get $inst						call $nextInstanceAfter						local.set $inst;; (JSIdentifier) inst						local.get $inst						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ReturnStatement) return instances;; (JSIdentifier) instances						local.get $instances						return);; (JSProperty) property: globalNamed -> function(name) ...;; (FunctionExpression) function(name) { 	return this.allGlobals...(func $globalNamed						(local $name i32)						(local $temp i32)						;; (ReturnStatement) return this.allGlobalsDo(function(nameOb...;; (CallExpression) this.allGlobalsDo(function(nameObj, glob...						local.get $this;; (FunctionExpression) function(nameObj, globalObj) { 	if (name...(func $nil						(local $temp i32)						(local $nameObj i32)						(local $globalObj i32)						;; (IfStatement) if (nameObj.bytesAsString() === name) {r...;; (BinaryExpression) nameObj.bytesAsString() === name;; (CallExpression) nameObj.bytesAsString()						local.get $nameObj						call $bytesAsString;; (JSIdentifier) name						local.get $name						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return globalObj;; (JSIdentifier) globalObj						local.get $globalObj						return)))						call $allGlobalsDo						return);; (JSProperty) property: allGlobalsDo -> function(callb...;; (FunctionExpression) function(callback) { 	var globals = this...(func $allGlobalsDo						(local $assn i32)						(local $i i32)						(local $callback i32)						(local $globals i32)						(local $temp i32)						(local $result i32)						;; (ForStatement) for (var i = 0; i < globals.length; i++)...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (BlockStatement) var assn = globals[i] if (!assn.isNil) {...;; (VariableDeclaration) var assn = globals[i];; (VariableDeclarator) assn = globals[i];; (ComputedMemberExpression) globals[i];; (JSIdentifier) globals						local.get $globals;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						local.set $assn;; (IfStatement) if (!assn.isNil) {var result = callback(...;; (UnaryExpression) !assn.isNil;; (StaticMemberExpression) assn.isNil;; (JSIdentifier) isNil						local.get $isNil						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) var result = callback(assn.pointers[0], ...;; (VariableDeclaration) var result = callback(assn.pointers[0], ...;; (VariableDeclarator) result = callback(assn.pointers[0], assn...;; (CallExpression) callback(assn.pointers[0], assn.pointers...;; (ComputedMemberExpression) assn.pointers[0];; (StaticMemberExpression) assn.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add;; (ComputedMemberExpression) assn.pointers[1];; (StaticMemberExpression) assn.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 1						i32.const 1						i32.const 4						i32.mul						i32.add						call $callback						local.set $result;; (IfStatement) if (result) {return result};; (JSIdentifier) result						local.get $result						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return result;; (JSIdentifier) result						local.get $result						return))));; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < globals.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) globals.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_1));; (JSProperty) property: allMethodsDo -> function(callb...;; (FunctionExpression) function(callback) { 	var self = this th...(func $allMethodsDo						(local $self i32)						(local $temp i32)						(local $callback i32)						;; (ExpressionStatement) this.allGlobalsDo(function(globalNameObj...;; (CallExpression) this.allGlobalsDo(function(globalNameObj...						local.get $this;; (FunctionExpression) function(globalNameObj, globalObj) { 	if...(func $nil						(local $temp i32)						(local $j i32)						(local $clsAndMeta i32)						(local $mdict i32)						(local $cls i32)						(local $globalNameObj i32)						(local $selectors i32)						(local $c i32)						(local $globalObj i32)						(local $methods i32)												;; unwritable: (IfStatement) if (globalObj.pointers && globalObj.poin)						call $allGlobalsDo);; (JSProperty) property: printStack -> function(ctx, li...;; (FunctionExpression) function(ctx, limit) { 	if (typeof ctx =...(func $printStack						(local $stack i32)						(local $method i32)						(local $hardLimit i32)						(local $temp i32)						(local $ctx i32)						(local $contexts i32)						(local $i i32)						(local $limit i32)						(local $extra i32)						(local $block i32)												;; unwritable: (IfStatement) if (typeof ctx == 'number') {limit = ctx;; (IfStatement) if (!ctx) {ctx = this.activeContext};; (UnaryExpression) !ctx;; (JSIdentifier) ctx						local.get $ctx						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) ctx = this.activeContext;; (AssignmentExpression) ctx = this.activeContext;; (StaticMemberExpression) this.activeContext;; (JSIdentifier) activeContext						local.get $activeContext						local.set $ctx));; (IfStatement) if (!limit) {limit = 100};; (UnaryExpression) !limit;; (JSIdentifier) limit						local.get $limit						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) limit = 100;; (AssignmentExpression) limit = 100;; (JSLiteral) 100						i32.const 100						local.set $limit));; (TryStatement) an active TryStatement with properties: ...);; (JSProperty) property: findMethod -> function(classAn...;; (FunctionExpression) function(classAndMethodString) { 	var fo...(func $findMethod						(local $methodName i32)						(local $found i32)						(local $className i32)						(local $temp i32)						(local $classAndMethodString i32)						;; (ExpressionStatement) this.allMethodsDo(function(classObj, met...;; (CallExpression) this.allMethodsDo(function(classObj, met...						local.get $this;; (FunctionExpression) function(classObj, methodObj, selectorOb...(func $nil						(local $classObj i32)						(local $temp i32)						(local $selectorObj i32)						(local $methodObj i32)						;; (IfStatement) if (selectorObj.bytesSize) {if (methodNa...;; (StaticMemberExpression) selectorObj.bytesSize;; (JSIdentifier) bytesSize						local.get $bytesSize						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (methodName.length == selectorObj.byt...;; (IfStatement) if (methodName.length == selectorObj.byt...;; (BinaryExpression) methodName.length == selectorObj.bytesSi...;; (BinaryExpression) methodName.length == selectorObj.bytesSi...;; (BinaryExpression) methodName.length == selectorObj.bytesSi...;; (StaticMemberExpression) methodName.length;; (JSIdentifier) length						local.get $length;; (CallExpression) selectorObj.bytesSize()						local.get $selectorObj						call $bytesSize						i32.eq;; (BinaryExpression) methodName == selectorObj.bytesAsString(...;; (JSIdentifier) methodName						local.get $methodName;; (CallExpression) selectorObj.bytesAsString()						local.get $selectorObj						call $bytesAsString						i32.eq						i32.and;; (BinaryExpression) className == classObj.className();; (JSIdentifier) className						local.get $className;; (CallExpression) classObj.className()						local.get $classObj						call $className						i32.eq						i32.and						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return found = methodObj;; (AssignmentExpression) found = methodObj;; (JSIdentifier) methodObj						local.get $methodObj						local.set $found						return)))))						call $allMethodsDo;; (ReturnStatement) return found;; (JSIdentifier) found						local.get $found						return);; (JSProperty) property: breakNow -> function(msg) { 	i...;; (FunctionExpression) function(msg) { 	if (msg) {console.log('...(func $breakNow						(local $msg i32)						(local $temp i32)												;; unwritable: (IfStatement) if (msg) {console.log('Break: ' + msg)}						;; unwritable: (ExpressionStatement) this.breakOutOfInterpreter = 'break');; (JSProperty) property: breakOn -> function(classAndMe...;; (FunctionExpression) function(classAndMethodString) { 	return...(func $breakOn						(local $classAndMethodString i32)						(local $temp i32)						;; (ReturnStatement) return this.breakOnMethod = classAndMeth...;; (AssignmentExpression) this.breakOnMethod = classAndMethodStrin...;; (BinaryExpression) classAndMethodString && this.findMethod(...;; (JSIdentifier) classAndMethodString						local.get $classAndMethodString;; (CallExpression) this.findMethod(classAndMethodString)						local.get $this;; (JSIdentifier) classAndMethodString						local.get $classAndMethodString						call $findMethod						i32.and						local.set $breakOnMethod						return);; (JSProperty) property: breakOnReturnFromThisContext -...;; (FunctionExpression) function() { 	this.breakOnContextChanged...(func $breakOnReturnFromThisContext						(local $temp i32)						;; (ExpressionStatement) this.breakOnContextChanged = false;; (AssignmentExpression) this.breakOnContextChanged = false;; (JSLiteral) false						i32.const 0						local.set $breakOnContextChanged;; (ExpressionStatement) this.breakOnContextReturned = this.activ...;; (AssignmentExpression) this.breakOnContextReturned = this.activ...;; (StaticMemberExpression) this.activeContext;; (JSIdentifier) activeContext						local.get $activeContext						local.set $breakOnContextReturned);; (JSProperty) property: breakOnSendOrReturn -> functio...;; (FunctionExpression) function() { 	this.breakOnContextChanged...(func $breakOnSendOrReturn						(local $temp i32)						;; (ExpressionStatement) this.breakOnContextChanged = true;; (AssignmentExpression) this.breakOnContextChanged = true;; (JSLiteral) true						i32.const 1						local.set $breakOnContextChanged;; (ExpressionStatement) this.breakOnContextReturned = nil;; (AssignmentExpression) this.breakOnContextReturned = nil;; (JSLiteral) nil						i32.const 0						local.set $breakOnContextReturned);; (JSProperty) property: printActiveContext -> function...;; (FunctionExpression) function(maxWidth) { 	if (!maxWidth) {ma...(func $printActiveContext						(local $value i32)						(local $lastTemp i32)						(local $closure i32)						(local $firstArg i32)						(local $i i32)						(local $temp i32)						(local $maxWidth i32)						(local $ctx i32)						(local $homeCtx i32)						(local $lastArg i32)						(local $firstTemp i32)						(local $isClosure i32)						(local $tempCount i32)						(local $stack i32)						(local $stackBottom i32)						(local $nArgs i32)						(local $isBlock i32)						(local $stackTop i32)						(local $label i32);; (FunctionDeclaration) function printObj(obj) {var value = obj....;; (FunctionExpression) function(obj) { 	var value = obj.sqInstN...(func $printObj	(local $obj i32)	(local $value i32)	(local $temp i32)		;; unwritable: (ExpressionStatement) value = JSON.stringify(value).slice(1, -	;; unwritable: (IfStatement) if (value.length > maxWidth - 3) {value ;; (ReturnStatement) return value;; (JSIdentifier) value						local.get $value						return)						;; (IfStatement) if (!maxWidth) {maxWidth = 72};; (UnaryExpression) !maxWidth;; (JSIdentifier) maxWidth						local.get $maxWidth						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) maxWidth = 72;; (AssignmentExpression) maxWidth = 72;; (JSLiteral) 72						i32.const 72						local.set $maxWidth))						;; unwritable: (ForStatement) for (var i = stackBottom; i <= stackTop;						;; unwritable: (IfStatement) if (isBlock) {stack += '
' var nArgs = c;; (ReturnStatement) return stack;; (JSIdentifier) stack						local.get $stack						return);; (JSProperty) property: waitingProcesses -> function()...;; (FunctionExpression) function() { 	var semaClass = this.speci...(func $waitingProcesses						(local $semaClass i32)						(local $sema i32)						(local $processIndex i32)						(local $processes i32)						(local $temp i32)						(local $process i32)						;; (WhileStatement) while (sema) {var process = sema.pointer...						(loop $loop_1;; (BlockStatement) var process = sema.pointers[Squeak.Linke...;; (VariableDeclaration) var process = sema.pointers[Squeak.Linke...;; (VariableDeclarator) process = sema.pointers[Squeak.LinkedLis...;; (ComputedMemberExpression) sema.pointers[Squeak.LinkedList_firstLin...;; (StaticMemberExpression) sema.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.LinkedList_firstLink;; (JSIdentifier) LinkedList_firstLink						local.get $LinkedList_firstLink						i32.const 4						i32.mul						i32.add						local.set $process;; (WhileStatement) while (!process.isNil) {processes[proces...						(loop $loop_2;; (BlockStatement) processes[processIndex] = process proces...;; (ExpressionStatement) processes[processIndex] = process;; (AssignmentExpression) processes[processIndex] = process						local.get $'processes';; (JSIdentifier) processIndex						local.get $processIndex;; (JSIdentifier) process						local.get $process						call $atPut;; (ExpressionStatement) process = process.pointers[Squeak.Link_n...;; (AssignmentExpression) process = process.pointers[Squeak.Link_n...;; (ComputedMemberExpression) process.pointers[Squeak.Link_nextLink];; (StaticMemberExpression) process.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Link_nextLink;; (JSIdentifier) Link_nextLink						local.get $Link_nextLink						i32.const 4						i32.mul						i32.add						local.set $process;; (UnaryExpression) !process.isNil;; (StaticMemberExpression) process.isNil;; (JSIdentifier) isNil						local.get $isNil						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.eq						br_if $loop_2)						(block $loop_2_continue);; (ExpressionStatement) sema = this.image.nextInstanceAfter(sema...;; (AssignmentExpression) sema = this.image.nextInstanceAfter(sema...;; (CallExpression) this.image.nextInstanceAfter(sema)						local.get $image;; (JSIdentifier) sema						local.get $sema						call $nextInstanceAfter						local.set $sema;; (JSIdentifier) sema						local.get $sema						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ReturnStatement) return processes;; (JSIdentifier) processes						local.get $processes						return);; (JSProperty) property: printAllProcesses -> function(...;; (FunctionExpression) function() { 	var schedAssn = this.speci...(func $printAllProcesses						(local $temp i32)						(local $lists i32)						(local $priority i32)						(local $activeProc i32)						(local $result i32)						(local $schedAssn i32)						(local $semaClass i32)						(local $process i32)						(local $sched i32)						(local $sema i32)												;; unwritable: (ForStatement) for (var priority = lists.length - 1; pr						;; unwritable: (WhileStatement) while (sema) {var process = sema.pointer;; (ReturnStatement) return result;; (JSIdentifier) result						local.get $result						return);; (JSProperty) property: printProcess -> function(proce...;; (FunctionExpression) function(process, active) { 	var context...(func $printProcess						(local $stack i32)						(local $active i32)						(local $priority i32)						(local $temp i32)						(local $context i32)						(local $process i32)												;; unwritable: (ReturnStatement) return process.toString() + ' at priorit);; (JSProperty) property: printByteCodes -> function(aMe...;; (FunctionExpression) function(aMethod, optionalIndent, option...(func $printByteCodes						(local $optionalHighlight i32)						(local $optionalPC i32)						(local $optionalIndent i32)						(local $printer i32)						(local $temp i32)						(local $aMethod i32)						;; (IfStatement) if (!aMethod) {aMethod = this.method};; (UnaryExpression) !aMethod;; (JSIdentifier) aMethod						local.get $aMethod						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) aMethod = this.method;; (AssignmentExpression) aMethod = this.method;; (StaticMemberExpression) this.method;; (JSIdentifier) method						local.get $method						local.set $aMethod));; (ReturnStatement) return printer.printInstructions(optiona...;; (CallExpression) printer.printInstructions(optionalIndent...						local.get $printer;; (JSIdentifier) optionalIndent						local.get $optionalIndent;; (JSIdentifier) optionalHighlight						local.get $optionalHighlight;; (JSIdentifier) optionalPC						local.get $optionalPC						call $printInstructions						return);; (JSProperty) property: willSendOrReturn -> function()...;; (FunctionExpression) function() { 	var byte = this.method.byt...(func $willSendOrReturn						(local $litIndex i32)						(local $temp i32)						(local $selectorObj i32)						(local $byte i32)						;; (IfStatement) if (byte >= 120 && byte <= 125) {return ...;; (BinaryExpression) byte >= 120 && byte <= 125;; (BinaryExpression) byte >= 120;; (JSIdentifier) byte						local.get $byte;; (JSLiteral) 120						i32.const 120						i32.ge_u;; (BinaryExpression) byte <= 125;; (JSIdentifier) byte						local.get $byte;; (JSLiteral) 125						i32.const 125						i32.le_u						i32.and						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return));; (IfStatement) if (byte < 131 || byte == 200) {return f...;; (BinaryExpression) byte < 131 || byte == 200;; (BinaryExpression) byte < 131;; (JSIdentifier) byte						local.get $byte;; (JSLiteral) 131						i32.const 131						i32.lt_u;; (BinaryExpression) byte == 200;; (JSIdentifier) byte						local.get $byte;; (JSLiteral) 200						i32.const 200						i32.eq						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (byte >= 176) {return true};; (BinaryExpression) byte >= 176;; (JSIdentifier) byte						local.get $byte;; (JSLiteral) 176						i32.const 176						i32.ge_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return))						;; unwritable: (IfStatement) if (byte <= 134) {var litIndex if (byte ;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: nextSendSelector -> function()...;; (FunctionExpression) function() { 	var byte = this.method.byt...(func $nextSendSelector						(local $litIndex i32)						(local $selector i32)						(local $temp i32)						(local $selectorObj i32)						(local $byte i32)						;; (IfStatement) if (byte < 131 || byte == 200) {return n...;; (BinaryExpression) byte < 131 || byte == 200;; (BinaryExpression) byte < 131;; (JSIdentifier) byte						local.get $byte;; (JSLiteral) 131						i32.const 131						i32.lt_u;; (BinaryExpression) byte == 200;; (JSIdentifier) byte						local.get $byte;; (JSLiteral) 200						i32.const 200						i32.eq						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return));; (IfStatement) if (byte >= 208) {selectorObj = this.met...;; (BinaryExpression) byte >= 208;; (JSIdentifier) byte						local.get $byte;; (JSLiteral) 208						i32.const 208						i32.ge_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) selectorObj = this.method.methodGetLiter...;; (ExpressionStatement) selectorObj = this.method.methodGetLiter...;; (AssignmentExpression) selectorObj = this.method.methodGetLiter...;; (CallExpression) this.method.methodGetLiteral(byte & 15)						local.get $method;; (BinaryExpression) byte & 15;; (JSIdentifier) byte						local.get $byte;; (JSLiteral) 15						i32.const 15						i32.and						call $methodGetLiteral						local.set $selectorObj)						(else;; (IfStatement) if (byte >= 176) {selectorObj = this.spe...;; (BinaryExpression) byte >= 176;; (JSIdentifier) byte						local.get $byte;; (JSLiteral) 176						i32.const 176						i32.ge_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) selectorObj = this.specialSelectors[2 * ...;; (ExpressionStatement) selectorObj = this.specialSelectors[2 * ...;; (AssignmentExpression) selectorObj = this.specialSelectors[2 * ...;; (ComputedMemberExpression) this.specialSelectors[2 * byte - 176];; (StaticMemberExpression) this.specialSelectors;; (JSIdentifier) specialSelectors						local.get $specialSelectors;; (BinaryExpression) 2 * byte - 176;; (JSLiteral) 2						i32.const 2;; (BinaryExpression) byte - 176;; (JSIdentifier) byte						local.get $byte;; (JSLiteral) 176						i32.const 176						i32.sub						i32.mul						i32.const 4						i32.mul						i32.add						local.set $selectorObj)						(else;; (IfStatement) if (byte <= 134) {var litIndex if (byte ...;; (BinaryExpression) byte <= 134;; (JSIdentifier) byte						local.get $byte;; (JSLiteral) 134						i32.const 134						i32.le_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) var litIndex if (byte === 132) {if (this...;; (VariableDeclaration) var litIndex;; (VariableDeclarator) litIndex;; (IfStatement) if (byte === 132) {if (this.method.bytes...;; (BinaryExpression) byte === 132;; (JSIdentifier) byte						local.get $byte;; (JSLiteral) 132						i32.const 132						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (this.method.bytes[this.pc + 1] >> 5 ...;; (IfStatement) if (this.method.bytes[this.pc + 1] >> 5 ...;; (BinaryExpression) this.method.bytes[this.pc + 1] >> 5 > 1;; (BinaryExpression) this.method.bytes[this.pc + 1] >> 5;; (ComputedMemberExpression) this.method.bytes[this.pc + 1];; (StaticMemberExpression) this.method.bytes;; (JSIdentifier) bytes						local.get $bytes;; (BinaryExpression) this.pc + 1;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc;; (JSLiteral) 1						i32.const 1						i32.add						i32.const 4						i32.mul						i32.add;; (JSLiteral) 5						i32.const 5						i32.shr_s;; (JSLiteral) 1						i32.const 1						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return));; (ExpressionStatement) litIndex = this.method.bytes[this.pc + 2...;; (AssignmentExpression) litIndex = this.method.bytes[this.pc + 2...;; (ComputedMemberExpression) this.method.bytes[this.pc + 2];; (StaticMemberExpression) this.method.bytes;; (JSIdentifier) bytes						local.get $bytes;; (BinaryExpression) this.pc + 2;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc;; (JSLiteral) 2						i32.const 2						i32.add						i32.const 4						i32.mul						i32.add						local.set $litIndex)						(else;; (ExpressionStatement) litIndex = this.method.bytes[this.pc + 1...;; (AssignmentExpression) litIndex = this.method.bytes[this.pc + 1...;; (BinaryExpression) this.method.bytes[this.pc + 1] & byte ==...;; (ComputedMemberExpression) this.method.bytes[this.pc + 1];; (StaticMemberExpression) this.method.bytes;; (JSIdentifier) bytes						local.get $bytes;; (BinaryExpression) this.pc + 1;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc;; (JSLiteral) 1						i32.const 1						i32.add						i32.const 4						i32.mul						i32.add;; (ConditionalExpression) byte === 134 ? 63 : 31;; (BinaryExpression) byte === 134;; (JSIdentifier) byte						local.get $byte;; (JSLiteral) 134						i32.const 134						i32.eq						i32.const 1						i32.eq						(if (then;; (JSLiteral) 63						i32.const 63)						(else;; (JSLiteral) 31						i32.const 31						))						i32.and						local.set $litIndex));; (ExpressionStatement) selectorObj = this.method.methodGetLiter...;; (AssignmentExpression) selectorObj = this.method.methodGetLiter...;; (CallExpression) this.method.methodGetLiteral(litIndex)						local.get $method;; (JSIdentifier) litIndex						local.get $litIndex						call $methodGetLiteral						local.set $selectorObj))))))						;; unwritable: (IfStatement) if (selectorObj) {var selector = selecto);; (JSProperty) property: initialize -> function(vm, dis...;; (FunctionExpression) function(vm, display) { 	this.vm = vm if...(func $initialize						(local $vm i32)						(local $display i32)						(local $temp i32)						;; (ExpressionStatement) this.vm = vm;; (AssignmentExpression) this.vm = vm;; (JSIdentifier) vm						local.get $vm						local.set $vm;; (IfStatement) if (display) {this.display = display} el...;; (JSIdentifier) display						local.get $display						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.display = display;; (AssignmentExpression) this.display = display;; (JSIdentifier) display						local.get $display						local.set $display)						(else;; (ExpressionStatement) this.display = {property: headless -> tr...;; (AssignmentExpression) this.display = {property: headless -> tr...;; (ObjectExpression) {property: headless -> true}						local.set $display))						;; unwritable: (ExpressionStatement) self.display = this.display;; (ExpressionStatement) this.display.vm = this.vm;; (AssignmentExpression) this.display.vm = this.vm;; (StaticMemberExpression) this.vm;; (JSIdentifier) vm						local.get $vm						local.set $vm;; (ExpressionStatement) this.oldPrims = !this.vm.image.hasClosur...;; (AssignmentExpression) this.oldPrims = !this.vm.image.hasClosur...;; (UnaryExpression) !this.vm.image.hasClosures;; (StaticMemberExpression) this.vm.image.hasClosures;; (JSIdentifier) hasClosures						local.get $hasClosures						local.set $temp						i32.const -1						local.get $temp						i32.sub						local.set $oldPrims;; (ExpressionStatement) this.allowAccessBeyondSP = this.oldPrims;; (AssignmentExpression) this.allowAccessBeyondSP = this.oldPrims;; (StaticMemberExpression) this.oldPrims;; (JSIdentifier) oldPrims						local.get $oldPrims						local.set $allowAccessBeyondSP;; (ExpressionStatement) this.deferDisplayUpdates = false;; (AssignmentExpression) this.deferDisplayUpdates = false;; (JSLiteral) false						i32.const 0						local.set $deferDisplayUpdates						;; unwritable: (ExpressionStatement) this.semaphoresToSignal = [];; (ExpressionStatement) this.initDisplay();; (CallExpression) this.initDisplay()						local.get $this						call $initDisplay;; (ExpressionStatement) this.initAtCache();; (CallExpression) this.initAtCache()						local.get $this						call $initAtCache;; (ExpressionStatement) this.initModules();; (CallExpression) this.initModules()						local.get $this						call $initModules;; (IfStatement) if (vm.image.isSpur) {this.charFromInt =...;; (StaticMemberExpression) vm.image.isSpur;; (JSIdentifier) isSpur						local.get $isSpur						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.charFromInt = this.charFromIntSpur ...;; (ExpressionStatement) this.charFromInt = this.charFromIntSpur;; (AssignmentExpression) this.charFromInt = this.charFromIntSpur;; (StaticMemberExpression) this.charFromIntSpur;; (JSIdentifier) charFromIntSpur						local.get $charFromIntSpur						local.set $charFromInt;; (ExpressionStatement) this.charToInt = this.charToIntSpur;; (AssignmentExpression) this.charToInt = this.charToIntSpur;; (StaticMemberExpression) this.charToIntSpur;; (JSIdentifier) charToIntSpur						local.get $charToIntSpur						local.set $charToInt;; (ExpressionStatement) this.identityHash = this.identityHashSpu...;; (AssignmentExpression) this.identityHash = this.identityHashSpu...;; (StaticMemberExpression) this.identityHashSpur;; (JSIdentifier) identityHashSpur						local.get $identityHashSpur						local.set $identityHash)));; (JSProperty) property: initModules -> function() { 	t...;; (FunctionExpression) function() { 	this.loadedModules = {} th...(func $initModules						(local $temp i32)						;; (ExpressionStatement) this.loadedModules = {};; (AssignmentExpression) this.loadedModules = {};; (ObjectExpression) {}						local.set $loadedModules;; (ExpressionStatement) this.builtinModules = {property: JavaScr...;; (AssignmentExpression) this.builtinModules = {property: JavaScr...;; (ObjectExpression) {property: JavaScriptPlugin -> this.find...						local.set $builtinModules;; (ExpressionStatement) this.patchModules = {property: ScratchPl...;; (AssignmentExpression) this.patchModules = {property: ScratchPl...;; (ObjectExpression) {property: ScratchPlugin -> this.findPlu...						local.set $patchModules;; (ExpressionStatement) this.interpreterProxy = new Squeak.Inter...;; (AssignmentExpression) this.interpreterProxy = new Squeak.Inter...;; (NewExpression) new Squeak.InterpreterProxy(this.vm)						unreachable						local.set $interpreterProxy);; (JSProperty) property: findPluginFunctions -> functio...;; (FunctionExpression) function(prefix, match, bindLate) { 	mat...(func $findPluginFunctions						(local $funcName i32)						(local $plugin i32)						(local $bindLate i32)						(local $regex i32)						(local $temp i32)						(local $prefix i32)						(local $match i32)						(local $primName i32)												;; unwritable: (ExpressionStatement) match = match || '(initialise|shutdown|p;; (ForInStatement) an active ForInStatement with properties...;; (ReturnStatement) return plugin;; (JSIdentifier) plugin						local.get $plugin						return);; (JSProperty) property: initDisplay -> function() { 	t...;; (FunctionExpression) function() { 	this.indexedColors = [4.29...(func $initDisplay						(local $temp i32)												;; unwritable: (ExpressionStatement) this.indexedColors = [4.294967295e9, 4.2);; (JSProperty) property: quickSendOther -> function(rcv...;; (FunctionExpression) function(rcvr, lobits) { 	this.success =...(func $quickSendOther						(local $temp i32)						(local $rcvr i32)						(local $lobits i32)						;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (SwitchStatement) switch (lobits) { case 0: return this.po...lobits						local.set $temp;; (SwitchCase)  case 0: return this.popNandPushIfOK(2, ...						local.get $temp;; (JSLiteral) 0						i32.const 0						i32.eq						(if (then ;; (ReturnStatement) return this.popNandPushIfOK(2, this.obje...;; (CallExpression) this.popNandPushIfOK(2, this.objectAt(tr...						local.get $this;; (JSLiteral) 2						i32.const 2;; (CallExpression) this.objectAt(true, true, false)						local.get $this;; (JSLiteral) true						i32.const 1;; (JSLiteral) true						i32.const 1;; (JSLiteral) false						i32.const 0						call $objectAt						call $popNandPushIfOK						return						));; (SwitchCase)  case 1: return this.popNandPushIfOK(3, ...						local.get $temp;; (JSLiteral) 1						i32.const 1						i32.eq						(if (then ;; (ReturnStatement) return this.popNandPushIfOK(3, this.obje...;; (CallExpression) this.popNandPushIfOK(3, this.objectAtPut...						local.get $this;; (JSLiteral) 3						i32.const 3;; (CallExpression) this.objectAtPut(true, true, false)						local.get $this;; (JSLiteral) true						i32.const 1;; (JSLiteral) true						i32.const 1;; (JSLiteral) false						i32.const 0						call $objectAtPut						call $popNandPushIfOK						return						));; (SwitchCase)  case 2: return this.popNandPushIfOK(1, ...						local.get $temp;; (JSLiteral) 2						i32.const 2						i32.eq						(if (then ;; (ReturnStatement) return this.popNandPushIfOK(1, this.obje...;; (CallExpression) this.popNandPushIfOK(1, this.objectSize(...						local.get $this;; (JSLiteral) 1						i32.const 1;; (CallExpression) this.objectSize(true)						local.get $this;; (JSLiteral) true						i32.const 1						call $objectSize						call $popNandPushIfOK						return						));; (SwitchCase)  case 6: return this.pop2andPushBoolIfOK...						local.get $temp;; (JSLiteral) 6						i32.const 6						i32.eq						(if (then ;; (ReturnStatement) return this.pop2andPushBoolIfOK(this.vm....;; (CallExpression) this.pop2andPushBoolIfOK(this.vm.stackVa...						local.get $this;; (BinaryExpression) this.vm.stackValue(1) === this.vm.stackV...;; (CallExpression) this.vm.stackValue(1)						local.get $vm;; (JSLiteral) 1						i32.const 1						call $stackValue;; (CallExpression) this.vm.stackValue(0)						local.get $vm;; (JSLiteral) 0						i32.const 0						call $stackValue						i32.eq						call $pop2andPushBoolIfOK						return						));; (SwitchCase)  case 7: return this.popNandPushIfOK(1, ...						local.get $temp;; (JSLiteral) 7						i32.const 7						i32.eq						(if (then ;; (ReturnStatement) return this.popNandPushIfOK(1, this.vm.g...;; (CallExpression) this.popNandPushIfOK(1, this.vm.getClass...						local.get $this;; (JSLiteral) 1						i32.const 1;; (CallExpression) this.vm.getClass(this.vm.top())						local.get $vm;; (CallExpression) this.vm.top()						local.get $vm						call $top						call $getClass						call $popNandPushIfOK						return						));; (SwitchCase)  case 8: return this.popNandPushIfOK(2, ...						local.get $temp;; (JSLiteral) 8						i32.const 8						i32.eq						(if (then ;; (ReturnStatement) return this.popNandPushIfOK(2, this.doBl...;; (CallExpression) this.popNandPushIfOK(2, this.doBlockCopy...						local.get $this;; (JSLiteral) 2						i32.const 2;; (CallExpression) this.doBlockCopy()						local.get $this						call $doBlockCopy						call $popNandPushIfOK						return						));; (SwitchCase)  case 9: return this.primitiveBlockValue...						local.get $temp;; (JSLiteral) 9						i32.const 9						i32.eq						(if (then ;; (ReturnStatement) return this.primitiveBlockValue(0);; (CallExpression) this.primitiveBlockValue(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $primitiveBlockValue						return						));; (SwitchCase)  case 10: return this.primitiveBlockValu...						local.get $temp;; (JSLiteral) 10						i32.const 10						i32.eq						(if (then ;; (ReturnStatement) return this.primitiveBlockValue(1);; (CallExpression) this.primitiveBlockValue(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $primitiveBlockValue						return						));; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: doPrimitive -> function(index,...;; (FunctionExpression) function(index, argCount, primMethod) { ...(func $doPrimitive						(local $primMethod i32)						(local $temp i32)						(local $argCount i32)						(local $index i32)						;; (ExpressionStatement) this.success = true;; (AssignmentExpression) this.success = true;; (JSLiteral) true						i32.const 1						local.set $success						;; unwritable: (IfStatement) if (index < 128) {switch (index) { case 						;; unwritable: (ExpressionStatement) console.error('primitive ' + index + ' n;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: namedPrimitive -> function(mod...;; (FunctionExpression) function(modName, functionName, argCount...(func $namedPrimitive						(local $functionName i32)						(local $mod i32)						(local $modName i32)						(local $argCount i32)						(local $primitive i32)						(local $temp i32)						(local $result i32)						;; (IfStatement) if (mod === undefined) {mod = this.loadM...;; (BinaryExpression) mod === undefined;; (JSIdentifier) mod						local.get $mod;; (JSIdentifier) undefined						local.get $undefined						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) mod = this.loadModule(modName) this.load...;; (ExpressionStatement) mod = this.loadModule(modName);; (AssignmentExpression) mod = this.loadModule(modName);; (CallExpression) this.loadModule(modName)						local.get $this;; (JSIdentifier) modName						local.get $modName						call $loadModule						local.set $mod;; (ExpressionStatement) this.loadedModules[modName] = mod;; (AssignmentExpression) this.loadedModules[modName] = mod						local.get $this;; (JSIdentifier) modName						local.get $modName;; (JSIdentifier) mod						local.get $mod						call $atPut))						;; unwritable: (IfStatement) if (mod) {this.interpreterProxy.argCount;; (IfStatement) if (result === true || result === false)...;; (BinaryExpression) result === true || result === false;; (BinaryExpression) result === true;; (JSIdentifier) result						local.get $result;; (JSLiteral) true						i32.const 1						i32.eq;; (BinaryExpression) result === false;; (JSIdentifier) result						local.get $result;; (JSLiteral) false						i32.const 0						i32.eq						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return result;; (JSIdentifier) result						local.get $result						return));; (ReturnStatement) return this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						return);; (JSProperty) property: doNamedPrimitive -> function(a...;; (FunctionExpression) function(argCount, primMethod) { 	if (pr...(func $doNamedPrimitive						(local $functionName i32)						(local $primMethod i32)						(local $moduleName i32)						(local $argCount i32)						(local $firstLiteral i32)						(local $temp i32)						;; (IfStatement) if (primMethod.pointersSize() < 2) {retu...;; (BinaryExpression) primMethod.pointersSize() < 2;; (CallExpression) primMethod.pointersSize()						local.get $primMethod						call $pointersSize;; (JSLiteral) 2						i32.const 2						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (firstLiteral.pointersSize() !== 4) {...;; (BinaryExpression) firstLiteral.pointersSize() !== 4;; (CallExpression) firstLiteral.pointersSize()						local.get $firstLiteral						call $pointersSize;; (JSLiteral) 4						i32.const 4						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.primMethod = primMethod;; (AssignmentExpression) this.primMethod = primMethod;; (JSIdentifier) primMethod						local.get $primMethod						local.set $primMethod;; (ReturnStatement) return this.namedPrimitive(moduleName, f...;; (CallExpression) this.namedPrimitive(moduleName, function...						local.get $this;; (JSIdentifier) moduleName						local.get $moduleName;; (JSIdentifier) functionName						local.get $functionName;; (JSIdentifier) argCount						local.get $argCount						call $namedPrimitive						return);; (JSProperty) property: fakePrimitive -> function(prim...;; (FunctionExpression) function(prim, retVal, argCount) { 	this...(func $fakePrimitive						(local $retVal i32)						(local $argCount i32)						(local $temp i32)						(local $prim i32)												;; unwritable: (ExpressionStatement) this.vm.warnOnce('faking primitive: ' + ;; (IfStatement) if (retVal === undefined) {this.vm.popN(...;; (BinaryExpression) retVal === undefined;; (JSIdentifier) retVal						local.get $retVal;; (JSIdentifier) undefined						local.get $undefined						i32.eq						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.vm.popN(argCount);; (CallExpression) this.vm.popN(argCount)						local.get $vm;; (JSIdentifier) argCount						local.get $argCount						call $popN)						(else;; (ExpressionStatement) this.vm.popNandPush(argCount + 1, this.m...;; (CallExpression) this.vm.popNandPush(argCount + 1, this.m...						local.get $vm;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeStObject(retVal)						local.get $this;; (JSIdentifier) retVal						local.get $retVal						call $makeStObject						call $popNandPush));; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: loadModule -> function(modName...;; (FunctionExpression) function(modName) { 	var mod = Squeak.ex...(func $loadModule						(local $initFunc i32)						(local $mod i32)						(local $modName i32)						(local $temp i32)						;; (IfStatement) if (!mod) {return nil};; (UnaryExpression) !mod;; (JSIdentifier) mod						local.get $mod						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return))						;; unwritable: (ExpressionStatement) this.vm.status('loading module: ' + modN;; (IfStatement) if (this.patchModules[modName]) {this.pa...;; (ComputedMemberExpression) this.patchModules[modName];; (StaticMemberExpression) this.patchModules;; (JSIdentifier) patchModules						local.get $patchModules;; (JSIdentifier) modName						local.get $modName						i32.const 4						i32.mul						i32.add						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.patchModule(mod, modName);; (CallExpression) this.patchModule(mod, modName)						local.get $this;; (JSIdentifier) mod						local.get $mod;; (JSIdentifier) modName						local.get $modName						call $patchModule))						;; unwritable: (IfStatement) if (mod.setInterpreter) {if (!mod.setInt						;; unwritable: (IfStatement) if (typeof initFunc === 'function') {mod						;; unwritable: (IfStatement) if (this.interpreterProxy.failed()) {con						;; unwritable: (ExpressionStatement) this.vm.status('loaded module: ' + modNa						;; unwritable: (ExpressionStatement) console.log('Loaded module: ' + modName);; (ReturnStatement) return mod;; (JSIdentifier) mod						local.get $mod						return);; (JSProperty) property: patchModule -> function(mod, m...;; (FunctionExpression) function(mod, modName) { 	var patch = th...(func $patchModule						(local $modName i32)						(local $key i32)						(local $mod i32)						(local $temp i32)						(local $patch i32)						;; (ForInStatement) an active ForInStatement with properties...);; (JSProperty) property: unloadModule -> function(modNa...;; (FunctionExpression) function(modName) { 	var mod = this.load...(func $unloadModule						(local $unloadFunc i32)						(local $mod i32)						(local $modName i32)						(local $temp i32)						;; (IfStatement) if (!modName || !mod || mod === this) {r...;; (BinaryExpression) !modName || !mod || mod === this;; (BinaryExpression) !modName || !mod;; (UnaryExpression) !modName;; (JSIdentifier) modName						local.get $modName						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !mod;; (JSIdentifier) mod						local.get $mod						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or;; (BinaryExpression) mod === this;; (JSIdentifier) mod						local.get $mod;; (ThisExpression) this						i32.eq						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return))						;; unwritable: (ExpressionStatement) delete this.loadedModules[modName]						;; unwritable: (IfStatement) if (typeof unloadFunc === 'function') {m						;; unwritable: (ExpressionStatement) console.log('Unloaded module: ' + modNam;; (ReturnStatement) return mod;; (JSIdentifier) mod						local.get $mod						return);; (JSProperty) property: loadFunctionFrom -> function(f...;; (FunctionExpression) function(functionName, modName) { 	var m...(func $loadFunctionFrom						(local $functionName i32)						(local $func i32)						(local $mod i32)						(local $modName i32)						(local $temp i32)						;; (IfStatement) if (mod === undefined) {mod = this.loadM...;; (BinaryExpression) mod === undefined;; (JSIdentifier) mod						local.get $mod;; (JSIdentifier) undefined						local.get $undefined						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) mod = this.loadModule(modName) this.load...;; (ExpressionStatement) mod = this.loadModule(modName);; (AssignmentExpression) mod = this.loadModule(modName);; (CallExpression) this.loadModule(modName)						local.get $this;; (JSIdentifier) modName						local.get $modName						call $loadModule						local.set $mod;; (ExpressionStatement) this.loadedModules[modName] = mod;; (AssignmentExpression) this.loadedModules[modName] = mod						local.get $this;; (JSIdentifier) modName						local.get $modName;; (JSIdentifier) mod						local.get $mod						call $atPut));; (IfStatement) if (!mod) {return nil};; (UnaryExpression) !mod;; (JSIdentifier) mod						local.get $mod						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return))						;; unwritable: (IfStatement) if (typeof func === 'function') {return 						;; unwritable: (ExpressionStatement) this.vm.warnOnce('missing primitive: ' +;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return);; (JSProperty) property: primitiveUnloadModule -> funct...;; (FunctionExpression) function(argCount) { 	var moduleName = t...(func $primitiveUnloadModule						(local $temp i32)						(local $argCount i32)						(local $moduleName i32)						;; (IfStatement) if (!moduleName) {return false};; (UnaryExpression) !moduleName;; (JSIdentifier) moduleName						local.get $moduleName						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.unloadModule(moduleName);; (CallExpression) this.unloadModule(moduleName)						local.get $this;; (JSIdentifier) moduleName						local.get $moduleName						call $unloadModule;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: primitiveListBuiltinModule -> ...;; (FunctionExpression) function(argCount) { 	var index = this.s...(func $primitiveListBuiltinModule						(local $temp i32)						(local $moduleNames i32)						(local $argCount i32)						(local $index i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeStObject(moduleNames[index])						local.get $this;; (ComputedMemberExpression) moduleNames[index];; (JSIdentifier) moduleNames						local.get $moduleNames;; (JSIdentifier) index						local.get $index						i32.const 4						i32.mul						i32.add						call $makeStObject						call $popNandPushIfOK						return);; (JSProperty) property: primitiveListLoadedModule -> f...;; (FunctionExpression) function(argCount) { 	var index = this.s...(func $primitiveListLoadedModule						(local $key i32)						(local $moduleName i32)						(local $argCount i32)						(local $moduleNames i32)						(local $index i32)						(local $module i32)						(local $temp i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ForInStatement) an active ForInStatement with properties...;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeStObject(moduleNames[index])						local.get $this;; (ComputedMemberExpression) moduleNames[index];; (JSIdentifier) moduleNames						local.get $moduleNames;; (JSIdentifier) index						local.get $index						i32.const 4						i32.mul						i32.add						call $makeStObject						call $popNandPushIfOK						return);; (JSProperty) property: popNIfOK -> function(nToPop) {...;; (FunctionExpression) function(nToPop) { 	if (!this.success) {...(func $popNIfOK						(local $nToPop i32)						(local $temp i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.vm.popN(nToPop);; (CallExpression) this.vm.popN(nToPop)						local.get $vm;; (JSIdentifier) nToPop						local.get $nToPop						call $popN;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: pop2andPushBoolIfOK -> functio...;; (FunctionExpression) function(bool) { 	this.vm.success = this...(func $pop2andPushBoolIfOK						(local $temp i32)						(local $bool i32)						;; (ExpressionStatement) this.vm.success = this.success;; (AssignmentExpression) this.vm.success = this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $success;; (ReturnStatement) return this.vm.pop2AndPushBoolResult(boo...;; (CallExpression) this.vm.pop2AndPushBoolResult(bool)						local.get $vm;; (JSIdentifier) bool						local.get $bool						call $pop2AndPushBoolResult						return);; (JSProperty) property: popNandPushIfOK -> function(nT...;; (FunctionExpression) function(nToPop, returnValue) { 	if (!th...(func $popNandPushIfOK						(local $nToPop i32)						(local $returnValue i32)						(local $temp i32)						;; (IfStatement) if (!this.success || returnValue == nil)...;; (BinaryExpression) !this.success || returnValue == nil;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (BinaryExpression) returnValue == nil;; (JSIdentifier) returnValue						local.get $returnValue;; (JSLiteral) nil						i32.const 0						i32.eq						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.vm.popNandPush(nToPop, returnValue);; (CallExpression) this.vm.popNandPush(nToPop, returnValue)						local.get $vm;; (JSIdentifier) nToPop						local.get $nToPop;; (JSIdentifier) returnValue						local.get $returnValue						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: popNandPushIntIfOK -> function...;; (FunctionExpression) function(nToPop, returnValue) { 	if (!th...(func $popNandPushIntIfOK						(local $nToPop i32)						(local $returnValue i32)						(local $temp i32)						;; (IfStatement) if (!this.success || !this.vm.canBeSmall...;; (BinaryExpression) !this.success || !this.vm.canBeSmallInt(...;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !this.vm.canBeSmallInt(returnValue);; (CallExpression) this.vm.canBeSmallInt(returnValue)						local.get $vm;; (JSIdentifier) returnValue						local.get $returnValue						call $canBeSmallInt						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ReturnStatement) return this.popNandPushIfOK(nToPop, retu...;; (CallExpression) this.popNandPushIfOK(nToPop, returnValue...						local.get $this;; (JSIdentifier) nToPop						local.get $nToPop;; (JSIdentifier) returnValue						local.get $returnValue						call $popNandPushIfOK						return);; (JSProperty) property: popNandPushFloatIfOK -> functi...;; (FunctionExpression) function(nToPop, returnValue) { 	if (!th...(func $popNandPushFloatIfOK						(local $nToPop i32)						(local $returnValue i32)						(local $temp i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ReturnStatement) return this.popNandPushIfOK(nToPop, this...;; (CallExpression) this.popNandPushIfOK(nToPop, this.makeFl...						local.get $this;; (JSIdentifier) nToPop						local.get $nToPop;; (CallExpression) this.makeFloat(returnValue)						local.get $this;; (JSIdentifier) returnValue						local.get $returnValue						call $makeFloat						call $popNandPushIfOK						return);; (JSProperty) property: stackNonInteger -> function(nD...;; (FunctionExpression) function(nDeep) { 	return this.checkNonI...(func $stackNonInteger						(local $nDeep i32)						(local $temp i32)						;; (ReturnStatement) return this.checkNonInteger(this.vm.stac...;; (CallExpression) this.checkNonInteger(this.vm.stackValue(...						local.get $this;; (CallExpression) this.vm.stackValue(nDeep)						local.get $vm;; (JSIdentifier) nDeep						local.get $nDeep						call $stackValue						call $checkNonInteger						return);; (JSProperty) property: stackInteger -> function(nDeep...;; (FunctionExpression) function(nDeep) { 	return this.checkSmal...(func $stackInteger						(local $nDeep i32)						(local $temp i32)						;; (ReturnStatement) return this.checkSmallInt(this.vm.stackV...;; (CallExpression) this.checkSmallInt(this.vm.stackValue(nD...						local.get $this;; (CallExpression) this.vm.stackValue(nDeep)						local.get $vm;; (JSIdentifier) nDeep						local.get $nDeep						call $stackValue						call $checkSmallInt						return);; (JSProperty) property: stackPos32BitInt -> function(n...;; (FunctionExpression) function(nDeep) { 	return this.positive3...(func $stackPos32BitInt						(local $nDeep i32)						(local $temp i32)						;; (ReturnStatement) return this.positive32BitValueOf(this.vm...;; (CallExpression) this.positive32BitValueOf(this.vm.stackV...						local.get $this;; (CallExpression) this.vm.stackValue(nDeep)						local.get $vm;; (JSIdentifier) nDeep						local.get $nDeep						call $stackValue						call $positive32BitValueOf						return);; (JSProperty) property: pos32BitIntFor -> function(sig...;; (FunctionExpression) function(signed32) { 	if (signed32 >= 0 ...(func $pos32BitIntFor						(local $bytes i32)						(local $signed32 i32)						(local $i i32)						(local $temp i32)						(local $lgIntClass i32)						(local $lgIntObj i32)						;; (IfStatement) if (signed32 >= 0 && signed32 <= Squeak....;; (BinaryExpression) signed32 >= 0 && signed32 <= Squeak.MaxS...;; (BinaryExpression) signed32 >= 0;; (JSIdentifier) signed32						local.get $signed32;; (JSLiteral) 0						i32.const 0						i32.ge_u;; (BinaryExpression) signed32 <= Squeak.MaxSmallInt;; (JSIdentifier) signed32						local.get $signed32;; (StaticMemberExpression) Squeak.MaxSmallInt;; (JSIdentifier) MaxSmallInt						local.get $MaxSmallInt						i32.le_u						i32.and						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return signed32;; (JSIdentifier) signed32						local.get $signed32						return));; (ForStatement) for (var i = 0; i < 4; i++) {bytes[i] = ...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) bytes[i] = signed32 >>> 8 * i & 255;; (AssignmentExpression) bytes[i] = signed32 >>> 8 * i & 255						local.get $'bytes';; (JSIdentifier) i						local.get $i;; (BinaryExpression) signed32 >>> 8 * i & 255;; (BinaryExpression) signed32 >>> 8 * i;; (JSIdentifier) signed32						local.get $signed32;; (BinaryExpression) 8 * i;; (JSLiteral) 8						i32.const 8;; (JSIdentifier) i						local.get $i						i32.mul						i32.shr_u;; (JSLiteral) 255						i32.const 255						i32.and						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return lgIntObj;; (JSIdentifier) lgIntObj						local.get $lgIntObj						return);; (JSProperty) property: pos53BitIntFor -> function(lon...;; (FunctionExpression) function(longlong) { 	if (longlong <= 4....(func $pos53BitIntFor						(local $longlong i32)						(local $bytes i32)						(local $i i32)						(local $sz i32)						(local $temp i32)						(local $lgIntClass i32)						(local $lgIntObj i32)						;; (IfStatement) if (longlong <= 4.294967295e9) {return t...;; (BinaryExpression) longlong <= 4.294967295e9;; (JSIdentifier) longlong						local.get $longlong;; (JSLiteral) 4.294967295e9						i32.const 4294967295						i32.le_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.pos32BitIntFor(longlong);; (CallExpression) this.pos32BitIntFor(longlong)						local.get $this;; (JSIdentifier) longlong						local.get $longlong						call $pos32BitIntFor						return))						;; unwritable: (IfStatement) if (longlong > 9.007199254740991e15) {co;; (EmptyStatement) ;; (ForStatement) for (var i = 0; i < sz; i++) {bytes[i] =...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (BlockStatement) bytes[i] = longlong & 255 longlong /= 25...;; (ExpressionStatement) bytes[i] = longlong & 255;; (AssignmentExpression) bytes[i] = longlong & 255						local.get $'bytes';; (JSIdentifier) i						local.get $i;; (BinaryExpression) longlong & 255;; (JSIdentifier) longlong						local.get $longlong;; (JSLiteral) 255						i32.const 255						i32.and						call $atPut;; (ExpressionStatement) longlong /= 256;; (AssignmentExpression) longlong /= 256;; (JSIdentifier) longlong						local.get $longlong;; (JSLiteral) 256						i32.const 256						i32.sub						local.set $longlong;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < sz;; (JSIdentifier) i						local.get $i;; (JSIdentifier) sz						local.get $sz						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return lgIntObj;; (JSIdentifier) lgIntObj						local.get $lgIntObj						return);; (JSProperty) property: stackSigned32BitInt -> functio...;; (FunctionExpression) function(nDeep) { 	var stackVal = this.v...(func $stackSigned32BitInt						(local $f i32)						(local $value i32)						(local $bytes i32)						(local $stackVal i32)						(local $i i32)						(local $temp i32)						(local $nDeep i32)												;; unwritable: (IfStatement) if (typeof stackVal === 'number') {retur;; (IfStatement) if (stackVal.bytesSize() !== 4) {this.su...;; (BinaryExpression) stackVal.bytesSize() !== 4;; (CallExpression) stackVal.bytesSize()						local.get $stackVal						call $bytesSize;; (JSLiteral) 4						i32.const 4						i32.ne						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return 0 ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return));; (ForStatement) for (var i = 0, f = 1; i < 4; an active ...;; (VariableDeclaration) var i = 0, f = 1;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i;; (VariableDeclarator) f = 1;; (JSLiteral) 1						i32.const 1						local.set $f						(loop $loop_1;; (ExpressionStatement) value += bytes[i] * f;; (AssignmentExpression) value += bytes[i] * f;; (JSIdentifier) value						local.get $value;; (BinaryExpression) bytes[i] * f;; (ComputedMemberExpression) bytes[i];; (JSIdentifier) bytes						local.get $bytes;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add;; (JSIdentifier) f						local.get $f						i32.mul						i32.add						local.set $value;; (SequenceExpression) an active SequenceExpression with proper...;; (BinaryExpression) i < 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.lt_u						i32.const 0						br_if $loop_1);; (IfStatement) if (this.isA(stackVal, Squeak.splOb_Clas...;; (BinaryExpression) this.isA(stackVal, Squeak.splOb_ClassLar...;; (CallExpression) this.isA(stackVal, Squeak.splOb_ClassLar...						local.get $this;; (JSIdentifier) stackVal						local.get $stackVal;; (StaticMemberExpression) Squeak.splOb_ClassLargePositiveInteger;; (JSIdentifier) splOb_ClassLargePositiveInteger						local.get $splOb_ClassLargePositiveInteger						call $isA;; (BinaryExpression) value <= 2147483647;; (JSIdentifier) value						local.get $value;; (JSLiteral) 2147483647						i32.const 2147483647						i32.le_u						i32.and						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return value;; (JSIdentifier) value						local.get $value						return));; (IfStatement) if (this.isA(stackVal, Squeak.splOb_Clas...;; (BinaryExpression) this.isA(stackVal, Squeak.splOb_ClassLar...;; (CallExpression) this.isA(stackVal, Squeak.splOb_ClassLar...						local.get $this;; (JSIdentifier) stackVal						local.get $stackVal;; (StaticMemberExpression) Squeak.splOb_ClassLargeNegativeInteger;; (JSIdentifier) splOb_ClassLargeNegativeInteger						local.get $splOb_ClassLargeNegativeInteger						call $isA;; (BinaryExpression) -value >= -2.147483648e9;; (UnaryExpression) -value;; (JSIdentifier) value						local.get $value						local.set $temp						i32.const 0						local.get $temp						i32.sub;; (UnaryExpression) -2.147483648e9;; (JSLiteral) 2.147483648e9						i32.const 2147483648						local.set $temp						i32.const 0						local.get $temp						i32.sub						i32.ge_u						i32.and						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return -value;; (UnaryExpression) -value;; (JSIdentifier) value						local.get $value						local.set $temp						i32.const 0						local.get $temp						i32.sub						return));; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return);; (JSProperty) property: signed32BitIntegerFor -> funct...;; (FunctionExpression) function(signed32) { 	if (signed32 >= Sq...(func $signed32BitIntegerFor						(local $bytes i32)						(local $signed32 i32)						(local $i i32)						(local $negative i32)						(local $lgIntClass i32)						(local $unsigned i32)						(local $temp i32)						(local $lgIntObj i32)						;; (IfStatement) if (signed32 >= Squeak.MinSmallInt && si...;; (BinaryExpression) signed32 >= Squeak.MinSmallInt && signed...;; (BinaryExpression) signed32 >= Squeak.MinSmallInt;; (JSIdentifier) signed32						local.get $signed32;; (StaticMemberExpression) Squeak.MinSmallInt;; (JSIdentifier) MinSmallInt						local.get $MinSmallInt						i32.ge_u;; (BinaryExpression) signed32 <= Squeak.MaxSmallInt;; (JSIdentifier) signed32						local.get $signed32;; (StaticMemberExpression) Squeak.MaxSmallInt;; (JSIdentifier) MaxSmallInt						local.get $MaxSmallInt						i32.le_u						i32.and						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return signed32;; (JSIdentifier) signed32						local.get $signed32						return));; (ForStatement) for (var i = 0; i < 4; i++) {bytes[i] = ...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) bytes[i] = unsigned >>> 8 * i & 255;; (AssignmentExpression) bytes[i] = unsigned >>> 8 * i & 255						local.get $'bytes';; (JSIdentifier) i						local.get $i;; (BinaryExpression) unsigned >>> 8 * i & 255;; (BinaryExpression) unsigned >>> 8 * i;; (JSIdentifier) unsigned						local.get $unsigned;; (BinaryExpression) 8 * i;; (JSLiteral) 8						i32.const 8;; (JSIdentifier) i						local.get $i						i32.mul						i32.shr_u;; (JSLiteral) 255						i32.const 255						i32.and						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return lgIntObj;; (JSIdentifier) lgIntObj						local.get $lgIntObj						return);; (JSProperty) property: stackFloat -> function(nDeep) ...;; (FunctionExpression) function(nDeep) { 	return this.checkFloa...(func $stackFloat						(local $nDeep i32)						(local $temp i32)						;; (ReturnStatement) return this.checkFloat(this.vm.stackValu...;; (CallExpression) this.checkFloat(this.vm.stackValue(nDeep...						local.get $this;; (CallExpression) this.vm.stackValue(nDeep)						local.get $vm;; (JSIdentifier) nDeep						local.get $nDeep						call $stackValue						call $checkFloat						return);; (JSProperty) property: stackBoolean -> function(nDeep...;; (FunctionExpression) function(nDeep) { 	return this.checkBool...(func $stackBoolean						(local $nDeep i32)						(local $temp i32)						;; (ReturnStatement) return this.checkBoolean(this.vm.stackVa...;; (CallExpression) this.checkBoolean(this.vm.stackValue(nDe...						local.get $this;; (CallExpression) this.vm.stackValue(nDeep)						local.get $vm;; (JSIdentifier) nDeep						local.get $nDeep						call $stackValue						call $checkBoolean						return);; (JSProperty) property: stackSigned53BitInt -> functio...;; (FunctionExpression) function(nDeep) { 	var stackVal = this.v...(func $stackSigned53BitInt						(local $f i32)						(local $bytes i32)						(local $value i32)						(local $stackVal i32)						(local $i i32)						(local $temp i32)						(local $n i32)						(local $nDeep i32)												;; unwritable: (IfStatement) if (typeof stackVal === 'number') {retur;; (IfStatement) if (n <= 7) {var bytes = stackVal.bytes,...;; (BinaryExpression) n <= 7;; (JSIdentifier) n						local.get $n;; (JSLiteral) 7						i32.const 7						i32.le_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) var bytes = stackVal.bytes, value = 0 fo...;; (VariableDeclaration) var bytes = stackVal.bytes, value = 0;; (VariableDeclarator) bytes = stackVal.bytes;; (StaticMemberExpression) stackVal.bytes;; (JSIdentifier) bytes						local.get $bytes						local.set $bytes;; (VariableDeclarator) value = 0;; (JSLiteral) 0						i32.const 0						local.set $value;; (ForStatement) for (var i = 0, f = 1; i < n; an active ...;; (VariableDeclaration) var i = 0, f = 1;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i;; (VariableDeclarator) f = 1;; (JSLiteral) 1						i32.const 1						local.set $f						(loop $loop_1;; (ExpressionStatement) value += bytes[i] * f;; (AssignmentExpression) value += bytes[i] * f;; (JSIdentifier) value						local.get $value;; (BinaryExpression) bytes[i] * f;; (ComputedMemberExpression) bytes[i];; (JSIdentifier) bytes						local.get $bytes;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add;; (JSIdentifier) f						local.get $f						i32.mul						i32.add						local.set $value;; (SequenceExpression) an active SequenceExpression with proper...;; (BinaryExpression) i < n;; (JSIdentifier) i						local.get $i;; (JSIdentifier) n						local.get $n						i32.lt_u						i32.const 0						br_if $loop_1);; (IfStatement) if (value <= 9.007199254740991e15) {if (...;; (BinaryExpression) value <= 9.007199254740991e15;; (JSIdentifier) value						local.get $value;; (JSLiteral) 9.007199254740991e15						i32.const 9007199254740991						i32.le_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (this.isA(stackVal, Squeak.splOb_Clas...;; (IfStatement) if (this.isA(stackVal, Squeak.splOb_Clas...;; (CallExpression) this.isA(stackVal, Squeak.splOb_ClassLar...						local.get $this;; (JSIdentifier) stackVal						local.get $stackVal;; (StaticMemberExpression) Squeak.splOb_ClassLargePositiveInteger;; (JSIdentifier) splOb_ClassLargePositiveInteger						local.get $splOb_ClassLargePositiveInteger						call $isA						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return value;; (JSIdentifier) value						local.get $value						return));; (IfStatement) if (this.isA(stackVal, Squeak.splOb_Clas...;; (CallExpression) this.isA(stackVal, Squeak.splOb_ClassLar...						local.get $this;; (JSIdentifier) stackVal						local.get $stackVal;; (StaticMemberExpression) Squeak.splOb_ClassLargeNegativeInteger;; (JSIdentifier) splOb_ClassLargeNegativeInteger						local.get $splOb_ClassLargeNegativeInteger						call $isA						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return -value;; (UnaryExpression) -value;; (JSIdentifier) value						local.get $value						local.set $temp						i32.const 0						local.get $temp						i32.sub						return))))));; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return);; (JSProperty) property: doBitAnd -> function() { 	var ...;; (FunctionExpression) function() { 	var rcvr = this.stackPos32...(func $doBitAnd						(local $arg i32)						(local $rcvr i32)						(local $temp i32)						;; (IfStatement) if (!this.success) {return 0};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return));; (ReturnStatement) return this.pos32BitIntFor(rcvr & arg);; (CallExpression) this.pos32BitIntFor(rcvr & arg)						local.get $this;; (BinaryExpression) rcvr & arg;; (JSIdentifier) rcvr						local.get $rcvr;; (JSIdentifier) arg						local.get $arg						i32.and						call $pos32BitIntFor						return);; (JSProperty) property: doBitOr -> function() { 	var r...;; (FunctionExpression) function() { 	var rcvr = this.stackPos32...(func $doBitOr						(local $arg i32)						(local $rcvr i32)						(local $temp i32)						;; (IfStatement) if (!this.success) {return 0};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return));; (ReturnStatement) return this.pos32BitIntFor(rcvr | arg);; (CallExpression) this.pos32BitIntFor(rcvr | arg)						local.get $this;; (BinaryExpression) rcvr | arg;; (JSIdentifier) rcvr						local.get $rcvr;; (JSIdentifier) arg						local.get $arg						i32.or						call $pos32BitIntFor						return);; (JSProperty) property: doBitXor -> function() { 	var ...;; (FunctionExpression) function() { 	var rcvr = this.stackPos32...(func $doBitXor						(local $arg i32)						(local $rcvr i32)						(local $temp i32)						;; (IfStatement) if (!this.success) {return 0};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return));; (ReturnStatement) return this.pos32BitIntFor(rcvr ^ arg);; (CallExpression) this.pos32BitIntFor(rcvr ^ arg)						local.get $this;; (BinaryExpression) rcvr ^ arg;; (JSIdentifier) rcvr						local.get $rcvr;; (JSIdentifier) arg						local.get $arg						i32.xor						call $pos32BitIntFor						return);; (JSProperty) property: doBitShift -> function() { 	va...;; (FunctionExpression) function() { 	var rcvr = this.stackPos32...(func $doBitShift						(local $rcvr i32)						(local $temp i32)						(local $result i32)						(local $arg i32)						;; (IfStatement) if (!this.success) {return 0};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return));; (IfStatement) if (result > 0) {return this.pos32BitInt...;; (BinaryExpression) result > 0;; (JSIdentifier) result						local.get $result;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.pos32BitIntFor(this.vm.safeS...;; (CallExpression) this.pos32BitIntFor(this.vm.safeShift(rc...						local.get $this;; (CallExpression) this.vm.safeShift(rcvr, arg)						local.get $vm;; (JSIdentifier) rcvr						local.get $rcvr;; (JSIdentifier) arg						local.get $arg						call $safeShift						call $pos32BitIntFor						return));; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return);; (JSProperty) property: safeFDiv -> function(dividend,...;; (FunctionExpression) function(dividend, divisor) { 	if (divis...(func $safeFDiv						(local $dividend i32)						(local $divisor i32)						(local $temp i32)						;; (IfStatement) if (divisor === 0) {this.success = false...;; (BinaryExpression) divisor === 0;; (JSIdentifier) divisor						local.get $divisor;; (JSLiteral) 0						i32.const 0.0						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return 1 ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return 1;; (JSLiteral) 1						i32.const 1.0						return));; (ReturnStatement) return dividend / divisor;; (BinaryExpression) dividend / divisor;; (JSIdentifier) dividend						local.get $dividend;; (JSIdentifier) divisor						local.get $divisor						i32.div_s						return);; (JSProperty) property: floatAsSmallInt -> function(fl...;; (FunctionExpression) function(float) { 	var truncated = float...(func $floatAsSmallInt						(local $temp i32)						(local $truncated i32)						(local $float i32)						;; (ReturnStatement) return this.ensureSmallInt(truncated);; (CallExpression) this.ensureSmallInt(truncated)						local.get $this;; (JSIdentifier) truncated						local.get $truncated						call $ensureSmallInt						return);; (JSProperty) property: frexp_exponent -> function(val...;; (FunctionExpression) function(value) { 	if (value == 0) {retu...(func $frexp_exponent						(local $data i32)						(local $value i32)						(local $bits i32)						(local $exponent i32)						(local $temp i32)						;; (IfStatement) if (value == 0) {return 0};; (BinaryExpression) value == 0;; (JSIdentifier) value						local.get $value;; (JSLiteral) 0						i32.const 0.0						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return));; (ExpressionStatement) data.setFloat64(0, value);; (CallExpression) data.setFloat64(0, value)						local.get $data;; (JSLiteral) 0						i32.const 0;; (JSIdentifier) value						local.get $value						call $setFloat64						;; unwritable: (IfStatement) if (bits === 0) {data.setFloat64(0, valu;; (ReturnStatement) return exponent;; (JSIdentifier) exponent						local.get $exponent						return);; (JSProperty) property: ldexp -> function(mantissa, ex...;; (FunctionExpression) function(mantissa, exponent) { 	var step...(func $ldexp						(local $steps i32)						(local $exponent i32)						(local $mantissa i32)						(local $i i32)						(local $temp i32)						(local $result i32)												;; unwritable: (ForStatement) for (var i = 0; i < steps; i++) {result ;; (ReturnStatement) return result;; (JSIdentifier) result						local.get $result						return);; (JSProperty) property: primitiveHashMultiply -> funct...;; (FunctionExpression) function() { 	var receiver = this.stackS...(func $primitiveHashMultiply						(local $receiver i32)						(local $low i32)						(local $temp i32)						;; (ReturnStatement) return this.popNandPushIfOK(1, 9741 * lo...;; (CallExpression) this.popNandPushIfOK(1, 9741 * low + 974...						local.get $this;; (JSLiteral) 1						i32.const 1;; (BinaryExpression) 9741 * low + 9741 * receiver << 14 + 101...;; (BinaryExpression) 9741 * low + 9741 * receiver << 14 + 101...;; (BinaryExpression) 9741 * low;; (JSLiteral) 9741						i32.const 9741;; (JSIdentifier) low						local.get $low						i32.mul;; (BinaryExpression) 9741 * receiver << 14 + 101 * low & 1638...;; (BinaryExpression) 9741 * receiver << 14 + 101 * low & 1638...;; (BinaryExpression) 9741 * receiver << 14 + 101 * low;; (BinaryExpression) 9741 * receiver << 14;; (JSLiteral) 9741						i32.const 9741;; (BinaryExpression) receiver << 14;; (JSIdentifier) receiver						local.get $receiver;; (JSLiteral) 14						i32.const 14						i32.shl						i32.mul;; (BinaryExpression) 101 * low;; (JSLiteral) 101						i32.const 101;; (JSIdentifier) low						local.get $low						i32.mul						i32.add;; (JSLiteral) 16383						i32.const 16383						i32.and;; (JSLiteral) 16384						i32.const 16384						i32.mul						i32.add;; (JSLiteral) 268435455						i32.const 268435455						i32.and						call $popNandPushIfOK						return);; (JSProperty) property: primitiveLessThanLargeIntegers...;; (FunctionExpression) function() { 	return this.pop2andPushBoo...(func $primitiveLessThanLargeIntegers						(local $temp i32)						;; (ReturnStatement) return this.pop2andPushBoolIfOK(this.sta...;; (CallExpression) this.pop2andPushBoolIfOK(this.stackSigne...						local.get $this;; (BinaryExpression) this.stackSigned53BitInt(1) < this.stack...;; (CallExpression) this.stackSigned53BitInt(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackSigned53BitInt;; (CallExpression) this.stackSigned53BitInt(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackSigned53BitInt						i32.lt_u						call $pop2andPushBoolIfOK						return);; (JSProperty) property: primitiveGreaterThanLargeInteg...;; (FunctionExpression) function() { 	return this.pop2andPushBoo...(func $primitiveGreaterThanLargeIntegers						(local $temp i32)						;; (ReturnStatement) return this.pop2andPushBoolIfOK(this.sta...;; (CallExpression) this.pop2andPushBoolIfOK(this.stackSigne...						local.get $this;; (BinaryExpression) this.stackSigned53BitInt(1) > this.stack...;; (CallExpression) this.stackSigned53BitInt(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackSigned53BitInt;; (CallExpression) this.stackSigned53BitInt(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackSigned53BitInt						i32.gt_u						call $pop2andPushBoolIfOK						return);; (JSProperty) property: primitiveLessOrEqualLargeInteg...;; (FunctionExpression) function() { 	return this.pop2andPushBoo...(func $primitiveLessOrEqualLargeIntegers						(local $temp i32)						;; (ReturnStatement) return this.pop2andPushBoolIfOK(this.sta...;; (CallExpression) this.pop2andPushBoolIfOK(this.stackSigne...						local.get $this;; (BinaryExpression) this.stackSigned53BitInt(1) <= this.stac...;; (CallExpression) this.stackSigned53BitInt(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackSigned53BitInt;; (CallExpression) this.stackSigned53BitInt(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackSigned53BitInt						i32.le_u						call $pop2andPushBoolIfOK						return);; (JSProperty) property: primitiveGreaterOrEqualLargeIn...;; (FunctionExpression) function() { 	return this.pop2andPushBoo...(func $primitiveGreaterOrEqualLargeIntegers						(local $temp i32)						;; (ReturnStatement) return this.pop2andPushBoolIfOK(this.sta...;; (CallExpression) this.pop2andPushBoolIfOK(this.stackSigne...						local.get $this;; (BinaryExpression) this.stackSigned53BitInt(1) >= this.stac...;; (CallExpression) this.stackSigned53BitInt(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackSigned53BitInt;; (CallExpression) this.stackSigned53BitInt(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackSigned53BitInt						i32.ge_u						call $pop2andPushBoolIfOK						return);; (JSProperty) property: primitiveEqualLargeIntegers ->...;; (FunctionExpression) function() { 	return this.pop2andPushBoo...(func $primitiveEqualLargeIntegers						(local $temp i32)						;; (ReturnStatement) return this.pop2andPushBoolIfOK(this.sta...;; (CallExpression) this.pop2andPushBoolIfOK(this.stackSigne...						local.get $this;; (BinaryExpression) this.stackSigned53BitInt(1) === this.sta...;; (CallExpression) this.stackSigned53BitInt(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackSigned53BitInt;; (CallExpression) this.stackSigned53BitInt(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackSigned53BitInt						i32.eq						call $pop2andPushBoolIfOK						return);; (JSProperty) property: primitiveNotEqualLargeIntegers...;; (FunctionExpression) function() { 	return this.pop2andPushBoo...(func $primitiveNotEqualLargeIntegers						(local $temp i32)						;; (ReturnStatement) return this.pop2andPushBoolIfOK(this.sta...;; (CallExpression) this.pop2andPushBoolIfOK(this.stackSigne...						local.get $this;; (BinaryExpression) this.stackSigned53BitInt(1) !== this.sta...;; (CallExpression) this.stackSigned53BitInt(1)						local.get $this;; (JSLiteral) 1						i32.const 1						call $stackSigned53BitInt;; (CallExpression) this.stackSigned53BitInt(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackSigned53BitInt						i32.ne						call $pop2andPushBoolIfOK						return);; (JSProperty) property: floatOrInt -> function(obj) { ...;; (FunctionExpression) function(obj) { 	if (obj.isFloat) {retur...(func $floatOrInt						(local $obj i32)						(local $temp i32)						;; (IfStatement) if (obj.isFloat) {return obj.float};; (StaticMemberExpression) obj.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return obj.float;; (StaticMemberExpression) obj.float;; (JSIdentifier) float						local.get $float						return))						;; unwritable: (IfStatement) if (typeof obj === 'number') {return obj;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return);; (JSProperty) property: positive32BitValueOf -> functi...;; (FunctionExpression) function(obj) { 	if (typeof obj === 'num...(func $positive32BitValueOf						(local $f i32)						(local $bytes i32)						(local $value i32)						(local $i i32)						(local $temp i32)						(local $obj i32)												;; unwritable: (IfStatement) if (typeof obj === 'number') {if (obj >=;; (IfStatement) if (!this.isA(obj, Squeak.splOb_ClassLar...;; (BinaryExpression) !this.isA(obj, Squeak.splOb_ClassLargePo...;; (UnaryExpression) !this.isA(obj, Squeak.splOb_ClassLargePo...;; (CallExpression) this.isA(obj, Squeak.splOb_ClassLargePos...						local.get $this;; (JSIdentifier) obj						local.get $obj;; (StaticMemberExpression) Squeak.splOb_ClassLargePositiveInteger;; (JSIdentifier) splOb_ClassLargePositiveInteger						local.get $splOb_ClassLargePositiveInteger						call $isA						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (BinaryExpression) obj.bytesSize() !== 4;; (CallExpression) obj.bytesSize()						local.get $obj						call $bytesSize;; (JSLiteral) 4						i32.const 4						i32.ne						i32.or						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return 0 ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return));; (ForStatement) for (var i = 0, f = 1; i < 4; an active ...;; (VariableDeclaration) var i = 0, f = 1;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i;; (VariableDeclarator) f = 1;; (JSLiteral) 1						i32.const 1						local.set $f						(loop $loop_1;; (ExpressionStatement) value += bytes[i] * f;; (AssignmentExpression) value += bytes[i] * f;; (JSIdentifier) value						local.get $value;; (BinaryExpression) bytes[i] * f;; (ComputedMemberExpression) bytes[i];; (JSIdentifier) bytes						local.get $bytes;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add;; (JSIdentifier) f						local.get $f						i32.mul						i32.add						local.set $value;; (SequenceExpression) an active SequenceExpression with proper...;; (BinaryExpression) i < 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return value;; (JSIdentifier) value						local.get $value						return);; (JSProperty) property: checkFloat -> function(maybeFl...;; (FunctionExpression) function(maybeFloat) { 	if (maybeFloat.i...(func $checkFloat						(local $maybeFloat i32)						(local $temp i32)						;; (IfStatement) if (maybeFloat.isFloat) {return maybeFlo...;; (StaticMemberExpression) maybeFloat.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return maybeFloat.float;; (StaticMemberExpression) maybeFloat.float;; (JSIdentifier) float						local.get $float						return))						;; unwritable: (IfStatement) if (typeof maybeFloat === 'number') {ret;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0.0						return);; (JSProperty) property: checkSmallInt -> function(mayb...;; (FunctionExpression) function(maybeSmall) { 	if (typeof maybe...(func $checkSmallInt						(local $maybeSmall i32)						(local $temp i32)												;; unwritable: (IfStatement) if (typeof maybeSmall === 'number') {ret;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return);; (JSProperty) property: checkNonInteger -> function(ob...;; (FunctionExpression) function(obj) { 	if (typeof obj !== 'num...(func $checkNonInteger						(local $obj i32)						(local $temp i32)												;; unwritable: (IfStatement) if (typeof obj !== 'number') {return obj;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return this.vm.nilObj;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						return);; (JSProperty) property: checkBoolean -> function(obj) ...;; (FunctionExpression) function(obj) { 	if (obj.isTrue) {return...(func $checkBoolean						(local $obj i32)						(local $temp i32)						;; (IfStatement) if (obj.isTrue) {return true};; (StaticMemberExpression) obj.isTrue;; (JSIdentifier) isTrue						local.get $isTrue						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return));; (IfStatement) if (obj.isFalse) {return false};; (StaticMemberExpression) obj.isFalse;; (JSIdentifier) isFalse						local.get $isFalse						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ReturnStatement) return this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success						return);; (JSProperty) property: indexableSize -> function(obj)...;; (FunctionExpression) function(obj) { 	if (typeof obj === 'num...(func $indexableSize						(local $obj i32)						(local $temp i32)												;; unwritable: (IfStatement) if (typeof obj === 'number') {return -1};; (ReturnStatement) return obj.indexableSize(this);; (CallExpression) obj.indexableSize(this)						local.get $obj;; (ThisExpression) this						call $indexableSize						return);; (JSProperty) property: isA -> function(obj, knownClas...;; (FunctionExpression) function(obj, knownClass) { 	return obj....(func $isA						(local $obj i32)						(local $knownClass i32)						(local $temp i32)						;; (ReturnStatement) return obj.sqClass === this.vm.specialOb...;; (BinaryExpression) obj.sqClass === this.vm.specialObjects[k...;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) this.vm.specialObjects[knownClass];; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (JSIdentifier) knownClass						local.get $knownClass						i32.const 4						i32.mul						i32.add						i32.eq						return);; (JSProperty) property: isKindOf -> function(obj, know...;; (FunctionExpression) function(obj, knownClass) { 	var classOr...(func $isKindOf						(local $classOrSuper i32)						(local $knownClass i32)						(local $temp i32)						(local $obj i32)						(local $theClass i32)						;; (WhileStatement) while (!classOrSuper.isNil) {if (classOr...						(loop $loop_1;; (BlockStatement) if (classOrSuper === theClass) {return t...;; (IfStatement) if (classOrSuper === theClass) {return t...;; (BinaryExpression) classOrSuper === theClass;; (JSIdentifier) classOrSuper						local.get $classOrSuper;; (JSIdentifier) theClass						local.get $theClass						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return));; (ExpressionStatement) classOrSuper = classOrSuper.pointers[Squ...;; (AssignmentExpression) classOrSuper = classOrSuper.pointers[Squ...;; (ComputedMemberExpression) classOrSuper.pointers[Squeak.Class_super...;; (StaticMemberExpression) classOrSuper.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Class_superclass;; (JSIdentifier) Class_superclass						local.get $Class_superclass						i32.const 4						i32.mul						i32.add						local.set $classOrSuper;; (UnaryExpression) !classOrSuper.isNil;; (StaticMemberExpression) classOrSuper.isNil;; (JSIdentifier) isNil						local.get $isNil						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: isAssociation -> function(obj)...;; (FunctionExpression) function(obj) { 	return obj.sqClass && o...(func $isAssociation						(local $obj i32)						(local $temp i32)						;; (ReturnStatement) return obj.sqClass && obj.sqClass.pointe...;; (BinaryExpression) obj.sqClass && obj.sqClass.pointers[0] =...;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (BinaryExpression) obj.sqClass.pointers[0] === this.vm.spec...;; (ComputedMemberExpression) obj.sqClass.pointers[0];; (StaticMemberExpression) obj.sqClass.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Sche...;; (StaticMemberExpression) this.vm.specialObjects[Squeak.splOb_Sche...;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add						i32.eq						i32.and						return);; (JSProperty) property: ensureSmallInt -> function(num...;; (FunctionExpression) function(number) { 	if (number === numbe...(func $ensureSmallInt						(local $number i32)						(local $temp i32)						;; (IfStatement) if (number === number | 0 && this.vm.can...;; (BinaryExpression) number === number | 0 && this.vm.canBeSm...;; (BinaryExpression) number === number | 0;; (JSIdentifier) number						local.get $number;; (BinaryExpression) number | 0;; (JSIdentifier) number						local.get $number;; (JSLiteral) 0						i32.const 0						i32.or						i32.eq;; (CallExpression) this.vm.canBeSmallInt(number)						local.get $vm;; (JSIdentifier) number						local.get $number						call $canBeSmallInt						i32.and						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return number;; (JSIdentifier) number						local.get $number						return));; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return);; (JSProperty) property: charFromInt -> function(ascii)...;; (FunctionExpression) function(ascii) { 	var charTable = this....(func $charFromInt						(local $char i32)						(local $charClass i32)						(local $ascii i32)						(local $temp i32)						(local $charTable i32)						;; (IfStatement) if (char) {return char};; (JSIdentifier) char						local.get $char						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return char;; (JSIdentifier) char						local.get $char						return));; (ExpressionStatement) char = this.vm.instantiateClass(charClas...;; (AssignmentExpression) char = this.vm.instantiateClass(charClas...;; (CallExpression) this.vm.instantiateClass(charClass, 0)						local.get $vm;; (JSIdentifier) charClass						local.get $charClass;; (JSLiteral) 0						i32.const 0						call $instantiateClass						local.set $char;; (ExpressionStatement) char.pointers[0] = ascii;; (AssignmentExpression) char.pointers[0] = ascii						local.get $char;; (JSLiteral) 0						i32.const 0;; (JSIdentifier) ascii						local.get $ascii						call $atPut;; (ReturnStatement) return char;; (JSIdentifier) char						local.get $char						return);; (JSProperty) property: charFromIntSpur -> function(un...;; (FunctionExpression) function(unicode) { 	return this.vm.imag...(func $charFromIntSpur						(local $temp i32)						(local $unicode i32)						;; (ReturnStatement) return this.vm.image.getCharacter(unicod...;; (CallExpression) this.vm.image.getCharacter(unicode)						local.get $vm.image;; (JSIdentifier) unicode						local.get $unicode						call $getCharacter						return);; (JSProperty) property: charToInt -> function(obj) { 	...;; (FunctionExpression) function(obj) { 	return obj.pointers[0] ...(func $charToInt						(local $obj i32)						(local $temp i32)						;; (ReturnStatement) return obj.pointers[0];; (ComputedMemberExpression) obj.pointers[0];; (StaticMemberExpression) obj.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: charToIntSpur -> function(obj)...;; (FunctionExpression) function(obj) { 	return obj.hash }(func $charToIntSpur						(local $obj i32)						(local $temp i32)						;; (ReturnStatement) return obj.hash;; (StaticMemberExpression) obj.hash;; (JSIdentifier) hash						local.get $hash						return);; (JSProperty) property: makeFloat -> function(value) {...;; (FunctionExpression) function(value) { 	var floatClass = this...(func $makeFloat						(local $value i32)						(local $newFloat i32)						(local $temp i32)						(local $floatClass i32)						;; (ExpressionStatement) newFloat.float = value;; (AssignmentExpression) newFloat.float = value;; (JSIdentifier) value						local.get $value						local.set $float;; (ReturnStatement) return newFloat;; (JSIdentifier) newFloat						local.get $newFloat						return);; (JSProperty) property: makeLargeIfNeeded -> function(...;; (FunctionExpression) function(integer) { 	return this.vm.canB...(func $makeLargeIfNeeded						(local $integer i32)						(local $temp i32)						;; (ReturnStatement) return this.vm.canBeSmallInt(integer) ? ...;; (ConditionalExpression) this.vm.canBeSmallInt(integer) ? integer...;; (CallExpression) this.vm.canBeSmallInt(integer)						local.get $vm;; (JSIdentifier) integer						local.get $integer						call $canBeSmallInt						i32.const 1						i32.eq						(if (then;; (JSIdentifier) integer						local.get $integer)						(else;; (CallExpression) this.makeLargeInt(integer)						local.get $this;; (JSIdentifier) integer						local.get $integer						call $makeLargeInt						))						return);; (JSProperty) property: makeLargeInt -> function(integ...;; (FunctionExpression) function(integer) { 	if (integer < 0) {t...(func $makeLargeInt						(local $integer i32)						(local $temp i32)						;; (IfStatement) if (integer < 0) {throw Error('negative ...;; (BinaryExpression) integer < 0;; (JSIdentifier) integer						local.get $integer;; (JSLiteral) 0						i32.const 0						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('negative large ints not imp...						unreachable));; (IfStatement) if (integer > 4.294967295e9) {throw Erro...;; (BinaryExpression) integer > 4.294967295e9;; (JSIdentifier) integer						local.get $integer;; (JSLiteral) 4.294967295e9						i32.const 4294967295						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('large large ints not implem...						unreachable));; (ReturnStatement) return this.pos32BitIntFor(integer);; (CallExpression) this.pos32BitIntFor(integer)						local.get $this;; (JSIdentifier) integer						local.get $integer						call $pos32BitIntFor						return);; (JSProperty) property: makePointWithXandY -> function...;; (FunctionExpression) function(x, y) { 	var pointClass = this....(func $makePointWithXandY						(local $x i32)						(local $newPoint i32)						(local $y i32)						(local $temp i32)						(local $pointClass i32)						;; (ExpressionStatement) newPoint.pointers[Squeak.Point_x] = x;; (AssignmentExpression) newPoint.pointers[Squeak.Point_x] = x						local.get $newPoint;; (StaticMemberExpression) Squeak.Point_x;; (JSIdentifier) Point_x						local.get $Point_x;; (JSIdentifier) x						local.get $x						call $atPut;; (ExpressionStatement) newPoint.pointers[Squeak.Point_y] = y;; (AssignmentExpression) newPoint.pointers[Squeak.Point_y] = y						local.get $newPoint;; (StaticMemberExpression) Squeak.Point_y;; (JSIdentifier) Point_y						local.get $Point_y;; (JSIdentifier) y						local.get $y						call $atPut;; (ReturnStatement) return newPoint;; (JSIdentifier) newPoint						local.get $newPoint						return);; (JSProperty) property: makeStArray -> function(jsArra...;; (FunctionExpression) function(jsArray, proxyClass) { 	var arr...(func $makeStArray						(local $array i32)						(local $i i32)						(local $temp i32)						(local $jsArray i32)						(local $proxyClass i32)						;; (ForStatement) for (var i = 0; i < jsArray.length; i++)...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) array.pointers[i] = this.makeStObject(js...;; (AssignmentExpression) array.pointers[i] = this.makeStObject(js...						local.get $array;; (JSIdentifier) i						local.get $i;; (CallExpression) this.makeStObject(jsArray[i], proxyClass...						local.get $this;; (ComputedMemberExpression) jsArray[i];; (JSIdentifier) jsArray						local.get $jsArray;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add;; (JSIdentifier) proxyClass						local.get $proxyClass						call $makeStObject						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < jsArray.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) jsArray.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return array;; (JSIdentifier) array						local.get $array						return);; (JSProperty) property: makeStString -> function(jsStr...;; (FunctionExpression) function(jsString) { 	var bytes = [] for...(func $makeStString						(local $bytes i32)						(local $jsString i32)						(local $stString i32)						(local $i i32)						(local $temp i32)						;; (ForStatement) for (var i = 0; i < jsString.length; ++i...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) bytes.push(jsString.charCodeAt(i) & 255);; (CallExpression) bytes.push(jsString.charCodeAt(i) & 255)						local.get $bytes;; (BinaryExpression) jsString.charCodeAt(i) & 255;; (CallExpression) jsString.charCodeAt(i)						local.get $jsString;; (JSIdentifier) i						local.get $i						call $charCodeAt;; (JSLiteral) 255						i32.const 255						i32.and						call $push;; (UpdateExpression) ++i;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < jsString.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) jsString.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_1);; (ExpressionStatement) stString.bytes = bytes;; (AssignmentExpression) stString.bytes = bytes;; (JSIdentifier) bytes						local.get $bytes						local.set $bytes;; (ReturnStatement) return stString;; (JSIdentifier) stString						local.get $stString						return);; (JSProperty) property: makeStObject -> function(obj, ...;; (FunctionExpression) function(obj, proxyClass) { 	if (obj ===...(func $makeStObject						(local $temp i32)						(local $proxyClass i32)						(local $obj i32)						(local $stObj i32)						;; (IfStatement) if (obj === undefined || obj === nil) {r...;; (BinaryExpression) obj === undefined || obj === nil;; (BinaryExpression) obj === undefined;; (JSIdentifier) obj						local.get $obj;; (JSIdentifier) undefined						local.get $undefined						i32.eq;; (BinaryExpression) obj === nil;; (JSIdentifier) obj						local.get $obj;; (JSLiteral) nil						i32.const 0						i32.eq						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.vm.nilObj;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						return));; (IfStatement) if (obj === true) {return this.vm.trueOb...;; (BinaryExpression) obj === true;; (JSIdentifier) obj						local.get $obj;; (JSLiteral) true						i32.const 1						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.vm.trueObj;; (StaticMemberExpression) this.vm.trueObj;; (JSIdentifier) trueObj						local.get $trueObj						return));; (IfStatement) if (obj === false) {return this.vm.false...;; (BinaryExpression) obj === false;; (JSIdentifier) obj						local.get $obj;; (JSLiteral) false						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.vm.falseObj;; (StaticMemberExpression) this.vm.falseObj;; (JSIdentifier) falseObj						local.get $falseObj						return));; (TryStatement) an active TryStatement with properties: ...						;; unwritable: (IfStatement) if (typeof obj === 'number') {if (obj ==;; (IfStatement) if (proxyClass) {var stObj = this.vm.ins...;; (JSIdentifier) proxyClass						local.get $proxyClass						i32.const 0						i32.ne						(if (then;; (BlockStatement) var stObj = this.vm.instantiateClass(pro...;; (VariableDeclaration) var stObj = this.vm.instantiateClass(pro...;; (VariableDeclarator) stObj = this.vm.instantiateClass(proxyCl...;; (CallExpression) this.vm.instantiateClass(proxyClass, 0)						local.get $vm;; (JSIdentifier) proxyClass						local.get $proxyClass;; (JSLiteral) 0						i32.const 0						call $instantiateClass						local.set $stObj;; (ExpressionStatement) stObj.jsObject = obj;; (AssignmentExpression) stObj.jsObject = obj;; (JSIdentifier) obj						local.get $obj						local.set $jsObject;; (ReturnStatement) return stObj;; (JSIdentifier) stObj						local.get $stObj						return))						;; unwritable: (IfStatement) if (typeof obj === 'string' || obj.const						;; unwritable: (IfStatement) if (obj.constructor.name === 'Array') {r;; (ThrowStatement) throw Error('cannot make smalltalk objec...						unreachable);; (JSProperty) property: pointsTo -> function(rcvr, arg...;; (FunctionExpression) function(rcvr, arg) { 	if (!rcvr.pointer...(func $pointsTo						(local $arg i32)						(local $rcvr i32)						(local $temp i32)						;; (IfStatement) if (!rcvr.pointers) {return false};; (UnaryExpression) !rcvr.pointers;; (StaticMemberExpression) rcvr.pointers;; (JSIdentifier) pointers						local.get $pointers						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ReturnStatement) return rcvr.pointers.indexOf(arg) >= 0;; (BinaryExpression) rcvr.pointers.indexOf(arg) >= 0;; (CallExpression) rcvr.pointers.indexOf(arg)						local.get $rcvr.pointers;; (JSIdentifier) arg						local.get $arg						call $indexOf;; (JSLiteral) 0						i32.const 0						i32.ge_u						return);; (JSProperty) property: asUint8Array -> function(buffe...;; (FunctionExpression) function(buffer) { 	if (buffer.construct...(func $asUint8Array						(local $array i32)						(local $buffer i32)						(local $i i32)						(local $temp i32)												;; unwritable: (IfStatement) if (buffer.constructor.name === 'Uint8Ar						;; unwritable: (IfStatement) if (buffer.constructor.name === 'ArrayBu						;; unwritable: (IfStatement) if (typeof buffer === 'string') {var arr;; (ThrowStatement) throw Error('unknown buffer type')						unreachable);; (JSProperty) property: filenameToSqueak -> function(u...;; (FunctionExpression) function(unixpath) { 	var slash = unixpa...(func $filenameToSqueak						(local $filepath i32)						(local $temp i32)						(local $slash i32)						(local $unixpath i32)												;; unwritable: (IfStatement) if (this.emulateMac) {filepath = 'Macint;; (ReturnStatement) return filepath;; (JSIdentifier) filepath						local.get $filepath						return);; (JSProperty) property: filenameFromSqueak -> function...;; (FunctionExpression) function(filepath) { 	var unixpath = !th...(func $filenameFromSqueak						(local $filepath i32)						(local $unixpath i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) unixpath = unixpath.replace(/^\/*SqueakJ;; (ReturnStatement) return unixpath;; (JSIdentifier) unixpath						local.get $unixpath						return);; (JSProperty) property: objectAt -> function(cameFromB...;; (FunctionExpression) function(cameFromBytecode, convertChars,...(func $objectAt						(local $temp i32)						(local $offset i32)						(local $array i32)						(local $floatData i32)						(local $convertChars i32)						(local $index i32)						(local $cameFromBytecode i32)						(local $info i32)						(local $includeInstVars i32)						;; (IfStatement) if (!this.success) {return array};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return array;; (JSIdentifier) array						local.get $array						return));; (IfStatement) if (cameFromBytecode) {info = this.atCac...;; (JSIdentifier) cameFromBytecode						local.get $cameFromBytecode						i32.const 0						i32.ne						(if (then;; (BlockStatement) info = this.atCache[array.hash & this.at...;; (ExpressionStatement) info = this.atCache[array.hash & this.at...;; (AssignmentExpression) info = this.atCache[array.hash & this.at...;; (ComputedMemberExpression) this.atCache[array.hash & this.atCacheMa...;; (StaticMemberExpression) this.atCache;; (JSIdentifier) atCache						local.get $atCache;; (BinaryExpression) array.hash & this.atCacheMask;; (StaticMemberExpression) array.hash;; (JSIdentifier) hash						local.get $hash;; (StaticMemberExpression) this.atCacheMask;; (JSIdentifier) atCacheMask						local.get $atCacheMask						i32.and						i32.const 4						i32.mul						i32.add						local.set $info;; (IfStatement) if (info.array !== array) {this.success ...;; (BinaryExpression) info.array !== array;; (StaticMemberExpression) info.array;; (JSIdentifier) array						local.get $array;; (JSIdentifier) array						local.get $array						i32.ne						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return array ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return array;; (JSIdentifier) array						local.get $array						return)))						(else;; (BlockStatement) if (array.isFloat) {var floatData = arra...;; (IfStatement) if (array.isFloat) {var floatData = arra...;; (StaticMemberExpression) array.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						i32.const 0						i32.ne						(if (then;; (BlockStatement) var floatData = array.floatData() if (in...;; (VariableDeclaration) var floatData = array.floatData();; (VariableDeclarator) floatData = array.floatData();; (CallExpression) array.floatData()						local.get $array						call $floatData						local.set $floatData;; (IfStatement) if (index == 1) {return this.pos32BitInt...;; (BinaryExpression) index == 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.pos32BitIntFor(floatData.get...;; (CallExpression) this.pos32BitIntFor(floatData.getUint32(...						local.get $this;; (CallExpression) floatData.getUint32(0, false)						local.get $floatData;; (JSLiteral) 0						i32.const 0;; (JSLiteral) false						i32.const 0						call $getUint32						call $pos32BitIntFor						return));; (IfStatement) if (index == 2) {return this.pos32BitInt...;; (BinaryExpression) index == 2;; (JSIdentifier) index						local.get $index;; (JSLiteral) 2						i32.const 2						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.pos32BitIntFor(floatData.get...;; (CallExpression) this.pos32BitIntFor(floatData.getUint32(...						local.get $this;; (CallExpression) floatData.getUint32(4, false)						local.get $floatData;; (JSLiteral) 4						i32.const 4;; (JSLiteral) false						i32.const 0						call $getUint32						call $pos32BitIntFor						return));; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return array;; (JSIdentifier) array						local.get $array						return));; (ExpressionStatement) info = this.makeAtCacheInfo(this.atCache...;; (AssignmentExpression) info = this.makeAtCacheInfo(this.atCache...;; (CallExpression) this.makeAtCacheInfo(this.atCache, this....						local.get $this;; (StaticMemberExpression) this.atCache;; (JSIdentifier) atCache						local.get $atCache;; (ComputedMemberExpression) this.vm.specialSelectors[32];; (StaticMemberExpression) this.vm.specialSelectors;; (JSIdentifier) specialSelectors						local.get $specialSelectors;; (JSLiteral) 32						i32.const 32						i32.const 4						i32.mul						i32.add;; (JSIdentifier) array						local.get $array;; (JSIdentifier) convertChars						local.get $convertChars;; (JSIdentifier) includeInstVars						local.get $includeInstVars						call $makeAtCacheInfo						local.set $info));; (IfStatement) if (index < 1 || index > info.size) {thi...;; (BinaryExpression) index < 1 || index > info.size;; (BinaryExpression) index < 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.lt_u;; (BinaryExpression) index > info.size;; (JSIdentifier) index						local.get $index;; (StaticMemberExpression) info.size;; (JSIdentifier) size						local.get $size						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return array ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return array;; (JSIdentifier) array						local.get $array						return));; (IfStatement) if (includeInstVars) {return array.point...;; (JSIdentifier) includeInstVars						local.get $includeInstVars						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return array.pointers[index - 1];; (ComputedMemberExpression) array.pointers[index - 1];; (StaticMemberExpression) array.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) index - 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.sub						i32.const 4						i32.mul						i32.add						return));; (IfStatement) if (array.isPointers()) {return array.po...;; (CallExpression) array.isPointers()						local.get $array						call $isPointers						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return array.pointers[index - 1 + info.i...;; (ComputedMemberExpression) array.pointers[index - 1 + info.ivarOffs...;; (StaticMemberExpression) array.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) index - 1 + info.ivarOffset;; (BinaryExpression) index - 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.sub;; (StaticMemberExpression) info.ivarOffset;; (JSIdentifier) ivarOffset						local.get $ivarOffset						i32.add						i32.const 4						i32.mul						i32.add						return));; (IfStatement) if (array.isWords()) {if (info.convertCh...;; (CallExpression) array.isWords()						local.get $array						call $isWords						i32.const 0						i32.ne						(if (then;; (IfStatement) if (info.convertChars) {return this.char...;; (StaticMemberExpression) info.convertChars;; (JSIdentifier) convertChars						local.get $convertChars						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.charFromInt(array.words[inde...;; (CallExpression) this.charFromInt(array.words[index - 1] ...						local.get $this;; (BinaryExpression) array.words[index - 1] & 1073741823;; (ComputedMemberExpression) array.words[index - 1];; (StaticMemberExpression) array.words;; (JSIdentifier) words						local.get $words;; (BinaryExpression) index - 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.sub						i32.const 4						i32.mul						i32.add;; (JSLiteral) 1073741823						i32.const 1073741823						i32.and						call $charFromInt						return)						(else;; (ReturnStatement) return this.pos32BitIntFor(array.words[i...;; (CallExpression) this.pos32BitIntFor(array.words[index - ...						local.get $this;; (ComputedMemberExpression) array.words[index - 1];; (StaticMemberExpression) array.words;; (JSIdentifier) words						local.get $words;; (BinaryExpression) index - 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.sub						i32.const 4						i32.mul						i32.add						call $pos32BitIntFor						return))));; (IfStatement) if (array.isBytes()) {if (info.convertCh...;; (CallExpression) array.isBytes()						local.get $array						call $isBytes						i32.const 0						i32.ne						(if (then;; (IfStatement) if (info.convertChars) {return this.char...;; (StaticMemberExpression) info.convertChars;; (JSIdentifier) convertChars						local.get $convertChars						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.charFromInt(array.bytes[inde...;; (CallExpression) this.charFromInt(array.bytes[index - 1] ...						local.get $this;; (BinaryExpression) array.bytes[index - 1] & 255;; (ComputedMemberExpression) array.bytes[index - 1];; (StaticMemberExpression) array.bytes;; (JSIdentifier) bytes						local.get $bytes;; (BinaryExpression) index - 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.sub						i32.const 4						i32.mul						i32.add;; (JSLiteral) 255						i32.const 255						i32.and						call $charFromInt						return)						(else;; (ReturnStatement) return array.bytes[index - 1] & 255;; (BinaryExpression) array.bytes[index - 1] & 255;; (ComputedMemberExpression) array.bytes[index - 1];; (StaticMemberExpression) array.bytes;; (JSIdentifier) bytes						local.get $bytes;; (BinaryExpression) index - 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.sub						i32.const 4						i32.mul						i32.add;; (JSLiteral) 255						i32.const 255						i32.and						return))));; (IfStatement) if (index - 1 - offset < 0) {this.succes...;; (BinaryExpression) index - 1 - offset < 0;; (BinaryExpression) index - 1 - offset;; (BinaryExpression) index - 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.sub;; (JSIdentifier) offset						local.get $offset						i32.sub;; (JSLiteral) 0						i32.const 0						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return array ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return array;; (JSIdentifier) array						local.get $array						return));; (ReturnStatement) return array.bytes[index - 1 - offset] &...;; (BinaryExpression) array.bytes[index - 1 - offset] & 255;; (ComputedMemberExpression) array.bytes[index - 1 - offset];; (StaticMemberExpression) array.bytes;; (JSIdentifier) bytes						local.get $bytes;; (BinaryExpression) index - 1 - offset;; (BinaryExpression) index - 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.sub;; (JSIdentifier) offset						local.get $offset						i32.sub						i32.const 4						i32.mul						i32.add;; (JSLiteral) 255						i32.const 255						i32.and						return);; (JSProperty) property: objectAtPut -> function(cameFr...;; (FunctionExpression) function(cameFromBytecode, convertChars,...(func $objectAtPut						(local $temp i32)						(local $intToPut i32)						(local $array i32)						(local $convertChars i32)						(local $floatData i32)						(local $offset i32)						(local $index i32)						(local $cameFromBytecode i32)						(local $info i32)						(local $includeInstVars i32)						(local $objToPut i32)						(local $wordToPut i32)						;; (IfStatement) if (!this.success) {return array};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return array;; (JSIdentifier) array						local.get $array						return));; (IfStatement) if (cameFromBytecode) {info = this.atPut...;; (JSIdentifier) cameFromBytecode						local.get $cameFromBytecode						i32.const 0						i32.ne						(if (then;; (BlockStatement) info = this.atPutCache[array.hash & this...;; (ExpressionStatement) info = this.atPutCache[array.hash & this...;; (AssignmentExpression) info = this.atPutCache[array.hash & this...;; (ComputedMemberExpression) this.atPutCache[array.hash & this.atCach...;; (StaticMemberExpression) this.atPutCache;; (JSIdentifier) atPutCache						local.get $atPutCache;; (BinaryExpression) array.hash & this.atCacheMask;; (StaticMemberExpression) array.hash;; (JSIdentifier) hash						local.get $hash;; (StaticMemberExpression) this.atCacheMask;; (JSIdentifier) atCacheMask						local.get $atCacheMask						i32.and						i32.const 4						i32.mul						i32.add						local.set $info;; (IfStatement) if (info.array !== array) {this.success ...;; (BinaryExpression) info.array !== array;; (StaticMemberExpression) info.array;; (JSIdentifier) array						local.get $array;; (JSIdentifier) array						local.get $array						i32.ne						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return array ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return array;; (JSIdentifier) array						local.get $array						return)))						(else;; (BlockStatement) if (array.isFloat) {var wordToPut = this...;; (IfStatement) if (array.isFloat) {var wordToPut = this...;; (StaticMemberExpression) array.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						i32.const 0						i32.ne						(if (then;; (BlockStatement) var wordToPut = this.stackPos32BitInt(0)...;; (VariableDeclaration) var wordToPut = this.stackPos32BitInt(0);; (VariableDeclarator) wordToPut = this.stackPos32BitInt(0);; (CallExpression) this.stackPos32BitInt(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackPos32BitInt						local.set $wordToPut;; (IfStatement) if (this.success && index == 1 || index ...;; (BinaryExpression) this.success && index == 1 || index == 2;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success;; (BinaryExpression) index == 1 || index == 2;; (BinaryExpression) index == 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.eq;; (BinaryExpression) index == 2;; (JSIdentifier) index						local.get $index;; (JSLiteral) 2						i32.const 2						i32.eq						i32.or						i32.and						i32.const 0						i32.ne						(if (then;; (BlockStatement) var floatData = array.floatData() floatD...;; (VariableDeclaration) var floatData = array.floatData();; (VariableDeclarator) floatData = array.floatData();; (CallExpression) array.floatData()						local.get $array						call $floatData						local.set $floatData;; (ExpressionStatement) floatData.setUint32(index == 1 ? 0 : 4, ...;; (CallExpression) floatData.setUint32(index == 1 ? 0 : 4, ...						local.get $floatData;; (ConditionalExpression) index == 1 ? 0 : 4;; (BinaryExpression) index == 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.eq						i32.const 1						i32.eq						(if (then;; (JSLiteral) 0						i32.const 0)						(else;; (JSLiteral) 4						i32.const 4						));; (JSIdentifier) wordToPut						local.get $wordToPut;; (JSLiteral) false						i32.const 0						call $setUint32;; (ExpressionStatement) array.float = floatData.getFloat64(0);; (AssignmentExpression) array.float = floatData.getFloat64(0);; (CallExpression) floatData.getFloat64(0)						local.get $floatData;; (JSLiteral) 0						i32.const 0						call $getFloat64						local.set $float)						(else;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success));; (ReturnStatement) return this.vm.stackValue(0);; (CallExpression) this.vm.stackValue(0)						local.get $vm;; (JSLiteral) 0						i32.const 0						call $stackValue						return));; (ExpressionStatement) info = this.makeAtCacheInfo(this.atPutCa...;; (AssignmentExpression) info = this.makeAtCacheInfo(this.atPutCa...;; (CallExpression) this.makeAtCacheInfo(this.atPutCache, th...						local.get $this;; (StaticMemberExpression) this.atPutCache;; (JSIdentifier) atPutCache						local.get $atPutCache;; (ComputedMemberExpression) this.vm.specialSelectors[34];; (StaticMemberExpression) this.vm.specialSelectors;; (JSIdentifier) specialSelectors						local.get $specialSelectors;; (JSLiteral) 34						i32.const 34						i32.const 4						i32.mul						i32.add;; (JSIdentifier) array						local.get $array;; (JSIdentifier) convertChars						local.get $convertChars;; (JSIdentifier) includeInstVars						local.get $includeInstVars						call $makeAtCacheInfo						local.set $info));; (IfStatement) if (index < 1 || index > info.size) {thi...;; (BinaryExpression) index < 1 || index > info.size;; (BinaryExpression) index < 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.lt_u;; (BinaryExpression) index > info.size;; (JSIdentifier) index						local.get $index;; (StaticMemberExpression) info.size;; (JSIdentifier) size						local.get $size						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return array ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return array;; (JSIdentifier) array						local.get $array						return));; (IfStatement) if (includeInstVars) {array.dirty = true...;; (JSIdentifier) includeInstVars						local.get $includeInstVars						i32.const 0						i32.ne						(if (then;; (BlockStatement) array.dirty = true return array.pointers...;; (ExpressionStatement) array.dirty = true;; (AssignmentExpression) array.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty;; (ReturnStatement) return array.pointers[index - 1] = objTo...;; (AssignmentExpression) array.pointers[index - 1] = objToPut						local.get $array;; (BinaryExpression) index - 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.sub;; (JSIdentifier) objToPut						local.get $objToPut						call $atPut						return));; (IfStatement) if (array.isPointers()) {array.dirty = t...;; (CallExpression) array.isPointers()						local.get $array						call $isPointers						i32.const 0						i32.ne						(if (then;; (BlockStatement) array.dirty = true return array.pointers...;; (ExpressionStatement) array.dirty = true;; (AssignmentExpression) array.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty;; (ReturnStatement) return array.pointers[index - 1 + info.i...;; (AssignmentExpression) array.pointers[index - 1 + info.ivarOffs...						local.get $array;; (BinaryExpression) index - 1 + info.ivarOffset;; (BinaryExpression) index - 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.sub;; (StaticMemberExpression) info.ivarOffset;; (JSIdentifier) ivarOffset						local.get $ivarOffset						i32.add;; (JSIdentifier) objToPut						local.get $objToPut						call $atPut						return))						;; unwritable: (IfStatement) if (array.isWords()) {if (convertChars) 						;; unwritable: (IfStatement) if (convertChars) {if (objToPut.sqClass ;; (IfStatement) if (intToPut < 0 || intToPut > 255) {thi...;; (BinaryExpression) intToPut < 0 || intToPut > 255;; (BinaryExpression) intToPut < 0;; (JSIdentifier) intToPut						local.get $intToPut;; (JSLiteral) 0						i32.const 0						i32.lt_u;; (BinaryExpression) intToPut > 255;; (JSIdentifier) intToPut						local.get $intToPut;; (JSLiteral) 255						i32.const 255						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return objToPut ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return objToPut;; (JSIdentifier) objToPut						local.get $objToPut						return));; (IfStatement) if (array.isBytes()) {return array.bytes...;; (CallExpression) array.isBytes()						local.get $array						call $isBytes						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return array.bytes[index - 1] = intToPut;; (AssignmentExpression) array.bytes[index - 1] = intToPut						local.get $array;; (BinaryExpression) index - 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.sub;; (JSIdentifier) intToPut						local.get $intToPut						call $atPut						return));; (IfStatement) if (index - 1 - offset < 0) {this.succes...;; (BinaryExpression) index - 1 - offset < 0;; (BinaryExpression) index - 1 - offset;; (BinaryExpression) index - 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.sub;; (JSIdentifier) offset						local.get $offset						i32.sub;; (JSLiteral) 0						i32.const 0						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return array ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return array;; (JSIdentifier) array						local.get $array						return));; (ExpressionStatement) array.bytes[index - 1 - offset] = intToP...;; (AssignmentExpression) array.bytes[index - 1 - offset] = intToP...						local.get $array;; (BinaryExpression) index - 1 - offset;; (BinaryExpression) index - 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.sub;; (JSIdentifier) offset						local.get $offset						i32.sub;; (JSIdentifier) intToPut						local.get $intToPut						call $atPut;; (ReturnStatement) return objToPut;; (JSIdentifier) objToPut						local.get $objToPut						return);; (JSProperty) property: objectSize -> function(cameFro...;; (FunctionExpression) function(cameFromBytecode) { 	var rcvr =...(func $objectSize						(local $size i32)						(local $rcvr i32)						(local $temp i32)						(local $cameFromBytecode i32)						;; (IfStatement) if (cameFromBytecode) {if (rcvr.sqClass ...;; (JSIdentifier) cameFromBytecode						local.get $cameFromBytecode						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (rcvr.sqClass === this.vm.specialObje...;; (IfStatement) if (rcvr.sqClass === this.vm.specialObje...;; (BinaryExpression) rcvr.sqClass === this.vm.specialObjects[...;; (StaticMemberExpression) rcvr.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassArray;; (JSIdentifier) splOb_ClassArray						local.get $splOb_ClassArray						i32.const 4						i32.mul						i32.add						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) size = rcvr.pointersSize() ;; (ExpressionStatement) size = rcvr.pointersSize();; (AssignmentExpression) size = rcvr.pointersSize();; (CallExpression) rcvr.pointersSize()						local.get $rcvr						call $pointersSize						local.set $size)						(else;; (IfStatement) if (rcvr.sqClass === this.vm.specialObje...;; (BinaryExpression) rcvr.sqClass === this.vm.specialObjects[...;; (StaticMemberExpression) rcvr.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassString;; (JSIdentifier) splOb_ClassString						local.get $splOb_ClassString						i32.const 4						i32.mul						i32.add						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) size = rcvr.bytesSize() ;; (ExpressionStatement) size = rcvr.bytesSize();; (AssignmentExpression) size = rcvr.bytesSize();; (CallExpression) rcvr.bytesSize()						local.get $rcvr						call $bytesSize						local.set $size)))))						(else;; (BlockStatement) size = this.indexableSize(rcvr) ;; (ExpressionStatement) size = this.indexableSize(rcvr);; (AssignmentExpression) size = this.indexableSize(rcvr);; (CallExpression) this.indexableSize(rcvr)						local.get $this;; (JSIdentifier) rcvr						local.get $rcvr						call $indexableSize						local.set $size));; (IfStatement) if (size === -1) {this.success = false r...;; (BinaryExpression) size === -1;; (JSIdentifier) size						local.get $size;; (UnaryExpression) -1;; (JSLiteral) 1						i32.const 1						local.set $temp						i32.const 0						local.get $temp						i32.sub						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return -1 ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return -1;; (UnaryExpression) -1;; (JSLiteral) 1						i32.const 1						local.set $temp						i32.const 0						local.get $temp						i32.sub						return));; (EmptyStatement) ;; (ReturnStatement) return this.pos32BitIntFor(size);; (CallExpression) this.pos32BitIntFor(size)						local.get $this;; (JSIdentifier) size						local.get $size						call $pos32BitIntFor						return);; (JSProperty) property: initAtCache -> function() { 	t...;; (FunctionExpression) function() { 	this.atCacheSize = 32 this...(func $initAtCache						(local $temp i32)						(local $i i32)						;; (ExpressionStatement) this.atCacheSize = 32;; (AssignmentExpression) this.atCacheSize = 32;; (JSLiteral) 32						i32.const 32						local.set $atCacheSize;; (ExpressionStatement) this.atCacheMask = this.atCacheSize - 1;; (AssignmentExpression) this.atCacheMask = this.atCacheSize - 1;; (BinaryExpression) this.atCacheSize - 1;; (StaticMemberExpression) this.atCacheSize;; (JSIdentifier) atCacheSize						local.get $atCacheSize;; (JSLiteral) 1						i32.const 1						i32.sub						local.set $atCacheMask						;; unwritable: (ExpressionStatement) this.atCache = []						;; unwritable: (ExpressionStatement) this.atPutCache = [];; (ExpressionStatement) this.nonCachedInfo = {};; (AssignmentExpression) this.nonCachedInfo = {};; (ObjectExpression) {}						local.set $nonCachedInfo;; (ForStatement) for (var i = 0; i < this.atCacheSize; i+...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (BlockStatement) this.atCache.push({}) this.atPutCache.pu...;; (ExpressionStatement) this.atCache.push({});; (CallExpression) this.atCache.push({})						local.get $atCache;; (ObjectExpression) {}						call $push;; (ExpressionStatement) this.atPutCache.push({});; (CallExpression) this.atPutCache.push({})						local.get $atPutCache;; (ObjectExpression) {}						call $push;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < this.atCacheSize;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) this.atCacheSize;; (JSIdentifier) atCacheSize						local.get $atCacheSize						i32.lt_u						i32.const 0						br_if $loop_1));; (JSProperty) property: makeAtCacheInfo -> function(at...;; (FunctionExpression) function(atOrPutCache, atOrPutSelector, ...(func $makeAtCacheInfo						(local $array i32)						(local $includeInstVars i32)						(local $cacheable i32)						(local $atOrPutSelector i32)						(local $info i32)						(local $atOrPutCache i32)						(local $temp i32)						(local $convertChars i32)						;; (ExpressionStatement) info = cacheable ? atOrPutCache[array.ha...;; (AssignmentExpression) info = cacheable ? atOrPutCache[array.ha...;; (ConditionalExpression) cacheable ? atOrPutCache[array.hash & th...;; (JSIdentifier) cacheable						local.get $cacheable						i32.const 1						i32.eq						(if (then;; (ComputedMemberExpression) atOrPutCache[array.hash & this.atCacheMa...;; (JSIdentifier) atOrPutCache						local.get $atOrPutCache;; (BinaryExpression) array.hash & this.atCacheMask;; (StaticMemberExpression) array.hash;; (JSIdentifier) hash						local.get $hash;; (StaticMemberExpression) this.atCacheMask;; (JSIdentifier) atCacheMask						local.get $atCacheMask						i32.and						i32.const 4						i32.mul						i32.add)						(else;; (StaticMemberExpression) this.nonCachedInfo;; (JSIdentifier) nonCachedInfo						local.get $nonCachedInfo						))						local.set $info;; (ExpressionStatement) info.array = array;; (AssignmentExpression) info.array = array;; (JSIdentifier) array						local.get $array						local.set $array;; (ExpressionStatement) info.convertChars = convertChars;; (AssignmentExpression) info.convertChars = convertChars;; (JSIdentifier) convertChars						local.get $convertChars						local.set $convertChars						;; unwritable: (IfStatement) if (includeInstVars) {info.size = array.;; (ReturnStatement) return info;; (JSIdentifier) info						local.get $info						return);; (JSProperty) property: instantiateClass -> function(c...;; (FunctionExpression) function(clsObj, indexableSize) { 	if (i...(func $instantiateClass						(local $indexableSize i32)						(local $clsObj i32)						(local $temp i32)												;; unwritable: (IfStatement) if (indexableSize * 4 > this.vm.image.by);; (JSProperty) property: someObject -> function() { 	re...;; (FunctionExpression) function() { 	return this.vm.image.first...(func $someObject						(local $temp i32)						;; (ReturnStatement) return this.vm.image.firstOldObject;; (StaticMemberExpression) this.vm.image.firstOldObject;; (JSIdentifier) firstOldObject						local.get $firstOldObject						return);; (JSProperty) property: nextObject -> function(obj) { ...;; (FunctionExpression) function(obj) { 	return this.vm.image.ob...(func $nextObject						(local $obj i32)						(local $temp i32)						;; (ReturnStatement) return this.vm.image.objectAfter(obj) ||...;; (BinaryExpression) this.vm.image.objectAfter(obj) || 0;; (CallExpression) this.vm.image.objectAfter(obj)						local.get $vm.image;; (JSIdentifier) obj						local.get $obj						call $objectAfter;; (JSLiteral) 0						i32.const 0						i32.or						return);; (JSProperty) property: someInstanceOf -> function(cls...;; (FunctionExpression) function(clsObj) { 	var someInstance = t...(func $someInstanceOf						(local $someInstance i32)						(local $clsObj i32)						(local $temp i32)						;; (IfStatement) if (someInstance) {return someInstance};; (JSIdentifier) someInstance						local.get $someInstance						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return someInstance;; (JSIdentifier) someInstance						local.get $someInstance						return));; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return);; (JSProperty) property: nextInstanceAfter -> function(...;; (FunctionExpression) function(obj) { 	var nextInstance = this...(func $nextInstanceAfter						(local $obj i32)						(local $nextInstance i32)						(local $temp i32)						;; (IfStatement) if (nextInstance) {return nextInstance};; (JSIdentifier) nextInstance						local.get $nextInstance						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nextInstance;; (JSIdentifier) nextInstance						local.get $nextInstance						return));; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return);; (JSProperty) property: allInstancesOf -> function(cls...;; (FunctionExpression) function(clsObj) { 	var instances = this...(func $allInstancesOf						(local $array i32)						(local $clsObj i32)						(local $temp i32)						(local $instances i32)						;; (ExpressionStatement) array.pointers = instances;; (AssignmentExpression) array.pointers = instances;; (JSIdentifier) instances						local.get $instances						local.set $pointers;; (ReturnStatement) return array;; (JSIdentifier) array						local.get $array						return);; (JSProperty) property: identityHash -> function(obj) ...;; (FunctionExpression) function(obj) { 	return obj.hash }(func $identityHash						(local $obj i32)						(local $temp i32)						;; (ReturnStatement) return obj.hash;; (StaticMemberExpression) obj.hash;; (JSIdentifier) hash						local.get $hash						return);; (JSProperty) property: identityHashSpur -> function(o...;; (FunctionExpression) function(obj) { 	var hash = obj.hash if ...(func $identityHashSpur						(local $obj i32)						(local $hash i32)						(local $temp i32)						;; (IfStatement) if (hash > 0) {return hash};; (BinaryExpression) hash > 0;; (JSIdentifier) hash						local.get $hash;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return hash;; (JSIdentifier) hash						local.get $hash						return));; (ReturnStatement) return obj.hash = this.newObjectHash();; (AssignmentExpression) obj.hash = this.newObjectHash();; (CallExpression) this.newObjectHash()						local.get $this						call $newObjectHash						local.set $hash						return);; (JSProperty) property: behaviorHash -> function(obj) ...;; (FunctionExpression) function(obj) { 	var hash = obj.hash if ...(func $behaviorHash						(local $obj i32)						(local $hash i32)						(local $temp i32)						;; (IfStatement) if (hash > 0) {return hash};; (BinaryExpression) hash > 0;; (JSIdentifier) hash						local.get $hash;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return hash;; (JSIdentifier) hash						local.get $hash						return));; (ReturnStatement) return this.vm.image.enterIntoClassTable...;; (CallExpression) this.vm.image.enterIntoClassTable(obj)						local.get $vm.image;; (JSIdentifier) obj						local.get $obj						call $enterIntoClassTable						return);; (JSProperty) property: newObjectHash -> function(obj)...;; (FunctionExpression) function(obj) { 	return Math.floor(Math....(func $newObjectHash						(local $obj i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return Math.floor(Math.random() * 419430);; (JSProperty) property: primitiveSizeInBytesOfInstance...;; (FunctionExpression) function(argCount) { 	if (argCount > 1) ...(func $primitiveSizeInBytesOfInstance						(local $bytes i32)						(local $classObj i32)						(local $argCount i32)						(local $temp i32)						(local $nElements i32)						;; (IfStatement) if (argCount > 1) {return false};; (BinaryExpression) argCount > 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeLargeIfNeeded(bytes)						local.get $this;; (JSIdentifier) bytes						local.get $bytes						call $makeLargeIfNeeded						call $popNandPushIfOK						return);; (JSProperty) property: primitiveSizeInBytes -> functi...;; (FunctionExpression) function(argCount) { 	var object = this....(func $primitiveSizeInBytes						(local $bytes i32)						(local $temp i32)						(local $object i32)						(local $argCount i32)						;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeLargeIfNeeded(bytes)						local.get $this;; (JSIdentifier) bytes						local.get $bytes						call $makeLargeIfNeeded						call $popNandPushIfOK						return);; (JSProperty) property: primitiveAsCharacter -> functi...;; (FunctionExpression) function(argCount) { 	var unicode = this...(func $primitiveAsCharacter						(local $char i32)						(local $temp i32)						(local $argCount i32)						(local $unicode i32)						;; (IfStatement) if (unicode < 0 || unicode > 1073741823)...;; (BinaryExpression) unicode < 0 || unicode > 1073741823;; (BinaryExpression) unicode < 0;; (JSIdentifier) unicode						local.get $unicode;; (JSLiteral) 0						i32.const 0						i32.lt_u;; (BinaryExpression) unicode > 1073741823;; (JSIdentifier) unicode						local.get $unicode;; (JSLiteral) 1073741823						i32.const 1073741823						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!char) {return false};; (UnaryExpression) !char;; (JSIdentifier) char						local.get $char						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, char)						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) char						local.get $char						call $popNandPushIfOK						return);; (JSProperty) property: primitiveFullGC -> function(ar...;; (FunctionExpression) function(argCount) { 	this.vm.image.full...(func $primitiveFullGC						(local $temp i32)						(local $argCount i32)						(local $bytes i32)												;; unwritable: (ExpressionStatement) this.vm.image.fullGC('primitive');; (ReturnStatement) return this.popNandPushIfOK(1, this.make...;; (CallExpression) this.popNandPushIfOK(1, this.makeLargeIf...						local.get $this;; (JSLiteral) 1						i32.const 1;; (CallExpression) this.makeLargeIfNeeded(bytes)						local.get $this;; (JSIdentifier) bytes						local.get $bytes						call $makeLargeIfNeeded						call $popNandPushIfOK						return);; (JSProperty) property: primitiveFusedGC -> function(a...;; (FunctionExpression) function(argCount) { 	if (this.vm.stackV...(func $primitiveFusedGC						(local $temp i32)						(local $argCount i32)						(local $bytes i32)						;; (IfStatement) if (this.vm.stackValue(0) === this.vm.tr...;; (BinaryExpression) this.vm.stackValue(0) === this.vm.trueOb...;; (BinaryExpression) this.vm.stackValue(0) === this.vm.trueOb...;; (CallExpression) this.vm.stackValue(0)						local.get $vm;; (JSLiteral) 0						i32.const 0						call $stackValue;; (StaticMemberExpression) this.vm.trueObj;; (JSIdentifier) trueObj						local.get $trueObj						i32.eq;; (BinaryExpression) this.vm.stackValue(0) === this.vm.trueOb...;; (CallExpression) this.vm.stackValue(0)						local.get $vm;; (JSLiteral) 0						i32.const 0						call $stackValue;; (StaticMemberExpression) this.vm.trueObj;; (JSIdentifier) trueObj						local.get $trueObj						i32.eq						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (ExpressionStatement) this.vm.image.fusedGC('primitive');; (ReturnStatement) return this.popNandPushIfOK(1, this.make...;; (CallExpression) this.popNandPushIfOK(1, this.makeLargeIf...						local.get $this;; (JSLiteral) 1						i32.const 1;; (CallExpression) this.makeLargeIfNeeded(bytes)						local.get $this;; (JSIdentifier) bytes						local.get $bytes						call $makeLargeIfNeeded						call $popNandPushIfOK						return);; (JSProperty) property: primitivePartialGC -> function...;; (FunctionExpression) function(argCount) { 	this.vm.image.part...(func $primitivePartialGC						(local $temp i32)						(local $argCount i32)						(local $bytes i32)												;; unwritable: (ExpressionStatement) this.vm.image.partialGC('primitive');; (ReturnStatement) return this.popNandPushIfOK(1, this.make...;; (CallExpression) this.popNandPushIfOK(1, this.makeLargeIf...						local.get $this;; (JSLiteral) 1						i32.const 1;; (CallExpression) this.makeLargeIfNeeded(bytes)						local.get $this;; (JSIdentifier) bytes						local.get $bytes						call $makeLargeIfNeeded						call $popNandPushIfOK						return);; (JSProperty) property: primitiveMakePoint -> function...;; (FunctionExpression) function(argCount, checkNumbers) { 	var ...(func $primitiveMakePoint						(local $x i32)						(local $argCount i32)						(local $y i32)						(local $checkNumbers i32)						(local $temp i32)						;; (IfStatement) if (checkNumbers) {this.checkFloat(x) th...;; (JSIdentifier) checkNumbers						local.get $checkNumbers						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.checkFloat(x) this.checkFloat(y) if...;; (ExpressionStatement) this.checkFloat(x);; (CallExpression) this.checkFloat(x)						local.get $this;; (JSIdentifier) x						local.get $x						call $checkFloat;; (ExpressionStatement) this.checkFloat(y);; (CallExpression) this.checkFloat(y)						local.get $this;; (JSIdentifier) y						local.get $y						call $checkFloat;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))));; (ExpressionStatement) this.vm.popNandPush(1 + argCount, this.m...;; (CallExpression) this.vm.popNandPush(1 + argCount, this.m...						local.get $vm;; (BinaryExpression) 1 + argCount;; (JSLiteral) 1						i32.const 1;; (JSIdentifier) argCount						local.get $argCount						i32.add;; (CallExpression) this.makePointWithXandY(x, y)						local.get $this;; (JSIdentifier) x						local.get $x;; (JSIdentifier) y						local.get $y						call $makePointWithXandY						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveStoreStackp -> functi...;; (FunctionExpression) function(argCount) { 	var ctxt = this.st...(func $primitiveStoreStackp						(local $newStackp i32)						(local $ctxt i32)						(local $argCount i32)						(local $stackp i32)						(local $temp i32)						;; (IfStatement) if (!this.success || newStackp < 0 || th...;; (BinaryExpression) !this.success || newStackp < 0 || this.v...;; (BinaryExpression) !this.success || newStackp < 0;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (BinaryExpression) newStackp < 0;; (JSIdentifier) newStackp						local.get $newStackp;; (JSLiteral) 0						i32.const 0						i32.lt_u						i32.or;; (BinaryExpression) this.vm.decodeSqueakSP(newStackp) >= ctx...;; (CallExpression) this.vm.decodeSqueakSP(newStackp)						local.get $vm;; (JSIdentifier) newStackp						local.get $newStackp						call $decodeSqueakSP;; (StaticMemberExpression) ctxt.pointers.length;; (JSIdentifier) length						local.get $length						i32.ge_u						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (WhileStatement) while (stackp < newStackp) {ctxt.pointer...						(loop $loop_1;; (ExpressionStatement) ctxt.pointers[this.vm.decodeSqueakSP(++s...;; (AssignmentExpression) ctxt.pointers[this.vm.decodeSqueakSP(++s...						local.get $ctxt;; (CallExpression) this.vm.decodeSqueakSP(++stackp)						local.get $vm;; (UpdateExpression) ++stackp;; (JSIdentifier) stackp						local.get $stackp						i32.const 1						i32.add						call $decodeSqueakSP;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut;; (BinaryExpression) stackp < newStackp;; (JSIdentifier) stackp						local.get $stackp;; (JSIdentifier) newStackp						local.get $newStackp						i32.lt_u						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ExpressionStatement) ctxt.pointers[Squeak.Context_stackPointe...;; (AssignmentExpression) ctxt.pointers[Squeak.Context_stackPointe...						local.get $ctxt;; (StaticMemberExpression) Squeak.Context_stackPointer;; (JSIdentifier) Context_stackPointer						local.get $Context_stackPointer;; (JSIdentifier) newStackp						local.get $newStackp						call $atPut;; (ExpressionStatement) this.vm.popN(argCount);; (CallExpression) this.vm.popN(argCount)						local.get $vm;; (JSIdentifier) argCount						local.get $argCount						call $popN;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveChangeClass -> functi...;; (FunctionExpression) function(argCount) { 	if (argCount > 2) ...(func $primitiveChangeClass						(local $hasBytes i32)						(local $rcvr i32)						(local $needBytes i32)						(local $argCount i32)						(local $temp i32)						(local $arg i32)						;; (IfStatement) if (argCount > 2) {return false};; (BinaryExpression) argCount > 2;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 2						i32.const 2						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (rcvr.sqClass.isCompact !== arg.sqCla...;; (BinaryExpression) rcvr.sqClass.isCompact !== arg.sqClass.i...;; (StaticMemberExpression) rcvr.sqClass.isCompact;; (JSIdentifier) isCompact						local.get $isCompact;; (StaticMemberExpression) arg.sqClass.isCompact;; (JSIdentifier) isCompact						local.get $isCompact						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (IfStatement) if (rcvr.isPointers()) {if (!arg.isPoint;; (ExpressionStatement) rcvr._format = arg._format;; (AssignmentExpression) rcvr._format = arg._format;; (StaticMemberExpression) arg._format;; (JSIdentifier) _format						local.get $_format						local.set $_format;; (ExpressionStatement) rcvr.sqClass = arg.sqClass;; (AssignmentExpression) rcvr.sqClass = arg.sqClass;; (StaticMemberExpression) arg.sqClass;; (JSIdentifier) sqClass						local.get $sqClass						local.set $sqClass;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: primitiveAdoptInstance -> func...;; (FunctionExpression) function(argCount) { 	if (argCount > 2) ...(func $primitiveAdoptInstance						(local $temp i32)						(local $argCount i32)						(local $cls i32)						(local $obj i32)						;; (IfStatement) if (argCount > 2) {return false};; (BinaryExpression) argCount > 2;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 2						i32.const 2						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (cls.classInstFormat() !== obj.sqClas...;; (BinaryExpression) cls.classInstFormat() !== obj.sqClass.cl...;; (BinaryExpression) cls.classInstFormat() !== obj.sqClass.cl...;; (BinaryExpression) cls.classInstFormat() !== obj.sqClass.cl...;; (CallExpression) cls.classInstFormat()						local.get $cls						call $classInstFormat;; (CallExpression) obj.sqClass.classInstFormat()						local.get $obj.sqClass						call $classInstFormat						i32.ne;; (BinaryExpression) cls.isCompact !== obj.sqClass.isCompact;; (StaticMemberExpression) cls.isCompact;; (JSIdentifier) isCompact						local.get $isCompact;; (StaticMemberExpression) obj.sqClass.isCompact;; (JSIdentifier) isCompact						local.get $isCompact						i32.ne						i32.or;; (BinaryExpression) cls.classInstSize() !== obj.sqClass.clas...;; (CallExpression) cls.classInstSize()						local.get $cls						call $classInstSize;; (CallExpression) obj.sqClass.classInstSize()						local.get $obj.sqClass						call $classInstSize						i32.ne						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) obj.sqClass = cls;; (AssignmentExpression) obj.sqClass = cls;; (JSIdentifier) cls						local.get $cls						local.set $sqClass;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: primitiveDoPrimitiveWithArgs -...;; (FunctionExpression) function(argCount) { 	var argumentArray ...(func $primitiveDoPrimitiveWithArgs						(local $arraySize i32)						(local $argumentArray i32)						(local $i i32)						(local $argCount i32)						(local $primIdx i32)						(local $cntxSize i32)						(local $temp i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (this.vm.sp + arraySize >= cntxSize) ...;; (BinaryExpression) this.vm.sp + arraySize >= cntxSize;; (BinaryExpression) this.vm.sp + arraySize;; (StaticMemberExpression) this.vm.sp;; (JSIdentifier) sp						local.get $sp;; (JSIdentifier) arraySize						local.get $arraySize						i32.add;; (JSIdentifier) cntxSize						local.get $cntxSize						i32.ge_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.vm.popN(2);; (CallExpression) this.vm.popN(2)						local.get $vm;; (JSLiteral) 2						i32.const 2						call $popN;; (ForStatement) for (var i = 0; i < arraySize; i++) {thi...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) this.vm.push(argumentArray.pointers[i]);; (CallExpression) this.vm.push(argumentArray.pointers[i])						local.get $vm;; (ComputedMemberExpression) argumentArray.pointers[i];; (StaticMemberExpression) argumentArray.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						call $push;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < arraySize;; (JSIdentifier) i						local.get $i;; (JSIdentifier) arraySize						local.get $arraySize						i32.lt_u						i32.const 0						br_if $loop_1);; (IfStatement) if (this.vm.tryPrimitive(primIdx, arrayS...;; (CallExpression) this.vm.tryPrimitive(primIdx, arraySize)						local.get $vm;; (JSIdentifier) primIdx						local.get $primIdx;; (JSIdentifier) arraySize						local.get $arraySize						call $tryPrimitive						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return));; (ExpressionStatement) this.vm.popN(arraySize);; (CallExpression) this.vm.popN(arraySize)						local.get $vm;; (JSIdentifier) arraySize						local.get $arraySize						call $popN;; (ExpressionStatement) this.vm.push(primIdx);; (CallExpression) this.vm.push(primIdx)						local.get $vm;; (JSIdentifier) primIdx						local.get $primIdx						call $push;; (ExpressionStatement) this.vm.push(argumentArray);; (CallExpression) this.vm.push(argumentArray)						local.get $vm;; (JSIdentifier) argumentArray						local.get $argumentArray						call $push;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: primitiveShortAtAndPut -> func...;; (FunctionExpression) function(argCount) { 	var rcvr = this.st...(func $primitiveShortAtAndPut						(local $array i32)						(local $rcvr i32)						(local $value i32)						(local $argCount i32)						(local $temp i32)						(local $index i32)						;; (IfStatement) if (!this.success || !array || index < 0...;; (BinaryExpression) !this.success || !array || index < 0 || ...;; (BinaryExpression) !this.success || !array || index < 0;; (BinaryExpression) !this.success || !array;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !array;; (JSIdentifier) array						local.get $array						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or;; (BinaryExpression) index < 0;; (JSIdentifier) index						local.get $index;; (JSLiteral) 0						i32.const 0						i32.lt_u						i32.or;; (BinaryExpression) index >= array.length;; (JSIdentifier) index						local.get $index;; (StaticMemberExpression) array.length;; (JSIdentifier) length						local.get $length						i32.ge_u						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (argCount < 2) {value = array[index] ...;; (BinaryExpression) argCount < 2;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 2						i32.const 2						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) value = array[index] ;; (ExpressionStatement) value = array[index];; (AssignmentExpression) value = array[index];; (ComputedMemberExpression) array[index];; (JSIdentifier) array						local.get $array;; (JSIdentifier) index						local.get $index						i32.const 4						i32.mul						i32.add						local.set $value)						(else;; (BlockStatement) value = this.stackInteger(0) if (value <...;; (ExpressionStatement) value = this.stackInteger(0);; (AssignmentExpression) value = this.stackInteger(0);; (CallExpression) this.stackInteger(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackInteger						local.set $value;; (IfStatement) if (value < -32768 || value > 32767) {re...;; (BinaryExpression) value < -32768 || value > 32767;; (BinaryExpression) value < -32768;; (JSIdentifier) value						local.get $value;; (UnaryExpression) -32768;; (JSLiteral) 32768						i32.const 32768						local.set $temp						i32.const 0						local.get $temp						i32.sub						i32.lt_u;; (BinaryExpression) value > 32767;; (JSIdentifier) value						local.get $value;; (JSLiteral) 32767						i32.const 32767						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) array[index] = value;; (AssignmentExpression) array[index] = value						local.get $'array';; (JSIdentifier) index						local.get $index;; (JSIdentifier) value						local.get $value						call $atPut));; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, value...;; (CallExpression) this.popNandPushIfOK(argCount + 1, value...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) value						local.get $value						call $popNandPushIfOK;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveIntegerAtAndPut -> fu...;; (FunctionExpression) function(argCount) { 	var rcvr = this.st...(func $primitiveIntegerAtAndPut						(local $array i32)						(local $rcvr i32)						(local $value i32)						(local $argCount i32)						(local $temp i32)						(local $index i32)						;; (IfStatement) if (!this.success || !array || index < 0...;; (BinaryExpression) !this.success || !array || index < 0 || ...;; (BinaryExpression) !this.success || !array || index < 0;; (BinaryExpression) !this.success || !array;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !array;; (JSIdentifier) array						local.get $array						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or;; (BinaryExpression) index < 0;; (JSIdentifier) index						local.get $index;; (JSLiteral) 0						i32.const 0						i32.lt_u						i32.or;; (BinaryExpression) index >= array.length;; (JSIdentifier) index						local.get $index;; (StaticMemberExpression) array.length;; (JSIdentifier) length						local.get $length						i32.ge_u						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (argCount < 2) {value = this.signed32...;; (BinaryExpression) argCount < 2;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 2						i32.const 2						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) value = this.signed32BitIntegerFor(array...;; (ExpressionStatement) value = this.signed32BitIntegerFor(array...;; (AssignmentExpression) value = this.signed32BitIntegerFor(array...;; (CallExpression) this.signed32BitIntegerFor(array[index])						local.get $this;; (ComputedMemberExpression) array[index];; (JSIdentifier) array						local.get $array;; (JSIdentifier) index						local.get $index						i32.const 4						i32.mul						i32.add						call $signed32BitIntegerFor						local.set $value)						(else;; (BlockStatement) value = this.stackSigned32BitInt(0) if (...;; (ExpressionStatement) value = this.stackSigned32BitInt(0);; (AssignmentExpression) value = this.stackSigned32BitInt(0);; (CallExpression) this.stackSigned32BitInt(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackSigned32BitInt						local.set $value;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) array[index] = value;; (AssignmentExpression) array[index] = value						local.get $'array';; (JSIdentifier) index						local.get $index;; (JSIdentifier) value						local.get $value						call $atPut));; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, value...;; (CallExpression) this.popNandPushIfOK(argCount + 1, value...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) value						local.get $value						call $popNandPushIfOK;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveConstantFill -> funct...;; (FunctionExpression) function(argCount) { 	var rcvr = this.st...(func $primitiveConstantFill						(local $value i32)						(local $array i32)						(local $rcvr i32)						(local $i i32)						(local $argCount i32)						(local $temp i32)						;; (IfStatement) if (!this.success || !rcvr.isWordsOrByte...;; (BinaryExpression) !this.success || !rcvr.isWordsOrBytes();; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !rcvr.isWordsOrBytes();; (CallExpression) rcvr.isWordsOrBytes()						local.get $rcvr						call $isWordsOrBytes						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (array) {if (array === rcvr.bytes && ...;; (JSIdentifier) array						local.get $array						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (array === rcvr.bytes && value > 255)...;; (IfStatement) if (array === rcvr.bytes && value > 255)...;; (BinaryExpression) array === rcvr.bytes && value > 255;; (BinaryExpression) array === rcvr.bytes;; (JSIdentifier) array						local.get $array;; (StaticMemberExpression) rcvr.bytes;; (JSIdentifier) bytes						local.get $bytes						i32.eq;; (BinaryExpression) value > 255;; (JSIdentifier) value						local.get $value;; (JSLiteral) 255						i32.const 255						i32.gt_u						i32.and						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ForStatement) for (var i = 0; i < array.length; i++) {...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) array[i] = value;; (AssignmentExpression) array[i] = value						local.get $'array';; (JSIdentifier) i						local.get $i;; (JSIdentifier) value						local.get $value						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < array.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) array.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_1)));; (ExpressionStatement) this.vm.popN(argCount);; (CallExpression) this.vm.popN(argCount)						local.get $vm;; (JSIdentifier) argCount						local.get $argCount						call $popN;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveNewMethod -> function...;; (FunctionExpression) function(argCount) { 	var header = this....(func $primitiveNewMethod						(local $method i32)						(local $i i32)						(local $litCount i32)						(local $header i32)						(local $argCount i32)						(local $bytecodeCount i32)						(local $temp i32)						;; (IfStatement) if (!this.success) {return 0};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return))						;; unwritable: (ExpressionStatement) method.pointers = [header];; (ForStatement) for (var i = 0; i < litCount; i++) {meth...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) method.pointers.push(this.vm.nilObj);; (CallExpression) method.pointers.push(this.vm.nilObj)						local.get $method.pointers;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $push;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < litCount;; (JSIdentifier) i						local.get $i;; (JSIdentifier) litCount						local.get $litCount						i32.lt_u						i32.const 0						br_if $loop_1);; (ExpressionStatement) this.vm.popNandPush(1 + argCount, method...;; (CallExpression) this.vm.popNandPush(1 + argCount, method...						local.get $vm;; (BinaryExpression) 1 + argCount;; (JSLiteral) 1						i32.const 1;; (JSIdentifier) argCount						local.get $argCount						i32.add;; (JSIdentifier) method						local.get $method						call $popNandPush;; (IfStatement) if (this.vm.breakOnNewMethod) {this.vm.b...;; (StaticMemberExpression) this.vm.breakOnNewMethod;; (JSIdentifier) breakOnNewMethod						local.get $breakOnNewMethod						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.vm.breakOnMethod = method;; (AssignmentExpression) this.vm.breakOnMethod = method;; (JSIdentifier) method						local.get $method						local.set $breakOnMethod));; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveExecuteMethodArgsArra...;; (FunctionExpression) function(argCount) { 	var methodObj = th...(func $primitiveExecuteMethodArgsArray						(local $argsArray i32)						(local $receiver i32)						(local $i i32)						(local $argCount i32)						(local $methodObj i32)						(local $numArgs i32)						(local $temp i32)						;; (IfStatement) if (!this.success || !methodObj.isMethod...;; (BinaryExpression) !this.success || !methodObj.isMethod() |...;; (BinaryExpression) !this.success || !methodObj.isMethod();; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !methodObj.isMethod();; (CallExpression) methodObj.isMethod()						local.get $methodObj						call $isMethod						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or;; (BinaryExpression) argCount > 4;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 4						i32.const 4						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (numArgs !== argsArray.pointersSize()...;; (BinaryExpression) numArgs !== argsArray.pointersSize();; (JSIdentifier) numArgs						local.get $numArgs;; (CallExpression) argsArray.pointersSize()						local.get $argsArray						call $pointersSize						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.vm.popNandPush(argCount + 1, receiv...;; (CallExpression) this.vm.popNandPush(argCount + 1, receiv...						local.get $vm;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) receiver						local.get $receiver						call $popNandPush;; (ForStatement) for (var i = 0; i < numArgs; i++) {this....;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) this.vm.push(argsArray.pointers[i]);; (CallExpression) this.vm.push(argsArray.pointers[i])						local.get $vm;; (ComputedMemberExpression) argsArray.pointers[i];; (StaticMemberExpression) argsArray.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						call $push;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < numArgs;; (JSIdentifier) i						local.get $i;; (JSIdentifier) numArgs						local.get $numArgs						i32.lt_u						i32.const 0						br_if $loop_1);; (ExpressionStatement) this.vm.executeNewMethod(receiver, metho...;; (CallExpression) this.vm.executeNewMethod(receiver, metho...						local.get $vm;; (JSIdentifier) receiver						local.get $receiver;; (JSIdentifier) methodObj						local.get $methodObj;; (JSIdentifier) numArgs						local.get $numArgs;; (CallExpression) methodObj.methodPrimitiveIndex()						local.get $methodObj						call $methodPrimitiveIndex;; (JSLiteral) nil						i32.const 0;; (JSLiteral) nil						i32.const 0						call $executeNewMethod;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveArrayBecome -> functi...;; (FunctionExpression) function(argCount, doBothWays) { 	var rc...(func $primitiveArrayBecome						(local $rcvr i32)						(local $argCount i32)						(local $doBothWays i32)						(local $copyHash i32)						(local $temp i32)						(local $arg i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.success = this.vm.image.bulkBecome(...;; (AssignmentExpression) this.success = this.vm.image.bulkBecome(...;; (CallExpression) this.vm.image.bulkBecome(rcvr.pointers, ...						local.get $vm.image;; (StaticMemberExpression) rcvr.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) arg.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSIdentifier) doBothWays						local.get $doBothWays;; (JSIdentifier) copyHash						local.get $copyHash						call $bulkBecome						local.set $success;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: doStringReplace -> function() ...;; (FunctionExpression) function() { 	var dst = this.stackNonInt...(func $doStringReplace						(local $temp i32)						(local $dst i32)						(local $totalLength i32)						(local $dstPos i32)						(local $dstInstSize i32)						(local $i i32)						(local $srcPos i32)						(local $count i32)						(local $srcInstSize i32)						(local $src i32)						;; (IfStatement) if (!this.success) {return dst};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return dst;; (JSIdentifier) dst						local.get $dst						return));; (IfStatement) if (!src.sameFormatAs(dst)) {this.succes...;; (UnaryExpression) !src.sameFormatAs(dst);; (CallExpression) src.sameFormatAs(dst)						local.get $src;; (JSIdentifier) dst						local.get $dst						call $sameFormatAs						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return dst ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return dst;; (JSIdentifier) dst						local.get $dst						return));; (IfStatement) if (src.isPointers()) {var totalLength =...;; (CallExpression) src.isPointers()						local.get $src						call $isPointers						i32.const 0						i32.ne						(if (then;; (BlockStatement) var totalLength = src.pointersSize() var...;; (VariableDeclaration) var totalLength = src.pointersSize();; (VariableDeclarator) totalLength = src.pointersSize();; (CallExpression) src.pointersSize()						local.get $src						call $pointersSize						local.set $totalLength;; (VariableDeclaration) var srcInstSize = src.instSize();; (VariableDeclarator) srcInstSize = src.instSize();; (CallExpression) src.instSize()						local.get $src						call $instSize						local.set $srcInstSize;; (ExpressionStatement) srcPos += srcInstSize;; (AssignmentExpression) srcPos += srcInstSize;; (JSIdentifier) srcPos						local.get $srcPos;; (JSIdentifier) srcInstSize						local.get $srcInstSize						i32.add						local.set $srcPos;; (IfStatement) if (srcPos < 0 || srcPos + count > total...;; (BinaryExpression) srcPos < 0 || srcPos + count > totalLeng...;; (BinaryExpression) srcPos < 0;; (JSIdentifier) srcPos						local.get $srcPos;; (JSLiteral) 0						i32.const 0						i32.lt_u;; (BinaryExpression) srcPos + count > totalLength;; (BinaryExpression) srcPos + count;; (JSIdentifier) srcPos						local.get $srcPos;; (JSIdentifier) count						local.get $count						i32.add;; (JSIdentifier) totalLength						local.get $totalLength						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return dst ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return dst;; (JSIdentifier) dst						local.get $dst						return));; (ExpressionStatement) totalLength = dst.pointersSize();; (AssignmentExpression) totalLength = dst.pointersSize();; (CallExpression) dst.pointersSize()						local.get $dst						call $pointersSize						local.set $totalLength;; (VariableDeclaration) var dstInstSize = dst.instSize();; (VariableDeclarator) dstInstSize = dst.instSize();; (CallExpression) dst.instSize()						local.get $dst						call $instSize						local.set $dstInstSize;; (ExpressionStatement) dstPos += dstInstSize;; (AssignmentExpression) dstPos += dstInstSize;; (JSIdentifier) dstPos						local.get $dstPos;; (JSIdentifier) dstInstSize						local.get $dstInstSize						i32.add						local.set $dstPos;; (IfStatement) if (dstPos < 0 || dstPos + count > total...;; (BinaryExpression) dstPos < 0 || dstPos + count > totalLeng...;; (BinaryExpression) dstPos < 0;; (JSIdentifier) dstPos						local.get $dstPos;; (JSLiteral) 0						i32.const 0						i32.lt_u;; (BinaryExpression) dstPos + count > totalLength;; (BinaryExpression) dstPos + count;; (JSIdentifier) dstPos						local.get $dstPos;; (JSIdentifier) count						local.get $count						i32.add;; (JSIdentifier) totalLength						local.get $totalLength						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return dst ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return dst;; (JSIdentifier) dst						local.get $dst						return));; (ForStatement) for (var i = 0; i < count; i++) {dst.poi...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) dst.pointers[dstPos + i] = src.pointers[...;; (AssignmentExpression) dst.pointers[dstPos + i] = src.pointers[...						local.get $dst;; (BinaryExpression) dstPos + i;; (JSIdentifier) dstPos						local.get $dstPos;; (JSIdentifier) i						local.get $i						i32.add;; (ComputedMemberExpression) src.pointers[srcPos + i];; (StaticMemberExpression) src.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) srcPos + i;; (JSIdentifier) srcPos						local.get $srcPos;; (JSIdentifier) i						local.get $i						i32.add						i32.const 4						i32.mul						i32.add						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < count;; (JSIdentifier) i						local.get $i;; (JSIdentifier) count						local.get $count						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return dst;; (JSIdentifier) dst						local.get $dst						return)						(else;; (IfStatement) if (src.isWords()) {var totalLength = sr...;; (CallExpression) src.isWords()						local.get $src						call $isWords						i32.const 0						i32.ne						(if (then;; (BlockStatement) var totalLength = src.wordsSize() if (sr...;; (VariableDeclaration) var totalLength = src.wordsSize();; (VariableDeclarator) totalLength = src.wordsSize();; (CallExpression) src.wordsSize()						local.get $src						call $wordsSize						local.set $totalLength;; (IfStatement) if (srcPos < 0 || srcPos + count > total...;; (BinaryExpression) srcPos < 0 || srcPos + count > totalLeng...;; (BinaryExpression) srcPos < 0;; (JSIdentifier) srcPos						local.get $srcPos;; (JSLiteral) 0						i32.const 0						i32.lt_u;; (BinaryExpression) srcPos + count > totalLength;; (BinaryExpression) srcPos + count;; (JSIdentifier) srcPos						local.get $srcPos;; (JSIdentifier) count						local.get $count						i32.add;; (JSIdentifier) totalLength						local.get $totalLength						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return dst ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return dst;; (JSIdentifier) dst						local.get $dst						return));; (ExpressionStatement) totalLength = dst.wordsSize();; (AssignmentExpression) totalLength = dst.wordsSize();; (CallExpression) dst.wordsSize()						local.get $dst						call $wordsSize						local.set $totalLength;; (IfStatement) if (dstPos < 0 || dstPos + count > total...;; (BinaryExpression) dstPos < 0 || dstPos + count > totalLeng...;; (BinaryExpression) dstPos < 0;; (JSIdentifier) dstPos						local.get $dstPos;; (JSLiteral) 0						i32.const 0						i32.lt_u;; (BinaryExpression) dstPos + count > totalLength;; (BinaryExpression) dstPos + count;; (JSIdentifier) dstPos						local.get $dstPos;; (JSIdentifier) count						local.get $count						i32.add;; (JSIdentifier) totalLength						local.get $totalLength						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return dst ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return dst;; (JSIdentifier) dst						local.get $dst						return));; (IfStatement) if (src.isFloat && dst.isFloat) {dst.flo...;; (BinaryExpression) src.isFloat && dst.isFloat;; (StaticMemberExpression) src.isFloat;; (JSIdentifier) isFloat						local.get $isFloat;; (StaticMemberExpression) dst.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						i32.and						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) dst.float = src.float;; (AssignmentExpression) dst.float = src.float;; (StaticMemberExpression) src.float;; (JSIdentifier) float						local.get $float						local.set $float)						(else;; (IfStatement) if (src.isFloat) {dst.wordsAsFloat64Arra...;; (StaticMemberExpression) src.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) dst.wordsAsFloat64Array()[dstPos] = src....;; (AssignmentExpression) dst.wordsAsFloat64Array()[dstPos] = src....						local.get $dst;; (JSIdentifier) dstPos						local.get $dstPos;; (StaticMemberExpression) src.float;; (JSIdentifier) float						local.get $float						call $atPut)						(else;; (IfStatement) if (dst.isFloat) {dst.float = src.wordsA...;; (StaticMemberExpression) dst.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) dst.float = src.wordsAsFloat64Array()[sr...;; (AssignmentExpression) dst.float = src.wordsAsFloat64Array()[sr...;; (ComputedMemberExpression) src.wordsAsFloat64Array()[srcPos];; (CallExpression) src.wordsAsFloat64Array()						local.get $src						call $wordsAsFloat64Array;; (JSIdentifier) srcPos						local.get $srcPos						i32.const 4						i32.mul						i32.add						local.set $float)						(else;; (ForStatement) for (var i = 0; i < count; i++) {dst.wor...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_2;; (ExpressionStatement) dst.words[dstPos + i] = src.words[srcPos...;; (AssignmentExpression) dst.words[dstPos + i] = src.words[srcPos...						local.get $dst;; (BinaryExpression) dstPos + i;; (JSIdentifier) dstPos						local.get $dstPos;; (JSIdentifier) i						local.get $i						i32.add;; (ComputedMemberExpression) src.words[srcPos + i];; (StaticMemberExpression) src.words;; (JSIdentifier) words						local.get $words;; (BinaryExpression) srcPos + i;; (JSIdentifier) srcPos						local.get $srcPos;; (JSIdentifier) i						local.get $i						i32.add						i32.const 4						i32.mul						i32.add						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < count;; (JSIdentifier) i						local.get $i;; (JSIdentifier) count						local.get $count						i32.lt_u						i32.const 0						br_if $loop_2)))))));; (ReturnStatement) return dst;; (JSIdentifier) dst						local.get $dst						return)						(else;; (BlockStatement) var totalLength = src.bytesSize() if (sr...;; (VariableDeclaration) var totalLength = src.bytesSize();; (VariableDeclarator) totalLength = src.bytesSize();; (CallExpression) src.bytesSize()						local.get $src						call $bytesSize						local.set $totalLength;; (IfStatement) if (srcPos < 0 || srcPos + count > total...;; (BinaryExpression) srcPos < 0 || srcPos + count > totalLeng...;; (BinaryExpression) srcPos < 0;; (JSIdentifier) srcPos						local.get $srcPos;; (JSLiteral) 0						i32.const 0						i32.lt_u;; (BinaryExpression) srcPos + count > totalLength;; (BinaryExpression) srcPos + count;; (JSIdentifier) srcPos						local.get $srcPos;; (JSIdentifier) count						local.get $count						i32.add;; (JSIdentifier) totalLength						local.get $totalLength						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return dst ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return dst;; (JSIdentifier) dst						local.get $dst						return));; (ExpressionStatement) totalLength = dst.bytesSize();; (AssignmentExpression) totalLength = dst.bytesSize();; (CallExpression) dst.bytesSize()						local.get $dst						call $bytesSize						local.set $totalLength;; (IfStatement) if (dstPos < 0 || dstPos + count > total...;; (BinaryExpression) dstPos < 0 || dstPos + count > totalLeng...;; (BinaryExpression) dstPos < 0;; (JSIdentifier) dstPos						local.get $dstPos;; (JSLiteral) 0						i32.const 0						i32.lt_u;; (BinaryExpression) dstPos + count > totalLength;; (BinaryExpression) dstPos + count;; (JSIdentifier) dstPos						local.get $dstPos;; (JSIdentifier) count						local.get $count						i32.add;; (JSIdentifier) totalLength						local.get $totalLength						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.success = false return dst ;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success;; (ReturnStatement) return dst;; (JSIdentifier) dst						local.get $dst						return));; (ForStatement) for (var i = 0; i < count; i++) {dst.byt...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_3;; (ExpressionStatement) dst.bytes[dstPos + i] = src.bytes[srcPos...;; (AssignmentExpression) dst.bytes[dstPos + i] = src.bytes[srcPos...						local.get $dst;; (BinaryExpression) dstPos + i;; (JSIdentifier) dstPos						local.get $dstPos;; (JSIdentifier) i						local.get $i						i32.add;; (ComputedMemberExpression) src.bytes[srcPos + i];; (StaticMemberExpression) src.bytes;; (JSIdentifier) bytes						local.get $bytes;; (BinaryExpression) srcPos + i;; (JSIdentifier) srcPos						local.get $srcPos;; (JSIdentifier) i						local.get $i						i32.add						i32.const 4						i32.mul						i32.add						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < count;; (JSIdentifier) i						local.get $i;; (JSIdentifier) count						local.get $count						i32.lt_u						i32.const 0						br_if $loop_3);; (ReturnStatement) return dst;; (JSIdentifier) dst						local.get $dst						return)))));; (JSProperty) property: primitiveCopyObject -> functio...;; (FunctionExpression) function(argCount) { 	var rcvr = this.st...(func $primitiveCopyObject						(local $length i32)						(local $rcvr i32)						(local $i i32)						(local $argCount i32)						(local $temp i32)						(local $arg i32)						;; (IfStatement) if (!this.success || rcvr.isWordsOrBytes...;; (BinaryExpression) !this.success || rcvr.isWordsOrBytes() |...;; (BinaryExpression) !this.success || rcvr.isWordsOrBytes() |...;; (BinaryExpression) !this.success || rcvr.isWordsOrBytes();; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (CallExpression) rcvr.isWordsOrBytes()						local.get $rcvr						call $isWordsOrBytes						i32.or;; (BinaryExpression) rcvr.sqClass !== arg.sqClass;; (StaticMemberExpression) rcvr.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (StaticMemberExpression) arg.sqClass;; (JSIdentifier) sqClass						local.get $sqClass						i32.ne						i32.or;; (BinaryExpression) length !== arg.pointersSize();; (JSIdentifier) length						local.get $length;; (CallExpression) arg.pointersSize()						local.get $arg						call $pointersSize						i32.ne						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ForStatement) for (var i = 0; i < length; i++) {rcvr.p...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) rcvr.pointers[i] = arg.pointers[i];; (AssignmentExpression) rcvr.pointers[i] = arg.pointers[i]						local.get $rcvr;; (JSIdentifier) i						local.get $i;; (ComputedMemberExpression) arg.pointers[i];; (StaticMemberExpression) arg.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < length;; (JSIdentifier) i						local.get $i;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_1);; (ExpressionStatement) rcvr.dirty = arg.dirty;; (AssignmentExpression) rcvr.dirty = arg.dirty;; (StaticMemberExpression) arg.dirty;; (JSIdentifier) dirty						local.get $dirty						local.set $dirty;; (ExpressionStatement) this.vm.pop(argCount);; (CallExpression) this.vm.pop(argCount)						local.get $vm;; (JSIdentifier) argCount						local.get $argCount						call $pop;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveLoadImageSegment -> f...;; (FunctionExpression) function(argCount) { 	var segmentWordArr...(func $primitiveLoadImageSegment						(local $segmentWordArray i32)						(local $outPointerArray i32)						(local $argCount i32)						(local $temp i32)						(local $roots i32)						;; (IfStatement) if (!segmentWordArray.words || !outPoint...;; (BinaryExpression) !segmentWordArray.words || !outPointerAr...;; (UnaryExpression) !segmentWordArray.words;; (StaticMemberExpression) segmentWordArray.words;; (JSIdentifier) words						local.get $words						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !outPointerArray.pointers;; (StaticMemberExpression) outPointerArray.pointers;; (JSIdentifier) pointers						local.get $pointers						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!roots) {return false};; (UnaryExpression) !roots;; (JSIdentifier) roots						local.get $roots						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, roots...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) roots						local.get $roots						call $popNandPushIfOK						return);; (JSProperty) property: doBlockCopy -> function() { 	v...;; (FunctionExpression) function() { 	var rcvr = this.vm.stackVa...(func $doBlockCopy						(local $rcvr i32)						(local $initialPC i32)						(local $homeCtxt i32)						(local $blockSize i32)						(local $sqArgCount i32)						(local $newBlock i32)						(local $temp i32)						;; (IfStatement) if (!this.vm.isContext(homeCtxt)) {this....;; (UnaryExpression) !this.vm.isContext(homeCtxt);; (CallExpression) this.vm.isContext(homeCtxt)						local.get $vm;; (JSIdentifier) homeCtxt						local.get $homeCtxt						call $isContext						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success));; (IfStatement) if (!this.success) {return rcvr};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return rcvr;; (JSIdentifier) rcvr						local.get $rcvr						return))						;; unwritable: (IfStatement) if (typeof homeCtxt.pointers[Squeak.Cont;; (ExpressionStatement) newBlock.pointers[Squeak.BlockContext_in...;; (AssignmentExpression) newBlock.pointers[Squeak.BlockContext_in...						local.get $newBlock;; (StaticMemberExpression) Squeak.BlockContext_initialIP;; (JSIdentifier) BlockContext_initialIP						local.get $BlockContext_initialIP;; (JSIdentifier) initialPC						local.get $initialPC						call $atPut;; (ExpressionStatement) newBlock.pointers[Squeak.Context_instruc...;; (AssignmentExpression) newBlock.pointers[Squeak.Context_instruc...						local.get $newBlock;; (StaticMemberExpression) Squeak.Context_instructionPointer;; (JSIdentifier) Context_instructionPointer						local.get $Context_instructionPointer;; (JSIdentifier) initialPC						local.get $initialPC						call $atPut;; (ExpressionStatement) newBlock.pointers[Squeak.Context_stackPo...;; (AssignmentExpression) newBlock.pointers[Squeak.Context_stackPo...						local.get $newBlock;; (StaticMemberExpression) Squeak.Context_stackPointer;; (JSIdentifier) Context_stackPointer						local.get $Context_stackPointer;; (JSLiteral) 0						i32.const 0						call $atPut;; (ExpressionStatement) newBlock.pointers[Squeak.BlockContext_ar...;; (AssignmentExpression) newBlock.pointers[Squeak.BlockContext_ar...						local.get $newBlock;; (StaticMemberExpression) Squeak.BlockContext_argumentCount;; (JSIdentifier) BlockContext_argumentCount						local.get $BlockContext_argumentCount;; (JSIdentifier) sqArgCount						local.get $sqArgCount						call $atPut;; (ExpressionStatement) newBlock.pointers[Squeak.BlockContext_ho...;; (AssignmentExpression) newBlock.pointers[Squeak.BlockContext_ho...						local.get $newBlock;; (StaticMemberExpression) Squeak.BlockContext_home;; (JSIdentifier) BlockContext_home						local.get $BlockContext_home;; (JSIdentifier) homeCtxt						local.get $homeCtxt						call $atPut;; (ExpressionStatement) newBlock.pointers[Squeak.Context_sender]...;; (AssignmentExpression) newBlock.pointers[Squeak.Context_sender]...						local.get $newBlock;; (StaticMemberExpression) Squeak.Context_sender;; (JSIdentifier) Context_sender						local.get $Context_sender;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut;; (ReturnStatement) return newBlock;; (JSIdentifier) newBlock						local.get $newBlock						return);; (JSProperty) property: primitiveBlockValue -> functio...;; (FunctionExpression) function(argCount) { 	var rcvr = this.vm...(func $primitiveBlockValue						(local $rcvr i32)						(local $blockArgCount i32)						(local $block i32)						(local $argCount i32)						(local $temp i32)						(local $initialIP i32)						;; (IfStatement) if (!this.isA(rcvr, Squeak.splOb_ClassBl...;; (UnaryExpression) !this.isA(rcvr, Squeak.splOb_ClassBlockC...;; (CallExpression) this.isA(rcvr, Squeak.splOb_ClassBlockCo...						local.get $this;; (JSIdentifier) rcvr						local.get $rcvr;; (StaticMemberExpression) Squeak.splOb_ClassBlockContext;; (JSIdentifier) splOb_ClassBlockContext						local.get $splOb_ClassBlockContext						call $isA						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (IfStatement) if (typeof blockArgCount !== 'number') {;; (IfStatement) if (blockArgCount != argCount) {return f...;; (BinaryExpression) blockArgCount != argCount;; (JSIdentifier) blockArgCount						local.get $blockArgCount;; (JSIdentifier) argCount						local.get $argCount						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!block.pointers[Squeak.BlockContext_...;; (UnaryExpression) !block.pointers[Squeak.BlockContext_call...;; (StaticMemberExpression) block.pointers[Squeak.BlockContext_calle...;; (JSIdentifier) isNil						local.get $isNil						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.vm.arrayCopy(this.vm.activeContext....;; (CallExpression) this.vm.arrayCopy(this.vm.activeContext....						local.get $vm;; (StaticMemberExpression) this.vm.activeContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) this.vm.sp - argCount + 1;; (BinaryExpression) this.vm.sp - argCount;; (StaticMemberExpression) this.vm.sp;; (JSIdentifier) sp						local.get $sp;; (JSIdentifier) argCount						local.get $argCount						i32.sub;; (JSLiteral) 1						i32.const 1						i32.add;; (StaticMemberExpression) block.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_tempFrameStart;; (JSIdentifier) Context_tempFrameStart						local.get $Context_tempFrameStart;; (JSIdentifier) argCount						local.get $argCount						call $arrayCopy;; (ExpressionStatement) block.pointers[Squeak.Context_instructio...;; (AssignmentExpression) block.pointers[Squeak.Context_instructio...						local.get $block;; (StaticMemberExpression) Squeak.Context_instructionPointer;; (JSIdentifier) Context_instructionPointer						local.get $Context_instructionPointer;; (JSIdentifier) initialIP						local.get $initialIP						call $atPut;; (ExpressionStatement) block.pointers[Squeak.Context_stackPoint...;; (AssignmentExpression) block.pointers[Squeak.Context_stackPoint...						local.get $block;; (StaticMemberExpression) Squeak.Context_stackPointer;; (JSIdentifier) Context_stackPointer						local.get $Context_stackPointer;; (JSIdentifier) argCount						local.get $argCount						call $atPut;; (ExpressionStatement) block.pointers[Squeak.BlockContext_calle...;; (AssignmentExpression) block.pointers[Squeak.BlockContext_calle...						local.get $block;; (StaticMemberExpression) Squeak.BlockContext_caller;; (JSIdentifier) BlockContext_caller						local.get $BlockContext_caller;; (StaticMemberExpression) this.vm.activeContext;; (JSIdentifier) activeContext						local.get $activeContext						call $atPut;; (ExpressionStatement) this.vm.popN(argCount + 1);; (CallExpression) this.vm.popN(argCount + 1)						local.get $vm;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add						call $popN;; (ExpressionStatement) this.vm.newActiveContext(block);; (CallExpression) this.vm.newActiveContext(block)						local.get $vm;; (JSIdentifier) block						local.get $block						call $newActiveContext;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveBlockValueWithArgs ->...;; (FunctionExpression) function(argCount) { 	var block = this.v...(func $primitiveBlockValueWithArgs						(local $array i32)						(local $blockArgCount i32)						(local $block i32)						(local $argCount i32)						(local $temp i32)						(local $initialIP i32)						;; (IfStatement) if (!this.isA(block, Squeak.splOb_ClassB...;; (UnaryExpression) !this.isA(block, Squeak.splOb_ClassBlock...;; (CallExpression) this.isA(block, Squeak.splOb_ClassBlockC...						local.get $this;; (JSIdentifier) block						local.get $block;; (StaticMemberExpression) Squeak.splOb_ClassBlockContext;; (JSIdentifier) splOb_ClassBlockContext						local.get $splOb_ClassBlockContext						call $isA						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!this.isA(array, Squeak.splOb_ClassA...;; (UnaryExpression) !this.isA(array, Squeak.splOb_ClassArray...;; (CallExpression) this.isA(array, Squeak.splOb_ClassArray)						local.get $this;; (JSIdentifier) array						local.get $array;; (StaticMemberExpression) Squeak.splOb_ClassArray;; (JSIdentifier) splOb_ClassArray						local.get $splOb_ClassArray						call $isA						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (IfStatement) if (typeof blockArgCount !== 'number') {;; (IfStatement) if (blockArgCount != array.pointersSize(...;; (BinaryExpression) blockArgCount != array.pointersSize();; (JSIdentifier) blockArgCount						local.get $blockArgCount;; (CallExpression) array.pointersSize()						local.get $array						call $pointersSize						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!block.pointers[Squeak.BlockContext_...;; (UnaryExpression) !block.pointers[Squeak.BlockContext_call...;; (StaticMemberExpression) block.pointers[Squeak.BlockContext_calle...;; (JSIdentifier) isNil						local.get $isNil						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.vm.arrayCopy(array.pointers, 0, blo...;; (CallExpression) this.vm.arrayCopy(array.pointers, 0, blo...						local.get $vm;; (StaticMemberExpression) array.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSLiteral) 0						i32.const 0;; (StaticMemberExpression) block.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_tempFrameStart;; (JSIdentifier) Context_tempFrameStart						local.get $Context_tempFrameStart;; (JSIdentifier) blockArgCount						local.get $blockArgCount						call $arrayCopy;; (ExpressionStatement) block.pointers[Squeak.Context_instructio...;; (AssignmentExpression) block.pointers[Squeak.Context_instructio...						local.get $block;; (StaticMemberExpression) Squeak.Context_instructionPointer;; (JSIdentifier) Context_instructionPointer						local.get $Context_instructionPointer;; (JSIdentifier) initialIP						local.get $initialIP						call $atPut;; (ExpressionStatement) block.pointers[Squeak.Context_stackPoint...;; (AssignmentExpression) block.pointers[Squeak.Context_stackPoint...						local.get $block;; (StaticMemberExpression) Squeak.Context_stackPointer;; (JSIdentifier) Context_stackPointer						local.get $Context_stackPointer;; (JSIdentifier) blockArgCount						local.get $blockArgCount						call $atPut;; (ExpressionStatement) block.pointers[Squeak.BlockContext_calle...;; (AssignmentExpression) block.pointers[Squeak.BlockContext_calle...						local.get $block;; (StaticMemberExpression) Squeak.BlockContext_caller;; (JSIdentifier) BlockContext_caller						local.get $BlockContext_caller;; (StaticMemberExpression) this.vm.activeContext;; (JSIdentifier) activeContext						local.get $activeContext						call $atPut;; (ExpressionStatement) this.vm.popN(argCount + 1);; (CallExpression) this.vm.popN(argCount + 1)						local.get $vm;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add						call $popN;; (ExpressionStatement) this.vm.newActiveContext(block);; (CallExpression) this.vm.newActiveContext(block)						local.get $vm;; (JSIdentifier) block						local.get $block						call $newActiveContext;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveClosureCopyWithCopied...;; (FunctionExpression) function(argCount) { 	this.vm.breakNow('...(func $primitiveClosureCopyWithCopiedValues						(local $argCount i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.vm.breakNow('primitiveClosureCopyWi;; (DebuggerStatement) an active DebuggerStatement with propert...;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: primitiveClosureValue -> funct...;; (FunctionExpression) function(argCount) { 	var blockClosure =...(func $primitiveClosureValue						(local $blockClosure i32)						(local $blockArgCount i32)						(local $temp i32)						(local $argCount i32)						;; (IfStatement) if (argCount !== blockArgCount) {return ...;; (BinaryExpression) argCount !== blockArgCount;; (JSIdentifier) argCount						local.get $argCount;; (JSIdentifier) blockArgCount						local.get $blockArgCount						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ReturnStatement) return this.activateNewClosureMethod(blo...;; (CallExpression) this.activateNewClosureMethod(blockClosu...						local.get $this;; (JSIdentifier) blockClosure						local.get $blockClosure;; (JSIdentifier) argCount						local.get $argCount						call $activateNewClosureMethod						return);; (JSProperty) property: primitiveClosureValueWithArgs ...;; (FunctionExpression) function(argCount) { 	var array = this.v...(func $primitiveClosureValueWithArgs						(local $arraySize i32)						(local $blockClosure i32)						(local $array i32)						(local $blockArgCount i32)						(local $i i32)						(local $argCount i32)						(local $temp i32)						;; (IfStatement) if (arraySize !== blockArgCount) {return...;; (BinaryExpression) arraySize !== blockArgCount;; (JSIdentifier) arraySize						local.get $arraySize;; (JSIdentifier) blockArgCount						local.get $blockArgCount						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.vm.pop();; (CallExpression) this.vm.pop()						local.get $vm						call $pop;; (ForStatement) for (var i = 0; i < arraySize; i++) {thi...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) this.vm.push(array.pointers[i]);; (CallExpression) this.vm.push(array.pointers[i])						local.get $vm;; (ComputedMemberExpression) array.pointers[i];; (StaticMemberExpression) array.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						call $push;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < arraySize;; (JSIdentifier) i						local.get $i;; (JSIdentifier) arraySize						local.get $arraySize						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return this.activateNewClosureMethod(blo...;; (CallExpression) this.activateNewClosureMethod(blockClosu...						local.get $this;; (JSIdentifier) blockClosure						local.get $blockClosure;; (JSIdentifier) arraySize						local.get $arraySize						call $activateNewClosureMethod						return);; (JSProperty) property: primitiveClosureValueNoContext...;; (FunctionExpression) function(argCount) { 	return this.primit...(func $primitiveClosureValueNoContextSwitch						(local $argCount i32)						(local $temp i32)						;; (ReturnStatement) return this.primitiveClosureValue(argCou...;; (CallExpression) this.primitiveClosureValue(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $primitiveClosureValue						return);; (JSProperty) property: activateNewClosureMethod -> fu...;; (FunctionExpression) function(blockClosure, argCount) { 	var ...(func $activateNewClosureMethod						(local $method i32)						(local $where i32)						(local $temp i32)						(local $numCopied i32)						(local $newContext i32)						(local $i i32)						(local $outerContext i32)						(local $blockClosure i32)						(local $argCount i32)						;; (IfStatement) if (method === this.vm.nilObj) {an activ...;; (BinaryExpression) method === this.vm.nilObj;; (JSIdentifier) method						local.get $method;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) an active DebuggerStatement with propert...;; (DebuggerStatement) an active DebuggerStatement with propert...));; (ExpressionStatement) newContext.pointers[Squeak.Context_sende...;; (AssignmentExpression) newContext.pointers[Squeak.Context_sende...						local.get $newContext;; (StaticMemberExpression) Squeak.Context_sender;; (JSIdentifier) Context_sender						local.get $Context_sender;; (StaticMemberExpression) this.vm.activeContext;; (JSIdentifier) activeContext						local.get $activeContext						call $atPut;; (ExpressionStatement) newContext.pointers[Squeak.Context_instr...;; (AssignmentExpression) newContext.pointers[Squeak.Context_instr...						local.get $newContext;; (StaticMemberExpression) Squeak.Context_instructionPointer;; (JSIdentifier) Context_instructionPointer						local.get $Context_instructionPointer;; (ComputedMemberExpression) blockClosure.pointers[Squeak.Closure_sta...;; (StaticMemberExpression) blockClosure.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Closure_startpc;; (JSIdentifier) Closure_startpc						local.get $Closure_startpc						i32.const 4						i32.mul						i32.add						call $atPut;; (ExpressionStatement) newContext.pointers[Squeak.Context_stack...;; (AssignmentExpression) newContext.pointers[Squeak.Context_stack...						local.get $newContext;; (StaticMemberExpression) Squeak.Context_stackPointer;; (JSIdentifier) Context_stackPointer						local.get $Context_stackPointer;; (BinaryExpression) argCount + numCopied;; (JSIdentifier) argCount						local.get $argCount;; (JSIdentifier) numCopied						local.get $numCopied						i32.add						call $atPut;; (ExpressionStatement) newContext.pointers[Squeak.Context_metho...;; (AssignmentExpression) newContext.pointers[Squeak.Context_metho...						local.get $newContext;; (StaticMemberExpression) Squeak.Context_method;; (JSIdentifier) Context_method						local.get $Context_method;; (ComputedMemberExpression) outerContext.pointers[Squeak.Context_met...;; (StaticMemberExpression) outerContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_method;; (JSIdentifier) Context_method						local.get $Context_method						i32.const 4						i32.mul						i32.add						call $atPut;; (ExpressionStatement) newContext.pointers[Squeak.Context_closu...;; (AssignmentExpression) newContext.pointers[Squeak.Context_closu...						local.get $newContext;; (StaticMemberExpression) Squeak.Context_closure;; (JSIdentifier) Context_closure						local.get $Context_closure;; (JSIdentifier) blockClosure						local.get $blockClosure						call $atPut;; (ExpressionStatement) newContext.pointers[Squeak.Context_recei...;; (AssignmentExpression) newContext.pointers[Squeak.Context_recei...						local.get $newContext;; (StaticMemberExpression) Squeak.Context_receiver;; (JSIdentifier) Context_receiver						local.get $Context_receiver;; (ComputedMemberExpression) outerContext.pointers[Squeak.Context_rec...;; (StaticMemberExpression) outerContext.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Context_receiver;; (JSIdentifier) Context_receiver						local.get $Context_receiver						i32.const 4						i32.mul						i32.add						call $atPut;; (ForStatement) for (var i = 0; i < argCount; i++) {newC...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) newContext.pointers[where++] = this.vm.s...;; (AssignmentExpression) newContext.pointers[where++] = this.vm.s...						local.get $newContext;; (UpdateExpression) where++;; (JSIdentifier) where						local.get $where						i32.const 1						i32.add;; (CallExpression) this.vm.stackValue(argCount - i - 1)						local.get $vm;; (BinaryExpression) argCount - i - 1;; (BinaryExpression) argCount - i;; (JSIdentifier) argCount						local.get $argCount;; (JSIdentifier) i						local.get $i						i32.sub;; (JSLiteral) 1						i32.const 1						i32.sub						call $stackValue						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < argCount;; (JSIdentifier) i						local.get $i;; (JSIdentifier) argCount						local.get $argCount						i32.lt_u						i32.const 0						br_if $loop_1);; (ForStatement) for (var i = 0; i < numCopied; i++) {new...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_2;; (ExpressionStatement) newContext.pointers[where++] = blockClos...;; (AssignmentExpression) newContext.pointers[where++] = blockClos...						local.get $newContext;; (UpdateExpression) where++;; (JSIdentifier) where						local.get $where						i32.const 1						i32.add;; (ComputedMemberExpression) blockClosure.pointers[Squeak.Closure_fir...;; (StaticMemberExpression) blockClosure.pointers;; (JSIdentifier) pointers						local.get $pointers;; (BinaryExpression) Squeak.Closure_firstCopiedValue + i;; (StaticMemberExpression) Squeak.Closure_firstCopiedValue;; (JSIdentifier) Closure_firstCopiedValue						local.get $Closure_firstCopiedValue;; (JSIdentifier) i						local.get $i						i32.add						i32.const 4						i32.mul						i32.add						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < numCopied;; (JSIdentifier) i						local.get $i;; (JSIdentifier) numCopied						local.get $numCopied						i32.lt_u						i32.const 0						br_if $loop_2);; (ExpressionStatement) this.vm.popN(argCount + 1);; (CallExpression) this.vm.popN(argCount + 1)						local.get $vm;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add						call $popN;; (ExpressionStatement) this.vm.newActiveContext(newContext);; (CallExpression) this.vm.newActiveContext(newContext)						local.get $vm;; (JSIdentifier) newContext						local.get $newContext						call $newActiveContext;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveResume -> function() ...;; (FunctionExpression) function() { 	this.resume(this.vm.top())...(func $primitiveResume						(local $temp i32)						;; (ExpressionStatement) this.resume(this.vm.top());; (CallExpression) this.resume(this.vm.top())						local.get $this;; (CallExpression) this.vm.top()						local.get $vm						call $top						call $resume;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveSuspend -> function()...;; (FunctionExpression) function() { 	var process = this.vm.top(...(func $primitiveSuspend						(local $temp i32)						(local $oldList i32)						(local $process i32)						;; (IfStatement) if (process === this.activeProcess()) {t...;; (BinaryExpression) process === this.activeProcess();; (JSIdentifier) process						local.get $process;; (CallExpression) this.activeProcess()						local.get $this						call $activeProcess						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.vm.popNandPush(1, this.vm.nilObj) t...;; (ExpressionStatement) this.vm.popNandPush(1, this.vm.nilObj);; (CallExpression) this.vm.popNandPush(1, this.vm.nilObj)						local.get $vm;; (JSLiteral) 1						i32.const 1;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $popNandPush;; (ExpressionStatement) this.transferTo(this.wakeHighestPriority...;; (CallExpression) this.transferTo(this.wakeHighestPriority...						local.get $this;; (CallExpression) this.wakeHighestPriority()						local.get $this						call $wakeHighestPriority						call $transferTo)						(else;; (BlockStatement) var oldList = process.pointers[Squeak.Pr...;; (VariableDeclaration) var oldList = process.pointers[Squeak.Pr...;; (VariableDeclarator) oldList = process.pointers[Squeak.Proc_m...;; (ComputedMemberExpression) process.pointers[Squeak.Proc_myList];; (StaticMemberExpression) process.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Proc_myList;; (JSIdentifier) Proc_myList						local.get $Proc_myList						i32.const 4						i32.mul						i32.add						local.set $oldList;; (IfStatement) if (oldList.isNil) {return false};; (StaticMemberExpression) oldList.isNil;; (JSIdentifier) isNil						local.get $isNil						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.removeProcessFromList(process, oldL...;; (CallExpression) this.removeProcessFromList(process, oldL...						local.get $this;; (JSIdentifier) process						local.get $process;; (JSIdentifier) oldList						local.get $oldList						call $removeProcessFromList;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) process.pointers[Squeak.Proc_myList] = t...;; (AssignmentExpression) process.pointers[Squeak.Proc_myList] = t...						local.get $process;; (StaticMemberExpression) Squeak.Proc_myList;; (JSIdentifier) Proc_myList						local.get $Proc_myList;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut;; (ExpressionStatement) this.vm.popNandPush(1, oldList);; (CallExpression) this.vm.popNandPush(1, oldList)						local.get $vm;; (JSLiteral) 1						i32.const 1;; (JSIdentifier) oldList						local.get $oldList						call $popNandPush));; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: getScheduler -> function() { 	...;; (FunctionExpression) function() { 	var assn = this.vm.special...(func $getScheduler						(local $assn i32)						(local $temp i32)						;; (ReturnStatement) return assn.pointers[Squeak.Assn_value];; (ComputedMemberExpression) assn.pointers[Squeak.Assn_value];; (StaticMemberExpression) assn.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Assn_value;; (JSIdentifier) Assn_value						local.get $Assn_value						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: activeProcess -> function() { ...;; (FunctionExpression) function() { 	return this.getScheduler()...(func $activeProcess						(local $temp i32)						;; (ReturnStatement) return this.getScheduler().pointers[Sque...;; (ComputedMemberExpression) this.getScheduler().pointers[Squeak.Proc...;; (StaticMemberExpression) this.getScheduler().pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.ProcSched_activeProcess;; (JSIdentifier) ProcSched_activeProcess						local.get $ProcSched_activeProcess						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: resume -> function(newProc) { ...;; (FunctionExpression) function(newProc) { 	var activeProc = th...(func $resume						(local $newProc i32)						(local $newPriority i32)						(local $temp i32)						(local $activeProc i32)						(local $activePriority i32)						;; (IfStatement) if (newPriority > activePriority) {this....;; (BinaryExpression) newPriority > activePriority;; (JSIdentifier) newPriority						local.get $newPriority;; (JSIdentifier) activePriority						local.get $activePriority						i32.gt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.putToSleep(activeProc) this.transfe...;; (ExpressionStatement) this.putToSleep(activeProc);; (CallExpression) this.putToSleep(activeProc)						local.get $this;; (JSIdentifier) activeProc						local.get $activeProc						call $putToSleep;; (ExpressionStatement) this.transferTo(newProc);; (CallExpression) this.transferTo(newProc)						local.get $this;; (JSIdentifier) newProc						local.get $newProc						call $transferTo)						(else;; (BlockStatement) this.putToSleep(newProc) ;; (ExpressionStatement) this.putToSleep(newProc);; (CallExpression) this.putToSleep(newProc)						local.get $this;; (JSIdentifier) newProc						local.get $newProc						call $putToSleep)));; (JSProperty) property: putToSleep -> function(aProces...;; (FunctionExpression) function(aProcess) { 	var priority = aPr...(func $putToSleep						(local $priority i32)						(local $processList i32)						(local $temp i32)						(local $aProcess i32)						(local $processLists i32)						;; (ExpressionStatement) this.linkProcessToList(aProcess, process...;; (CallExpression) this.linkProcessToList(aProcess, process...						local.get $this;; (JSIdentifier) aProcess						local.get $aProcess;; (JSIdentifier) processList						local.get $processList						call $linkProcessToList);; (JSProperty) property: transferTo -> function(newProc...;; (FunctionExpression) function(newProc) { 	var sched = this.ge...(func $transferTo						(local $newProc i32)						(local $sched i32)						(local $temp i32)						(local $oldProc i32)						;; (ExpressionStatement) sched.pointers[Squeak.ProcSched_activePr...;; (AssignmentExpression) sched.pointers[Squeak.ProcSched_activePr...						local.get $sched;; (StaticMemberExpression) Squeak.ProcSched_activeProcess;; (JSIdentifier) ProcSched_activeProcess						local.get $ProcSched_activeProcess;; (JSIdentifier) newProc						local.get $newProc						call $atPut;; (ExpressionStatement) sched.dirty = true;; (AssignmentExpression) sched.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty;; (ExpressionStatement) oldProc.pointers[Squeak.Proc_suspendedCo...;; (AssignmentExpression) oldProc.pointers[Squeak.Proc_suspendedCo...						local.get $oldProc;; (StaticMemberExpression) Squeak.Proc_suspendedContext;; (JSIdentifier) Proc_suspendedContext						local.get $Proc_suspendedContext;; (StaticMemberExpression) this.vm.activeContext;; (JSIdentifier) activeContext						local.get $activeContext						call $atPut;; (ExpressionStatement) oldProc.dirty = true;; (AssignmentExpression) oldProc.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty;; (ExpressionStatement) this.vm.newActiveContext(newProc.pointer...;; (CallExpression) this.vm.newActiveContext(newProc.pointer...						local.get $vm;; (ComputedMemberExpression) newProc.pointers[Squeak.Proc_suspendedCo...;; (StaticMemberExpression) newProc.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Proc_suspendedContext;; (JSIdentifier) Proc_suspendedContext						local.get $Proc_suspendedContext						i32.const 4						i32.mul						i32.add						call $newActiveContext;; (ExpressionStatement) newProc.pointers[Squeak.Proc_suspendedCo...;; (AssignmentExpression) newProc.pointers[Squeak.Proc_suspendedCo...						local.get $newProc;; (StaticMemberExpression) Squeak.Proc_suspendedContext;; (JSIdentifier) Proc_suspendedContext						local.get $Proc_suspendedContext;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut;; (ExpressionStatement) this.vm.reclaimableContextCount = 0;; (AssignmentExpression) this.vm.reclaimableContextCount = 0;; (JSLiteral) 0						i32.const 0						local.set $reclaimableContextCount;; (IfStatement) if (this.vm.breakOnContextChanged) {this...;; (StaticMemberExpression) this.vm.breakOnContextChanged;; (JSIdentifier) breakOnContextChanged						local.get $breakOnContextChanged						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.vm.breakOnContextChanged = false th...;; (ExpressionStatement) this.vm.breakOnContextChanged = false;; (AssignmentExpression) this.vm.breakOnContextChanged = false;; (JSLiteral) false						i32.const 0						local.set $breakOnContextChanged;; (ExpressionStatement) this.vm.breakNow();; (CallExpression) this.vm.breakNow()						local.get $vm						call $breakNow)));; (JSProperty) property: wakeHighestPriority -> functio...;; (FunctionExpression) function() { 	var schedLists = this.getS...(func $wakeHighestPriority						(local $processList i32)						(local $schedLists i32)						(local $p i32)						(local $temp i32)						;; (DoWhileStatement) an active DoWhileStatement with properti...;; (ReturnStatement) return this.removeFirstLinkOfList(proces...;; (CallExpression) this.removeFirstLinkOfList(processList)						local.get $this;; (JSIdentifier) processList						local.get $processList						call $removeFirstLinkOfList						return);; (JSProperty) property: linkProcessToList -> function(...;; (FunctionExpression) function(proc, aList) { 	if (this.isEmpt...(func $linkProcessToList						(local $proc i32)						(local $lastLink i32)						(local $temp i32)						(local $aList i32)						;; (IfStatement) if (this.isEmptyList(aList)) {aList.poin...;; (CallExpression) this.isEmptyList(aList)						local.get $this;; (JSIdentifier) aList						local.get $aList						call $isEmptyList						i32.const 0						i32.ne						(if (then;; (BlockStatement) aList.pointers[Squeak.LinkedList_firstLi...;; (ExpressionStatement) aList.pointers[Squeak.LinkedList_firstLi...;; (AssignmentExpression) aList.pointers[Squeak.LinkedList_firstLi...						local.get $aList;; (StaticMemberExpression) Squeak.LinkedList_firstLink;; (JSIdentifier) LinkedList_firstLink						local.get $LinkedList_firstLink;; (JSIdentifier) proc						local.get $proc						call $atPut)						(else;; (BlockStatement) var lastLink = aList.pointers[Squeak.Lin...;; (VariableDeclaration) var lastLink = aList.pointers[Squeak.Lin...;; (VariableDeclarator) lastLink = aList.pointers[Squeak.LinkedL...;; (ComputedMemberExpression) aList.pointers[Squeak.LinkedList_lastLin...;; (StaticMemberExpression) aList.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.LinkedList_lastLink;; (JSIdentifier) LinkedList_lastLink						local.get $LinkedList_lastLink						i32.const 4						i32.mul						i32.add						local.set $lastLink;; (ExpressionStatement) lastLink.pointers[Squeak.Link_nextLink] ...;; (AssignmentExpression) lastLink.pointers[Squeak.Link_nextLink] ...						local.get $lastLink;; (StaticMemberExpression) Squeak.Link_nextLink;; (JSIdentifier) Link_nextLink						local.get $Link_nextLink;; (JSIdentifier) proc						local.get $proc						call $atPut;; (ExpressionStatement) lastLink.dirty = true;; (AssignmentExpression) lastLink.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty));; (ExpressionStatement) aList.pointers[Squeak.LinkedList_lastLin...;; (AssignmentExpression) aList.pointers[Squeak.LinkedList_lastLin...						local.get $aList;; (StaticMemberExpression) Squeak.LinkedList_lastLink;; (JSIdentifier) LinkedList_lastLink						local.get $LinkedList_lastLink;; (JSIdentifier) proc						local.get $proc						call $atPut;; (ExpressionStatement) aList.dirty = true;; (AssignmentExpression) aList.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty;; (ExpressionStatement) proc.pointers[Squeak.Proc_myList] = aLis...;; (AssignmentExpression) proc.pointers[Squeak.Proc_myList] = aLis...						local.get $proc;; (StaticMemberExpression) Squeak.Proc_myList;; (JSIdentifier) Proc_myList						local.get $Proc_myList;; (JSIdentifier) aList						local.get $aList						call $atPut;; (ExpressionStatement) proc.dirty = true;; (AssignmentExpression) proc.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty);; (JSProperty) property: isEmptyList -> function(aLinke...;; (FunctionExpression) function(aLinkedList) { 	return aLinkedL...(func $isEmptyList						(local $temp i32)						(local $aLinkedList i32)						;; (ReturnStatement) return aLinkedList.pointers[Squeak.Linke...;; (StaticMemberExpression) aLinkedList.pointers[Squeak.LinkedList_f...;; (JSIdentifier) isNil						local.get $isNil						return);; (JSProperty) property: removeFirstLinkOfList -> funct...;; (FunctionExpression) function(aList) { 	var first = aList.poi...(func $removeFirstLinkOfList						(local $next i32)						(local $last i32)						(local $aList i32)						(local $first i32)						(local $temp i32)						;; (IfStatement) if (first === last) {aList.pointers[Sque...;; (BinaryExpression) first === last;; (JSIdentifier) first						local.get $first;; (JSIdentifier) last						local.get $last						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) aList.pointers[Squeak.LinkedList_firstLi...;; (ExpressionStatement) aList.pointers[Squeak.LinkedList_firstLi...;; (AssignmentExpression) aList.pointers[Squeak.LinkedList_firstLi...						local.get $aList;; (StaticMemberExpression) Squeak.LinkedList_firstLink;; (JSIdentifier) LinkedList_firstLink						local.get $LinkedList_firstLink;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut;; (ExpressionStatement) aList.pointers[Squeak.LinkedList_lastLin...;; (AssignmentExpression) aList.pointers[Squeak.LinkedList_lastLin...						local.get $aList;; (StaticMemberExpression) Squeak.LinkedList_lastLink;; (JSIdentifier) LinkedList_lastLink						local.get $LinkedList_lastLink;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut)						(else;; (BlockStatement) var next = first.pointers[Squeak.Link_ne...;; (VariableDeclaration) var next = first.pointers[Squeak.Link_ne...;; (VariableDeclarator) next = first.pointers[Squeak.Link_nextLi...;; (ComputedMemberExpression) first.pointers[Squeak.Link_nextLink];; (StaticMemberExpression) first.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Link_nextLink;; (JSIdentifier) Link_nextLink						local.get $Link_nextLink						i32.const 4						i32.mul						i32.add						local.set $next;; (ExpressionStatement) aList.pointers[Squeak.LinkedList_firstLi...;; (AssignmentExpression) aList.pointers[Squeak.LinkedList_firstLi...						local.get $aList;; (StaticMemberExpression) Squeak.LinkedList_firstLink;; (JSIdentifier) LinkedList_firstLink						local.get $LinkedList_firstLink;; (JSIdentifier) next						local.get $next						call $atPut;; (ExpressionStatement) aList.dirty = true;; (AssignmentExpression) aList.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty));; (ExpressionStatement) first.pointers[Squeak.Link_nextLink] = t...;; (AssignmentExpression) first.pointers[Squeak.Link_nextLink] = t...						local.get $first;; (StaticMemberExpression) Squeak.Link_nextLink;; (JSIdentifier) Link_nextLink						local.get $Link_nextLink;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut;; (ReturnStatement) return first;; (JSIdentifier) first						local.get $first						return);; (JSProperty) property: removeProcessFromList -> funct...;; (FunctionExpression) function(process, list) { 	var first = l...(func $removeProcessFromList						(local $next i32)						(local $last i32)						(local $temp i32)						(local $first i32)						(local $list i32)						(local $process i32)						;; (IfStatement) if (process === first) {var next = proce...;; (BinaryExpression) process === first;; (JSIdentifier) process						local.get $process;; (JSIdentifier) first						local.get $first						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) var next = process.pointers[Squeak.Link_...;; (VariableDeclaration) var next = process.pointers[Squeak.Link_...;; (VariableDeclarator) next = process.pointers[Squeak.Link_next...;; (ComputedMemberExpression) process.pointers[Squeak.Link_nextLink];; (StaticMemberExpression) process.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Link_nextLink;; (JSIdentifier) Link_nextLink						local.get $Link_nextLink						i32.const 4						i32.mul						i32.add						local.set $next;; (ExpressionStatement) list.pointers[Squeak.LinkedList_firstLin...;; (AssignmentExpression) list.pointers[Squeak.LinkedList_firstLin...						local.get $list;; (StaticMemberExpression) Squeak.LinkedList_firstLink;; (JSIdentifier) LinkedList_firstLink						local.get $LinkedList_firstLink;; (JSIdentifier) next						local.get $next						call $atPut;; (IfStatement) if (process === last) {list.pointers[Squ...;; (BinaryExpression) process === last;; (JSIdentifier) process						local.get $process;; (JSIdentifier) last						local.get $last						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) list.pointers[Squeak.LinkedList_lastLink...;; (ExpressionStatement) list.pointers[Squeak.LinkedList_lastLink...;; (AssignmentExpression) list.pointers[Squeak.LinkedList_lastLink...						local.get $list;; (StaticMemberExpression) Squeak.LinkedList_lastLink;; (JSIdentifier) LinkedList_lastLink						local.get $LinkedList_lastLink;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut)))						(else;; (BlockStatement) var temp = first while (true) {if (temp....;; (VariableDeclaration) var temp = first;; (VariableDeclarator) temp = first;; (JSIdentifier) first						local.get $first						local.set $temp;; (WhileStatement) while (true) {if (temp.isNil) {return th...						(loop $loop_1;; (BlockStatement) if (temp.isNil) {return this.success = f...;; (IfStatement) if (temp.isNil) {return this.success = f...;; (StaticMemberExpression) temp.isNil;; (JSIdentifier) isNil						local.get $isNil						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.success = false;; (AssignmentExpression) this.success = false;; (JSLiteral) false						i32.const 0						local.set $success						return));; (ExpressionStatement) next = temp.pointers[Squeak.Link_nextLin...;; (AssignmentExpression) next = temp.pointers[Squeak.Link_nextLin...;; (ComputedMemberExpression) temp.pointers[Squeak.Link_nextLink];; (StaticMemberExpression) temp.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Link_nextLink;; (JSIdentifier) Link_nextLink						local.get $Link_nextLink						i32.const 4						i32.mul						i32.add						local.set $next;; (IfStatement) if (next === process) {break};; (BinaryExpression) next === process;; (JSIdentifier) next						local.get $next;; (JSIdentifier) process						local.get $process						i32.eq						i32.const 0						i32.ne						(if (then;; (BreakStatement) break						br $loop_1_continue));; (JSLiteral) true						i32.const 1						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ExpressionStatement) next = process.pointers[Squeak.Link_next...;; (AssignmentExpression) next = process.pointers[Squeak.Link_next...;; (ComputedMemberExpression) process.pointers[Squeak.Link_nextLink];; (StaticMemberExpression) process.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Link_nextLink;; (JSIdentifier) Link_nextLink						local.get $Link_nextLink						i32.const 4						i32.mul						i32.add						local.set $next;; (ExpressionStatement) temp.pointers[Squeak.Link_nextLink] = ne...;; (AssignmentExpression) temp.pointers[Squeak.Link_nextLink] = ne...						local.get $temp;; (StaticMemberExpression) Squeak.Link_nextLink;; (JSIdentifier) Link_nextLink						local.get $Link_nextLink;; (JSIdentifier) next						local.get $next						call $atPut;; (IfStatement) if (process === last) {list.pointers[Squ...;; (BinaryExpression) process === last;; (JSIdentifier) process						local.get $process;; (JSIdentifier) last						local.get $last						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) list.pointers[Squeak.LinkedList_lastLink...;; (ExpressionStatement) list.pointers[Squeak.LinkedList_lastLink...;; (AssignmentExpression) list.pointers[Squeak.LinkedList_lastLink...						local.get $list;; (StaticMemberExpression) Squeak.LinkedList_lastLink;; (JSIdentifier) LinkedList_lastLink						local.get $LinkedList_lastLink;; (JSIdentifier) temp						local.get $temp						call $atPut))));; (ExpressionStatement) process.pointers[Squeak.Link_nextLink] =...;; (AssignmentExpression) process.pointers[Squeak.Link_nextLink] =...						local.get $process;; (StaticMemberExpression) Squeak.Link_nextLink;; (JSIdentifier) Link_nextLink						local.get $Link_nextLink;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut);; (JSProperty) property: registerSemaphore -> function(...;; (FunctionExpression) function(specialObjIndex) { 	var sema = ...(func $registerSemaphore						(local $temp i32)						(local $specialObjIndex i32)						(local $sema i32)						;; (IfStatement) if (this.isA(sema, Squeak.splOb_ClassSem...;; (CallExpression) this.isA(sema, Squeak.splOb_ClassSemapho...						local.get $this;; (JSIdentifier) sema						local.get $sema;; (StaticMemberExpression) Squeak.splOb_ClassSemaphore;; (JSIdentifier) splOb_ClassSemaphore						local.get $splOb_ClassSemaphore						call $isA						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.vm.specialObjects[specialObjIndex] ...;; (AssignmentExpression) this.vm.specialObjects[specialObjIndex] ...						local.get $this.vm;; (JSIdentifier) specialObjIndex						local.get $specialObjIndex;; (JSIdentifier) sema						local.get $sema						call $atPut)						(else;; (ExpressionStatement) this.vm.specialObjects[specialObjIndex] ...;; (AssignmentExpression) this.vm.specialObjects[specialObjIndex] ...						local.get $this.vm;; (JSIdentifier) specialObjIndex						local.get $specialObjIndex;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut));; (ReturnStatement) return this.vm.stackValue(1);; (CallExpression) this.vm.stackValue(1)						local.get $vm;; (JSLiteral) 1						i32.const 1						call $stackValue						return);; (JSProperty) property: primitiveWait -> function() { ...;; (FunctionExpression) function() { 	var sema = this.vm.top() i...(func $primitiveWait						(local $temp i32)						(local $sema i32)						(local $excessSignals i32)						;; (IfStatement) if (!this.isA(sema, Squeak.splOb_ClassSe...;; (UnaryExpression) !this.isA(sema, Squeak.splOb_ClassSemaph...;; (CallExpression) this.isA(sema, Squeak.splOb_ClassSemapho...						local.get $this;; (JSIdentifier) sema						local.get $sema;; (StaticMemberExpression) Squeak.splOb_ClassSemaphore;; (JSIdentifier) splOb_ClassSemaphore						local.get $splOb_ClassSemaphore						call $isA						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (excessSignals > 0) {sema.pointers[Sq...;; (BinaryExpression) excessSignals > 0;; (JSIdentifier) excessSignals						local.get $excessSignals;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) sema.pointers[Squeak.Semaphore_excessSig...;; (AssignmentExpression) sema.pointers[Squeak.Semaphore_excessSig...						local.get $sema;; (StaticMemberExpression) Squeak.Semaphore_excessSignals;; (JSIdentifier) Semaphore_excessSignals						local.get $Semaphore_excessSignals;; (BinaryExpression) excessSignals - 1;; (JSIdentifier) excessSignals						local.get $excessSignals;; (JSLiteral) 1						i32.const 1						i32.sub						call $atPut)						(else;; (BlockStatement) this.linkProcessToList(this.activeProces...;; (ExpressionStatement) this.linkProcessToList(this.activeProces...;; (CallExpression) this.linkProcessToList(this.activeProces...						local.get $this;; (CallExpression) this.activeProcess()						local.get $this						call $activeProcess;; (JSIdentifier) sema						local.get $sema						call $linkProcessToList;; (ExpressionStatement) this.transferTo(this.wakeHighestPriority...;; (CallExpression) this.transferTo(this.wakeHighestPriority...						local.get $this;; (CallExpression) this.wakeHighestPriority()						local.get $this						call $wakeHighestPriority						call $transferTo));; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveSignal -> function() ...;; (FunctionExpression) function() { 	var sema = this.vm.top() i...(func $primitiveSignal						(local $sema i32)						(local $temp i32)						;; (IfStatement) if (!this.isA(sema, Squeak.splOb_ClassSe...;; (UnaryExpression) !this.isA(sema, Squeak.splOb_ClassSemaph...;; (CallExpression) this.isA(sema, Squeak.splOb_ClassSemapho...						local.get $this;; (JSIdentifier) sema						local.get $sema;; (StaticMemberExpression) Squeak.splOb_ClassSemaphore;; (JSIdentifier) splOb_ClassSemaphore						local.get $splOb_ClassSemaphore						call $isA						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.synchronousSignal(sema);; (CallExpression) this.synchronousSignal(sema)						local.get $this;; (JSIdentifier) sema						local.get $sema						call $synchronousSignal;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: synchronousSignal -> function(...;; (FunctionExpression) function(sema) { 	if (this.isEmptyList(s...(func $synchronousSignal						(local $sema i32)						(local $temp i32)						;; (IfStatement) if (this.isEmptyList(sema)) {sema.pointe...;; (CallExpression) this.isEmptyList(sema)						local.get $this;; (JSIdentifier) sema						local.get $sema						call $isEmptyList						i32.const 0						i32.ne						(if (then;; (BlockStatement) sema.pointers[Squeak.Semaphore_excessSig...;; (ExpressionStatement) sema.pointers[Squeak.Semaphore_excessSig...;; (UpdateExpression) sema.pointers[Squeak.Semaphore_excessSig...;; (ComputedMemberExpression) sema.pointers[Squeak.Semaphore_excessSig...;; (StaticMemberExpression) sema.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Semaphore_excessSignals;; (JSIdentifier) Semaphore_excessSignals						local.get $Semaphore_excessSignals						i32.const 4						i32.mul						i32.add						i32.const 1						i32.add)						(else;; (ExpressionStatement) this.resume(this.removeFirstLinkOfList(s...;; (CallExpression) this.resume(this.removeFirstLinkOfList(s...						local.get $this;; (CallExpression) this.removeFirstLinkOfList(sema)						local.get $this;; (JSIdentifier) sema						local.get $sema						call $removeFirstLinkOfList						call $resume));; (ReturnStatement) return 						return);; (JSProperty) property: signalAtMilliseconds -> functi...;; (FunctionExpression) function(sema, msTime) { 	if (this.isA(s...(func $signalAtMilliseconds						(local $temp i32)						(local $sema i32)						(local $msTime i32)						;; (IfStatement) if (this.isA(sema, Squeak.splOb_ClassSem...;; (CallExpression) this.isA(sema, Squeak.splOb_ClassSemapho...						local.get $this;; (JSIdentifier) sema						local.get $sema;; (StaticMemberExpression) Squeak.splOb_ClassSemaphore;; (JSIdentifier) splOb_ClassSemaphore						local.get $splOb_ClassSemaphore						call $isA						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.vm.specialObjects[Squeak.splOb_TheT...;; (ExpressionStatement) this.vm.specialObjects[Squeak.splOb_TheT...;; (AssignmentExpression) this.vm.specialObjects[Squeak.splOb_TheT...						local.get $this.vm;; (StaticMemberExpression) Squeak.splOb_TheTimerSemaphore;; (JSIdentifier) splOb_TheTimerSemaphore						local.get $splOb_TheTimerSemaphore;; (JSIdentifier) sema						local.get $sema						call $atPut;; (ExpressionStatement) this.vm.nextWakeupTick = msTime;; (AssignmentExpression) this.vm.nextWakeupTick = msTime;; (JSIdentifier) msTime						local.get $msTime						local.set $nextWakeupTick)						(else;; (BlockStatement) this.vm.specialObjects[Squeak.splOb_TheT...;; (ExpressionStatement) this.vm.specialObjects[Squeak.splOb_TheT...;; (AssignmentExpression) this.vm.specialObjects[Squeak.splOb_TheT...						local.get $this.vm;; (StaticMemberExpression) Squeak.splOb_TheTimerSemaphore;; (JSIdentifier) splOb_TheTimerSemaphore						local.get $splOb_TheTimerSemaphore;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut;; (ExpressionStatement) this.vm.nextWakeupTick = 0;; (AssignmentExpression) this.vm.nextWakeupTick = 0;; (JSLiteral) 0						i32.const 0						local.set $nextWakeupTick)));; (JSProperty) property: primitiveSignalAtMilliseconds ...;; (FunctionExpression) function(argCount) { 	var msTime = this....(func $primitiveSignalAtMilliseconds						(local $msTime i32)						(local $sema i32)						(local $temp i32)						(local $argCount i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.signalAtMilliseconds(sema, msTime);; (CallExpression) this.signalAtMilliseconds(sema, msTime)						local.get $this;; (JSIdentifier) sema						local.get $sema;; (JSIdentifier) msTime						local.get $msTime						call $signalAtMilliseconds;; (ExpressionStatement) this.vm.popN(argCount);; (CallExpression) this.vm.popN(argCount)						local.get $vm;; (JSIdentifier) argCount						local.get $argCount						call $popN;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveSignalAtUTCMicrosecon...;; (FunctionExpression) function(argCount) { 	var usecsUTC = thi...(func $primitiveSignalAtUTCMicroseconds						(local $msTime i32)						(local $usecsUTC i32)						(local $sema i32)						(local $argCount i32)						(local $temp i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.signalAtMilliseconds(sema, msTime);; (CallExpression) this.signalAtMilliseconds(sema, msTime)						local.get $this;; (JSIdentifier) sema						local.get $sema;; (JSIdentifier) msTime						local.get $msTime						call $signalAtMilliseconds;; (ExpressionStatement) this.vm.popN(argCount);; (CallExpression) this.vm.popN(argCount)						local.get $vm;; (JSIdentifier) argCount						local.get $argCount						call $popN;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: signalSemaphoreWithIndex -> fu...;; (FunctionExpression) function(semaIndex) { 	this.semaphoresTo...(func $signalSemaphoreWithIndex						(local $temp i32)						(local $semaIndex i32)						;; (ExpressionStatement) this.semaphoresToSignal.push(semaIndex);; (CallExpression) this.semaphoresToSignal.push(semaIndex)						local.get $semaphoresToSignal;; (JSIdentifier) semaIndex						local.get $semaIndex						call $push);; (JSProperty) property: signalExternalSemaphores -> fu...;; (FunctionExpression) function() { 	var semaphores = this.vm.s...(func $signalExternalSemaphores						(local $semaphores i32)						(local $semaClass i32)						(local $sema i32)						(local $temp i32)						(local $semaIndex i32)						;; (WhileStatement) while (this.semaphoresToSignal.length) {...						(loop $loop_1;; (BlockStatement) var semaIndex = this.semaphoresToSignal....;; (VariableDeclaration) var semaIndex = this.semaphoresToSignal....;; (VariableDeclarator) semaIndex = this.semaphoresToSignal.shif...;; (CallExpression) this.semaphoresToSignal.shift()						local.get $semaphoresToSignal						call $shift						local.set $semaIndex;; (VariableDeclarator) sema = semaphores[semaIndex - 1];; (ComputedMemberExpression) semaphores[semaIndex - 1];; (JSIdentifier) semaphores						local.get $semaphores;; (BinaryExpression) semaIndex - 1;; (JSIdentifier) semaIndex						local.get $semaIndex;; (JSLiteral) 1						i32.const 1						i32.sub						i32.const 4						i32.mul						i32.add						local.set $sema;; (IfStatement) if (sema.sqClass == semaClass) {this.syn...;; (BinaryExpression) sema.sqClass == semaClass;; (StaticMemberExpression) sema.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (JSIdentifier) semaClass						local.get $semaClass						i32.eq						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.synchronousSignal(sema);; (CallExpression) this.synchronousSignal(sema)						local.get $this;; (JSIdentifier) sema						local.get $sema						call $synchronousSignal));; (StaticMemberExpression) this.semaphoresToSignal.length;; (JSIdentifier) length						local.get $length						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue));; (JSProperty) property: primitiveEnterCriticalSection ...;; (FunctionExpression) function(argCount) { 	if (argCount > 1) ...(func $primitiveEnterCriticalSection						(local $argCount i32)						(local $activeProc i32)						(local $temp i32)						(local $owningProcess i32)						(local $mutex i32)						;; (IfStatement) if (argCount > 1) {return false};; (BinaryExpression) argCount > 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (owningProcess.isNil) {mutex.pointers...;; (StaticMemberExpression) owningProcess.isNil;; (JSIdentifier) isNil						local.get $isNil						i32.const 0						i32.ne						(if (then;; (BlockStatement) mutex.pointers[Squeak.Mutex_owner] = act...;; (ExpressionStatement) mutex.pointers[Squeak.Mutex_owner] = act...;; (AssignmentExpression) mutex.pointers[Squeak.Mutex_owner] = act...						local.get $mutex;; (StaticMemberExpression) Squeak.Mutex_owner;; (JSIdentifier) Mutex_owner						local.get $Mutex_owner;; (JSIdentifier) activeProc						local.get $activeProc						call $atPut;; (ExpressionStatement) mutex.dirty = true;; (AssignmentExpression) mutex.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty;; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, this....;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (StaticMemberExpression) this.vm.falseObj;; (JSIdentifier) falseObj						local.get $falseObj						call $popNandPushIfOK)						(else;; (IfStatement) if (owningProcess === activeProc) {this....;; (BinaryExpression) owningProcess === activeProc;; (JSIdentifier) owningProcess						local.get $owningProcess;; (JSIdentifier) activeProc						local.get $activeProc						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.popNandPushIfOK(argCount + 1, this....;; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, this....;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (StaticMemberExpression) this.vm.trueObj;; (JSIdentifier) trueObj						local.get $trueObj						call $popNandPushIfOK)						(else;; (BlockStatement) this.popNandPushIfOK(argCount + 1, this....;; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, this....;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (StaticMemberExpression) this.vm.falseObj;; (JSIdentifier) falseObj						local.get $falseObj						call $popNandPushIfOK;; (ExpressionStatement) this.linkProcessToList(activeProc, mutex...;; (CallExpression) this.linkProcessToList(activeProc, mutex...						local.get $this;; (JSIdentifier) activeProc						local.get $activeProc;; (JSIdentifier) mutex						local.get $mutex						call $linkProcessToList;; (ExpressionStatement) this.transferTo(this.wakeHighestPriority...;; (CallExpression) this.transferTo(this.wakeHighestPriority...						local.get $this;; (CallExpression) this.wakeHighestPriority()						local.get $this						call $wakeHighestPriority						call $transferTo))));; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveExitCriticalSection -...;; (FunctionExpression) function(argCount) { 	var criticalSectio...(func $primitiveExitCriticalSection						(local $temp i32)						(local $argCount i32)						(local $owningProcess i32)						(local $criticalSection i32)						;; (IfStatement) if (this.isEmptyList(criticalSection)) {...;; (CallExpression) this.isEmptyList(criticalSection)						local.get $this;; (JSIdentifier) criticalSection						local.get $criticalSection						call $isEmptyList						i32.const 0						i32.ne						(if (then;; (BlockStatement) criticalSection.pointers[Squeak.Mutex_ow...;; (ExpressionStatement) criticalSection.pointers[Squeak.Mutex_ow...;; (AssignmentExpression) criticalSection.pointers[Squeak.Mutex_ow...						local.get $criticalSection;; (StaticMemberExpression) Squeak.Mutex_owner;; (JSIdentifier) Mutex_owner						local.get $Mutex_owner;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $atPut)						(else;; (BlockStatement) var owningProcess = this.removeFirstLink...;; (VariableDeclaration) var owningProcess = this.removeFirstLink...;; (VariableDeclarator) owningProcess = this.removeFirstLinkOfLi...;; (CallExpression) this.removeFirstLinkOfList(criticalSecti...						local.get $this;; (JSIdentifier) criticalSection						local.get $criticalSection						call $removeFirstLinkOfList						local.set $owningProcess;; (ExpressionStatement) criticalSection.pointers[Squeak.Mutex_ow...;; (AssignmentExpression) criticalSection.pointers[Squeak.Mutex_ow...						local.get $criticalSection;; (StaticMemberExpression) Squeak.Mutex_owner;; (JSIdentifier) Mutex_owner						local.get $Mutex_owner;; (JSIdentifier) owningProcess						local.get $owningProcess						call $atPut;; (ExpressionStatement) criticalSection.dirty = true;; (AssignmentExpression) criticalSection.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty;; (ExpressionStatement) this.resume(owningProcess);; (CallExpression) this.resume(owningProcess)						local.get $this;; (JSIdentifier) owningProcess						local.get $owningProcess						call $resume));; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveTestAndSetOwnershipOf...;; (FunctionExpression) function(argCount) { 	if (argCount > 1) ...(func $primitiveTestAndSetOwnershipOfCriticalSection						(local $argCount i32)						(local $activeProc i32)						(local $temp i32)						(local $owningProcess i32)						(local $mutex i32)						;; (IfStatement) if (argCount > 1) {return false};; (BinaryExpression) argCount > 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (owningProcess.isNil) {mutex.pointers...;; (StaticMemberExpression) owningProcess.isNil;; (JSIdentifier) isNil						local.get $isNil						i32.const 0						i32.ne						(if (then;; (BlockStatement) mutex.pointers[Squeak.Mutex_owner] = act...;; (ExpressionStatement) mutex.pointers[Squeak.Mutex_owner] = act...;; (AssignmentExpression) mutex.pointers[Squeak.Mutex_owner] = act...						local.get $mutex;; (StaticMemberExpression) Squeak.Mutex_owner;; (JSIdentifier) Mutex_owner						local.get $Mutex_owner;; (JSIdentifier) activeProc						local.get $activeProc						call $atPut;; (ExpressionStatement) mutex.dirty = true;; (AssignmentExpression) mutex.dirty = true;; (JSLiteral) true						i32.const 1						local.set $dirty;; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, this....;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (StaticMemberExpression) this.vm.falseObj;; (JSIdentifier) falseObj						local.get $falseObj						call $popNandPushIfOK)						(else;; (IfStatement) if (owningProcess === activeProc) {this....;; (BinaryExpression) owningProcess === activeProc;; (JSIdentifier) owningProcess						local.get $owningProcess;; (JSIdentifier) activeProc						local.get $activeProc						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.popNandPushIfOK(argCount + 1, this....;; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, this....;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (StaticMemberExpression) this.vm.trueObj;; (JSIdentifier) trueObj						local.get $trueObj						call $popNandPushIfOK)						(else;; (BlockStatement) this.popNandPushIfOK(argCount + 1, this....;; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, this....;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						call $popNandPushIfOK))));; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveGetAttribute -> funct...;; (FunctionExpression) function(argCount) { 	var attr = this.st...(func $primitiveGetAttribute						(local $value i32)						(local $attr i32)						(local $argv i32)						(local $argCount i32)						(local $temp i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (SwitchStatement) switch (attr) { case 0: value = argv && ;; (ExpressionStatement) this.vm.popNandPush(argCount + 1, this.m...;; (CallExpression) this.vm.popNandPush(argCount + 1, this.m...						local.get $vm;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeStObject(value)						local.get $this;; (JSIdentifier) value						local.get $value						call $makeStObject						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: setLowSpaceThreshold -> functi...;; (FunctionExpression) function() { 	var nBytes = this.stackInt...(func $setLowSpaceThreshold						(local $nBytes i32)						(local $temp i32)						;; (IfStatement) if (this.success) {this.vm.lowSpaceThres...;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.vm.lowSpaceThreshold = nBytes;; (AssignmentExpression) this.vm.lowSpaceThreshold = nBytes;; (JSIdentifier) nBytes						local.get $nBytes						local.set $lowSpaceThreshold));; (ReturnStatement) return this.vm.stackValue(1);; (CallExpression) this.vm.stackValue(1)						local.get $vm;; (JSLiteral) 1						i32.const 1						call $stackValue						return);; (JSProperty) property: primitiveVMParameter -> functi...;; (FunctionExpression) function(argCount) { 	var paramsArraySiz...(func $primitiveVMParameter						(local $paramsArraySize i32)						(local $argCount i32)						(local $temp i32)												;; unwritable: (SwitchStatement) switch (argCount) { case 0: var arrayObj;; (EmptyStatement) ;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: vmParameterAt -> function(inde...;; (FunctionExpression) function(index) { 	switch (index) { case...(func $vmParameterAt						(local $temp i32)						(local $index i32)						;; (SwitchStatement) switch (index) { case 1: return this.vm....index						local.set $temp;; (SwitchCase)  case 1: return this.vm.image.oldSpaceBy...						local.get $temp;; (JSLiteral) 1						i32.const 1						i32.eq						(if (then ;; (ReturnStatement) return this.vm.image.oldSpaceBytes;; (StaticMemberExpression) this.vm.image.oldSpaceBytes;; (JSIdentifier) oldSpaceBytes						local.get $oldSpaceBytes						return						));; (SwitchCase)  case 2: return this.vm.image.oldSpaceBy...						local.get $temp;; (JSLiteral) 2						i32.const 2						i32.eq						(if (then ;; (ReturnStatement) return this.vm.image.oldSpaceBytes;; (StaticMemberExpression) this.vm.image.oldSpaceBytes;; (JSIdentifier) oldSpaceBytes						local.get $oldSpaceBytes						return						));; (SwitchCase)  case 3: return this.vm.image.totalMemor...						local.get $temp;; (JSLiteral) 3						i32.const 3						i32.eq						(if (then ;; (ReturnStatement) return this.vm.image.totalMemory;; (StaticMemberExpression) this.vm.image.totalMemory;; (JSIdentifier) totalMemory						local.get $totalMemory						return						));; (SwitchCase)  case 4: return this.vm.image.allocation...						local.get $temp;; (JSLiteral) 4						i32.const 4						i32.eq						(if (then ;; (ReturnStatement) return this.vm.image.allocationCount + t...;; (BinaryExpression) this.vm.image.allocationCount + this.vm....;; (StaticMemberExpression) this.vm.image.allocationCount;; (JSIdentifier) allocationCount						local.get $allocationCount;; (StaticMemberExpression) this.vm.image.newSpaceCount;; (JSIdentifier) newSpaceCount						local.get $newSpaceCount						i32.add						return						));; (SwitchCase)  case 7: return this.vm.image.gcCount						local.get $temp;; (JSLiteral) 7						i32.const 7						i32.eq						(if (then ;; (ReturnStatement) return this.vm.image.gcCount;; (StaticMemberExpression) this.vm.image.gcCount;; (JSIdentifier) gcCount						local.get $gcCount						return						));; (SwitchCase)  case 8: return this.vm.image.gcMillisec...						local.get $temp;; (JSLiteral) 8						i32.const 8						i32.eq						(if (then ;; (ReturnStatement) return this.vm.image.gcMilliseconds;; (StaticMemberExpression) this.vm.image.gcMilliseconds;; (JSIdentifier) gcMilliseconds						local.get $gcMilliseconds						return						));; (SwitchCase)  case 9: return this.vm.image.pgcCount						local.get $temp;; (JSLiteral) 9						i32.const 9						i32.eq						(if (then ;; (ReturnStatement) return this.vm.image.pgcCount;; (StaticMemberExpression) this.vm.image.pgcCount;; (JSIdentifier) pgcCount						local.get $pgcCount						return						));; (SwitchCase)  case 10: return this.vm.image.pgcMillis...						local.get $temp;; (JSLiteral) 10						i32.const 10						i32.eq						(if (then ;; (ReturnStatement) return this.vm.image.pgcMilliseconds;; (StaticMemberExpression) this.vm.image.pgcMilliseconds;; (JSIdentifier) pgcMilliseconds						local.get $pgcMilliseconds						return						));; (SwitchCase)  case 11: return this.vm.image.gcTenured						local.get $temp;; (JSLiteral) 11						i32.const 11						i32.eq						(if (then ;; (ReturnStatement) return this.vm.image.gcTenured;; (StaticMemberExpression) this.vm.image.gcTenured;; (JSIdentifier) gcTenured						local.get $gcTenured						return						));; (SwitchCase)  case 15:						local.get $temp;; (JSLiteral) 15						i32.const 15						i32.eq						(if (then 						));; (SwitchCase)  case 16:						local.get $temp;; (JSLiteral) 16						i32.const 16						i32.eq						(if (then 						));; (SwitchCase)  case 17: return 0						local.get $temp;; (JSLiteral) 17						i32.const 17						i32.eq						(if (then ;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return						));; (SwitchCase)  case 22: return 0						local.get $temp;; (JSLiteral) 22						i32.const 22						i32.eq						(if (then ;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return						));; (SwitchCase)  case 23: return this.vm.image.extraVMMe...						local.get $temp;; (JSLiteral) 23						i32.const 23						i32.eq						(if (then ;; (ReturnStatement) return this.vm.image.extraVMMemory;; (StaticMemberExpression) this.vm.image.extraVMMemory;; (JSIdentifier) extraVMMemory						local.get $extraVMMemory						return						));; (SwitchCase)  case 40: return 4						local.get $temp;; (JSLiteral) 40						i32.const 40						i32.eq						(if (then ;; (ReturnStatement) return 4;; (JSLiteral) 4						i32.const 4						return						));; (SwitchCase)  case 41: return this.vm.image.formatVer...						local.get $temp;; (JSLiteral) 41						i32.const 41						i32.eq						(if (then ;; (ReturnStatement) return this.vm.image.formatVersion();; (CallExpression) this.vm.image.formatVersion()						local.get $vm.image						call $formatVersion						return						));; (SwitchCase)  case 44: return 0						local.get $temp;; (JSLiteral) 44						i32.const 44						i32.eq						(if (then ;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return						));; (SwitchCase)  case 48: return 0						local.get $temp;; (JSLiteral) 48						i32.const 48						i32.eq						(if (then ;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return						));; (SwitchCase)  case 54: return this.vm.image.bytesLeft...						local.get $temp;; (JSLiteral) 54						i32.const 54						i32.eq						(if (then ;; (ReturnStatement) return this.vm.image.bytesLeft();; (CallExpression) this.vm.image.bytesLeft()						local.get $vm.image						call $bytesLeft						return						));; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return);; (JSProperty) property: primitiveImageName -> function...;; (FunctionExpression) function(argCount) { 	if (argCount == 0)...(func $primitiveImageName						(local $argCount i32)						(local $temp i32)						;; (IfStatement) if (argCount == 0) {return this.popNandP...;; (BinaryExpression) argCount == 0;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.popNandPushIfOK(1, this.make...;; (CallExpression) this.popNandPushIfOK(1, this.makeStStrin...						local.get $this;; (JSLiteral) 1						i32.const 1;; (CallExpression) this.makeStString(this.filenameToSqueak(...						local.get $this;; (CallExpression) this.filenameToSqueak(this.vm.image.name...						local.get $this;; (StaticMemberExpression) this.vm.image.name;; (JSIdentifier) name						local.get $name						call $filenameToSqueak						call $makeStString						call $popNandPushIfOK						return))						;; unwritable: (ExpressionStatement) this.vm.image.name = this.filenameFromSq						;; unwritable: (ExpressionStatement) self.localStorage['squeakImageName'] = t;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveSnapshot -> function(...;; (FunctionExpression) function(argCount) { 	this.vm.popNandPus...(func $primitiveSnapshot						(local $buffer i32)						(local $argCount i32)						(local $temp i32)						;; (ExpressionStatement) this.vm.popNandPush(1, this.vm.trueObj);; (CallExpression) this.vm.popNandPush(1, this.vm.trueObj)						local.get $vm;; (JSLiteral) 1						i32.const 1;; (StaticMemberExpression) this.vm.trueObj;; (JSIdentifier) trueObj						local.get $trueObj						call $popNandPush;; (ExpressionStatement) this.vm.storeContextRegisters();; (CallExpression) this.vm.storeContextRegisters()						local.get $vm						call $storeContextRegisters						;; unwritable: (ExpressionStatement) this.activeProcess().pointers[Squeak.Pro						;; unwritable: (ExpressionStatement) this.vm.image.fullGC('snapshot')						;; unwritable: (ExpressionStatement) Squeak.flushAllFiles()						;; unwritable: (ExpressionStatement) Squeak.filePut(this.vm.image.name, buffe;; (ExpressionStatement) this.vm.popNandPush(1, this.vm.falseObj);; (CallExpression) this.vm.popNandPush(1, this.vm.falseObj)						local.get $vm;; (JSLiteral) 1						i32.const 1;; (StaticMemberExpression) this.vm.falseObj;; (JSIdentifier) falseObj						local.get $falseObj						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveQuit -> function(argC...;; (FunctionExpression) function(argCount) { 	Squeak.flushAllFil...(func $primitiveQuit						(local $argCount i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) Squeak.flushAllFiles();; (ExpressionStatement) this.display.quitFlag = true;; (AssignmentExpression) this.display.quitFlag = true;; (JSLiteral) true						i32.const 1						local.set $quitFlag						;; unwritable: (ExpressionStatement) this.vm.breakNow('quit');; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveExitToDebugger -> fun...;; (FunctionExpression) function(argCount) { 	this.vm.breakNow('...(func $primitiveExitToDebugger						(local $argCount i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.vm.breakNow('debugger primitive');; (DebuggerStatement) an active DebuggerStatement with propert...;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveSetGCBiasToGrow -> fu...;; (FunctionExpression) function(argCount) { 	return this.fakePr...(func $primitiveSetGCBiasToGrow						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.fakePrimitive('.primitiveSet);; (JSProperty) property: primitiveSetGCBiasToGrowGCLimi...;; (FunctionExpression) function(argCount) { 	return this.fakePr...(func $primitiveSetGCBiasToGrowGCLimit						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.fakePrimitive('.primitiveSet);; (JSProperty) property: primitiveBeCursor -> function(...;; (FunctionExpression) function(argCount) { 	var cursorCanvas =...(func $primitiveBeCursor						(local $context i32)						(local $temp i32)						(local $cursorCanvas i32)						(local $scale i32)						(local $canvas i32)						(local $maskForm i32)						(local $argCount i32)						(local $cursorForm i32)						(local $bounds i32)						;; (IfStatement) if (!this.success || !cursorForm) {retur...;; (BinaryExpression) !this.success || !cursorForm;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !cursorForm;; (JSIdentifier) cursorForm						local.get $cursorForm						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (IfStatement) if (cursorCanvas) {cursorCanvas.style.vi						;; unwritable: (IfStatement) if (cursorCanvas) {context = cursorCanva;; (ExpressionStatement) this.vm.popN(argCount);; (CallExpression) this.vm.popN(argCount)						local.get $vm;; (JSIdentifier) argCount						local.get $argCount						call $popN;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: cursorMergeMask -> function(cu...;; (FunctionExpression) function(cursor, mask) { 	var bits = new...(func $cursorMergeMask						(local $m i32)						(local $bit i32)						(local $temp i32)						(local $cursor i32)						(local $bits i32)						(local $merged i32)						(local $mask i32)						(local $x i32)						(local $c i32)						(local $y i32)						;; (ForStatement) for (var y = 0; y < 16; y++) {var c = cu...;; (VariableDeclaration) var y = 0;; (VariableDeclarator) y = 0;; (JSLiteral) 0						i32.const 0						local.set $y						(loop $loop_1;; (BlockStatement) var c = cursor.bits[y], m = mask.bits[y]...;; (VariableDeclaration) var c = cursor.bits[y], m = mask.bits[y]...;; (VariableDeclarator) c = cursor.bits[y];; (ComputedMemberExpression) cursor.bits[y];; (StaticMemberExpression) cursor.bits;; (JSIdentifier) bits						local.get $bits;; (JSIdentifier) y						local.get $y						i32.const 4						i32.mul						i32.add						local.set $c;; (VariableDeclarator) m = mask.bits[y];; (ComputedMemberExpression) mask.bits[y];; (StaticMemberExpression) mask.bits;; (JSIdentifier) bits						local.get $bits;; (JSIdentifier) y						local.get $y						i32.const 4						i32.mul						i32.add						local.set $m;; (VariableDeclarator) bit = 2.147483648e9;; (JSLiteral) 2.147483648e9						i32.const 2147483648						local.set $bit;; (VariableDeclarator) merged = 0;; (JSLiteral) 0						i32.const 0						local.set $merged;; (ForStatement) for (var x = 0; x < 16; x++) {merged = m...;; (VariableDeclaration) var x = 0;; (VariableDeclarator) x = 0;; (JSLiteral) 0						i32.const 0						local.set $x						(loop $loop_2;; (BlockStatement) merged = merged | m & bit >> x | c & bit...;; (ExpressionStatement) merged = merged | m & bit >> x | c & bit...;; (AssignmentExpression) merged = merged | m & bit >> x | c & bit...;; (BinaryExpression) merged | m & bit >> x | c & bit >> x + 1;; (BinaryExpression) merged | m & bit >> x;; (JSIdentifier) merged						local.get $merged;; (BinaryExpression) m & bit >> x;; (BinaryExpression) m & bit;; (JSIdentifier) m						local.get $m;; (JSIdentifier) bit						local.get $bit						i32.and;; (JSIdentifier) x						local.get $x						i32.shr_s						i32.or;; (BinaryExpression) c & bit >> x + 1;; (BinaryExpression) c & bit;; (JSIdentifier) c						local.get $c;; (JSIdentifier) bit						local.get $bit						i32.and;; (BinaryExpression) x + 1;; (JSIdentifier) x						local.get $x;; (JSLiteral) 1						i32.const 1						i32.add						i32.shr_s						i32.or						local.set $merged;; (ExpressionStatement) bit = bit >>> 1;; (AssignmentExpression) bit = bit >>> 1;; (BinaryExpression) bit >>> 1;; (JSIdentifier) bit						local.get $bit;; (JSLiteral) 1						i32.const 1						i32.shr_u						local.set $bit;; (UpdateExpression) x++;; (JSIdentifier) x						local.get $x						i32.const 1						i32.add;; (BinaryExpression) x < 16;; (JSIdentifier) x						local.get $x;; (JSLiteral) 16						i32.const 16						i32.lt_u						i32.const 0						br_if $loop_2);; (ExpressionStatement) bits[y] = merged;; (AssignmentExpression) bits[y] = merged						local.get $'bits';; (JSIdentifier) y						local.get $y;; (JSIdentifier) merged						local.get $merged						call $atPut;; (UpdateExpression) y++;; (JSIdentifier) y						local.get $y						i32.const 1						i32.add;; (BinaryExpression) y < 16;; (JSIdentifier) y						local.get $y;; (JSLiteral) 16						i32.const 16						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return {property: obj -> cursor.obj, pro...;; (ObjectExpression) {property: obj -> cursor.obj, property: ...						return);; (JSProperty) property: primitiveBeDisplay -> function...;; (FunctionExpression) function(argCount) { 	var displayObj = t...(func $primitiveBeDisplay						(local $temp i32)						(local $argCount i32)						(local $displayObj i32)						;; (ExpressionStatement) this.vm.specialObjects[Squeak.splOb_TheD...;; (AssignmentExpression) this.vm.specialObjects[Squeak.splOb_TheD...						local.get $this.vm;; (StaticMemberExpression) Squeak.splOb_TheDisplay;; (JSIdentifier) splOb_TheDisplay						local.get $splOb_TheDisplay;; (JSIdentifier) displayObj						local.get $displayObj						call $atPut;; (ExpressionStatement) this.vm.popN(argCount);; (CallExpression) this.vm.popN(argCount)						local.get $vm;; (JSIdentifier) argCount						local.get $argCount						call $popN;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveReverseDisplay -> fun...;; (FunctionExpression) function(argCount) { 	this.reverseDispla...(func $primitiveReverseDisplay						(local $data i32)						(local $image i32)						(local $canvas i32)						(local $i i32)						(local $argCount i32)						(local $context i32)						(local $temp i32)						;; (ExpressionStatement) this.reverseDisplay = !this.reverseDispl...;; (AssignmentExpression) this.reverseDisplay = !this.reverseDispl...;; (UnaryExpression) !this.reverseDisplay;; (StaticMemberExpression) this.reverseDisplay;; (JSIdentifier) reverseDisplay						local.get $reverseDisplay						local.set $temp						i32.const -1						local.get $temp						i32.sub						local.set $reverseDisplay;; (ExpressionStatement) this.redrawDisplay();; (CallExpression) this.redrawDisplay()						local.get $this						call $redrawDisplay						;; unwritable: (IfStatement) if (this.display.cursorCanvas) {var canv;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveShowDisplayRect -> fu...;; (FunctionExpression) function(argCount) { 	var rect = {proper...(func $primitiveShowDisplayRect						(local $rect i32)						(local $argCount i32)						(local $temp i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.redrawDisplay(rect);; (CallExpression) this.redrawDisplay(rect)						local.get $this;; (JSIdentifier) rect						local.get $rect						call $redrawDisplay;; (ExpressionStatement) this.vm.popN(argCount);; (CallExpression) this.vm.popN(argCount)						local.get $vm;; (JSIdentifier) argCount						local.get $argCount						call $popN;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: redrawDisplay -> function(rect...;; (FunctionExpression) function(rect) { 	var theDisplay = this....(func $redrawDisplay						(local $bounds i32)						(local $temp i32)						(local $rect i32)						(local $theDisplay i32)						;; (IfStatement) if (rect) {if (rect.left > bounds.left) ...;; (JSIdentifier) rect						local.get $rect						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (rect.left > bounds.left) {bounds.lef...;; (IfStatement) if (rect.left > bounds.left) {bounds.lef...;; (BinaryExpression) rect.left > bounds.left;; (StaticMemberExpression) rect.left;; (JSIdentifier) left						local.get $left;; (StaticMemberExpression) bounds.left;; (JSIdentifier) left						local.get $left						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) bounds.left = rect.left;; (AssignmentExpression) bounds.left = rect.left;; (StaticMemberExpression) rect.left;; (JSIdentifier) left						local.get $left						local.set $left));; (IfStatement) if (rect.right < bounds.right) {bounds.r...;; (BinaryExpression) rect.right < bounds.right;; (StaticMemberExpression) rect.right;; (JSIdentifier) right						local.get $right;; (StaticMemberExpression) bounds.right;; (JSIdentifier) right						local.get $right						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) bounds.right = rect.right;; (AssignmentExpression) bounds.right = rect.right;; (StaticMemberExpression) rect.right;; (JSIdentifier) right						local.get $right						local.set $right));; (IfStatement) if (rect.top > bounds.top) {bounds.top =...;; (BinaryExpression) rect.top > bounds.top;; (StaticMemberExpression) rect.top;; (JSIdentifier) top						local.get $top;; (StaticMemberExpression) bounds.top;; (JSIdentifier) top						local.get $top						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) bounds.top = rect.top;; (AssignmentExpression) bounds.top = rect.top;; (StaticMemberExpression) rect.top;; (JSIdentifier) top						local.get $top						local.set $top));; (IfStatement) if (rect.bottom < bounds.bottom) {bounds...;; (BinaryExpression) rect.bottom < bounds.bottom;; (StaticMemberExpression) rect.bottom;; (JSIdentifier) bottom						local.get $bottom;; (StaticMemberExpression) bounds.bottom;; (JSIdentifier) bottom						local.get $bottom						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) bounds.bottom = rect.bottom;; (AssignmentExpression) bounds.bottom = rect.bottom;; (StaticMemberExpression) rect.bottom;; (JSIdentifier) bottom						local.get $bottom						local.set $bottom))));; (IfStatement) if (bounds.left < bounds.right && bounds...;; (BinaryExpression) bounds.left < bounds.right && bounds.top...;; (BinaryExpression) bounds.left < bounds.right;; (StaticMemberExpression) bounds.left;; (JSIdentifier) left						local.get $left;; (StaticMemberExpression) bounds.right;; (JSIdentifier) right						local.get $right						i32.lt_u;; (BinaryExpression) bounds.top < bounds.bottom;; (StaticMemberExpression) bounds.top;; (JSIdentifier) top						local.get $top;; (StaticMemberExpression) bounds.bottom;; (JSIdentifier) bottom						local.get $bottom						i32.lt_u						i32.and						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.displayUpdate(theDisplay, bounds);; (CallExpression) this.displayUpdate(theDisplay, bounds)						local.get $this;; (JSIdentifier) theDisplay						local.get $theDisplay;; (JSIdentifier) bounds						local.get $bounds						call $displayUpdate)));; (JSProperty) property: primitiveShowTopLeftBottomRigh...;; (FunctionExpression) function(argCount) { 	var top = this.vm....(func $primitiveShowTopLeftBottomRightInFormAt						(local $temp i32)						(local $form i32)						(local $originObj i32)						(local $right i32)						(local $argCount i32)						(local $left i32)						(local $formObj i32)						(local $bottom i32)						(local $top i32)						;; (ExpressionStatement) this.showFormAt(this.vm.stackValue(0).js...;; (CallExpression) this.showFormAt(this.vm.stackValue(0).js...						local.get $this;; (StaticMemberExpression) this.vm.stackValue(0).jsObject;; (JSIdentifier) jsObject						local.get $jsObject;; (JSIdentifier) form						local.get $form;; (ObjectExpression) {property: left -> left, property: top -...;; (ObjectExpression) {property: x -> originObj.pointers[Squea...;; (JSLiteral) true						i32.const 1						call $showFormAt;; (ExpressionStatement) this.vm.popN(argCount);; (CallExpression) this.vm.popN(argCount)						local.get $vm;; (JSIdentifier) argCount						local.get $argCount						call $popN;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: showForm -> function(ctx, form...;; (FunctionExpression) function(ctx, form, rect, cursorColors) ...(func $showForm						(local $cursorColors i32)						(local $ctx i32)						(local $temp i32)						(local $rect i32)						(local $form i32)						;; (ExpressionStatement) this.showFormAt(ctx, form, rect, {proper...;; (CallExpression) this.showFormAt(ctx, form, rect, {proper...						local.get $this;; (JSIdentifier) ctx						local.get $ctx;; (JSIdentifier) form						local.get $form;; (JSIdentifier) rect						local.get $rect;; (ObjectExpression) {property: x -> rect.left, property: y -...;; (JSIdentifier) cursorColors						local.get $cursorColors						call $showFormAt);; (JSProperty) property: showFormAt -> function(ctx, fo...;; (FunctionExpression) function(ctx, form, rect, point, cursorC...(func $showFormAt						(local $form i32)						(local $rect i32)						(local $temp i32)						(local $cursorColors i32)						(local $ctx i32)						(local $srcX i32)						(local $pixelData i32)						(local $dest i32)						(local $srcW i32)						(local $pixels i32)						(local $srcH i32)						(local $srcY i32)						(local $point i32)						;; (IfStatement) if (!rect) {return };; (UnaryExpression) !rect;; (JSIdentifier) rect						local.get $rect						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 						return));; (IfStatement) if (!ctx) {return };; (UnaryExpression) !ctx;; (JSIdentifier) ctx						local.get $ctx						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 						return));; (IfStatement) if (!pixelData.buffer) {pixelData = new ...;; (UnaryExpression) !pixelData.buffer;; (StaticMemberExpression) pixelData.buffer;; (JSIdentifier) buffer						local.get $buffer						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) pixelData = new Uint8Array(srcW * srcH *...;; (ExpressionStatement) pixelData = new Uint8Array(srcW * srcH *...;; (AssignmentExpression) pixelData = new Uint8Array(srcW * srcH *...;; (NewExpression) new Uint8Array(srcW * srcH * 4)						unreachable						local.set $pixelData))						;; unwritable: (SwitchStatement) switch (form.depth) { case 1: case 2: ca;; (EmptyStatement) ;; (IfStatement) if (pixels.data !== pixelData) {pixels.d...;; (BinaryExpression) pixels.data !== pixelData;; (StaticMemberExpression) pixels.data;; (JSIdentifier) data						local.get $data;; (JSIdentifier) pixelData						local.get $pixelData						i32.ne						i32.const 0						i32.ne						(if (then;; (BlockStatement) pixels.data.set(pixelData) ;; (ExpressionStatement) pixels.data.set(pixelData);; (CallExpression) pixels.data.set(pixelData)						local.get $pixels.data;; (JSIdentifier) pixelData						local.get $pixelData						call $set));; (ExpressionStatement) ctx.putImageData(pixels, point.x, point....;; (CallExpression) ctx.putImageData(pixels, point.x, point....						local.get $ctx;; (JSIdentifier) pixels						local.get $pixels;; (StaticMemberExpression) point.x;; (JSIdentifier) x						local.get $x;; (StaticMemberExpression) point.y;; (JSIdentifier) y						local.get $y						call $putImageData);; (JSProperty) property: primitiveDeferDisplayUpdates -...;; (FunctionExpression) function(argCount) { 	var flag = this.st...(func $primitiveDeferDisplayUpdates						(local $temp i32)						(local $argCount i32)						(local $flag i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.deferDisplayUpdates = flag;; (AssignmentExpression) this.deferDisplayUpdates = flag;; (JSIdentifier) flag						local.get $flag						local.set $deferDisplayUpdates;; (ExpressionStatement) this.vm.popN(argCount);; (CallExpression) this.vm.popN(argCount)						local.get $vm;; (JSIdentifier) argCount						local.get $argCount						call $popN;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveForceDisplayUpdate ->...;; (FunctionExpression) function(argCount) { 	this.vm.breakOut()...(func $primitiveForceDisplayUpdate						(local $argCount i32)						(local $temp i32)						;; (ExpressionStatement) this.vm.breakOut();; (CallExpression) this.vm.breakOut()						local.get $vm						call $breakOut;; (ExpressionStatement) this.vm.popN(argCount);; (CallExpression) this.vm.popN(argCount)						local.get $vm;; (JSIdentifier) argCount						local.get $argCount						call $popN;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveScreenSize -> functio...;; (FunctionExpression) function(argCount) { 	var display = this...(func $primitiveScreenSize						(local $display i32)						(local $argCount i32)						(local $temp i32)						(local $w i32)						(local $h i32)						;; (IfStatement) if (display.context) {w = display.contex...;; (StaticMemberExpression) display.context;; (JSIdentifier) context						local.get $context						i32.const 0						i32.ne						(if (then;; (BlockStatement) w = display.context.canvas.width h = dis...;; (ExpressionStatement) w = display.context.canvas.width;; (AssignmentExpression) w = display.context.canvas.width;; (StaticMemberExpression) display.context.canvas.width;; (JSIdentifier) width						local.get $width						local.set $w;; (ExpressionStatement) h = display.context.canvas.height;; (AssignmentExpression) h = display.context.canvas.height;; (StaticMemberExpression) display.context.canvas.height;; (JSIdentifier) height						local.get $height						local.set $h)						(else;; (BlockStatement) w = h = 0 ;; (ExpressionStatement) w = h = 0;; (AssignmentExpression) w = h = 0;; (AssignmentExpression) h = 0;; (JSLiteral) 0						i32.const 0						local.set $h						local.set $w));; (ExpressionStatement) display.width = w;; (AssignmentExpression) display.width = w;; (JSIdentifier) w						local.get $w						local.set $width;; (ExpressionStatement) display.height = h;; (AssignmentExpression) display.height = h;; (JSIdentifier) h						local.get $h						local.set $height;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makePointWithXandY(w, h)						local.get $this;; (JSIdentifier) w						local.get $w;; (JSIdentifier) h						local.get $h						call $makePointWithXandY						call $popNandPushIfOK						return);; (JSProperty) property: primitiveSetFullScreen -> func...;; (FunctionExpression) function(argCount) { 	var flag = this.st...(func $primitiveSetFullScreen						(local $unfreeze i32)						(local $temp i32)						(local $argCount i32)						(local $flag i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (this.display.fullscreen != flag) {if...;; (BinaryExpression) this.display.fullscreen != flag;; (StaticMemberExpression) this.display.fullscreen;; (JSIdentifier) fullscreen						local.get $fullscreen;; (JSIdentifier) flag						local.get $flag						i32.ne						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (this.display.fullscreenRequest) {var...;; (IfStatement) if (this.display.fullscreenRequest) {var...;; (StaticMemberExpression) this.display.fullscreenRequest;; (JSIdentifier) fullscreenRequest						local.get $fullscreenRequest						i32.const 0						i32.ne						(if (then;; (BlockStatement) var unfreeze = this.vm.freeze() this.dis...;; (VariableDeclaration) var unfreeze = this.vm.freeze();; (VariableDeclarator) unfreeze = this.vm.freeze();; (CallExpression) this.vm.freeze()						local.get $vm						call $freeze						local.set $unfreeze;; (ExpressionStatement) this.display.fullscreenRequest(flag, fun...;; (CallExpression) this.display.fullscreenRequest(flag, fun...						local.get $display;; (JSIdentifier) flag						local.get $flag;; (FunctionExpression) function() { 	unfreeze() }(func $thenDo						(local $temp i32)						;; (ExpressionStatement) unfreeze();; (CallExpression) unfreeze()						call $unfreeze)						call $fullscreenRequest)						(else;; (BlockStatement) this.display.fullscreen = flag this.vm.b...;; (ExpressionStatement) this.display.fullscreen = flag;; (AssignmentExpression) this.display.fullscreen = flag;; (JSIdentifier) flag						local.get $flag						local.set $fullscreen;; (ExpressionStatement) this.vm.breakOut();; (CallExpression) this.vm.breakOut()						local.get $vm						call $breakOut))));; (ExpressionStatement) this.vm.popN(argCount);; (CallExpression) this.vm.popN(argCount)						local.get $vm;; (JSIdentifier) argCount						local.get $argCount						call $popN;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveTestDisplayDepth -> f...;; (FunctionExpression) function(argCount) { 	var supportedDepth...(func $primitiveTestDisplayDepth						(local $supportedDepths i32)						(local $argCount i32)						(local $temp i32)						;; (ReturnStatement) return this.pop2andPushBoolIfOK(supporte...;; (CallExpression) this.pop2andPushBoolIfOK(supportedDepths...						local.get $this;; (BinaryExpression) supportedDepths.indexOf(this.stackIntege...;; (CallExpression) supportedDepths.indexOf(this.stackIntege...						local.get $supportedDepths;; (CallExpression) this.stackInteger(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackInteger						call $indexOf;; (JSLiteral) 0						i32.const 0						i32.ge_u						call $pop2andPushBoolIfOK						return);; (JSProperty) property: loadForm -> function(formObj, ...;; (FunctionExpression) function(formObj, withOffset) { 	if (for...(func $loadForm						(local $temp i32)						(local $formObj i32)						(local $form i32)						(local $withOffset i32)						(local $offset i32)						;; (IfStatement) if (formObj.isNil) {return nil};; (StaticMemberExpression) formObj.isNil;; (JSIdentifier) isNil						local.get $isNil						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return));; (IfStatement) if (withOffset) {var offset = formObj.po...;; (JSIdentifier) withOffset						local.get $withOffset						i32.const 0						i32.ne						(if (then;; (BlockStatement) var offset = formObj.pointers[Squeak.For...;; (VariableDeclaration) var offset = formObj.pointers[Squeak.For...;; (VariableDeclarator) offset = formObj.pointers[Squeak.Form_of...;; (ComputedMemberExpression) formObj.pointers[Squeak.Form_offset];; (StaticMemberExpression) formObj.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Form_offset;; (JSIdentifier) Form_offset						local.get $Form_offset						i32.const 4						i32.mul						i32.add						local.set $offset;; (ExpressionStatement) form.offsetX = offset.pointers ? offset....;; (AssignmentExpression) form.offsetX = offset.pointers ? offset....;; (ConditionalExpression) offset.pointers ? offset.pointers[Squeak...;; (StaticMemberExpression) offset.pointers;; (JSIdentifier) pointers						local.get $pointers						i32.const 1						i32.eq						(if (then;; (ComputedMemberExpression) offset.pointers[Squeak.Point_x];; (StaticMemberExpression) offset.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Point_x;; (JSIdentifier) Point_x						local.get $Point_x						i32.const 4						i32.mul						i32.add)						(else;; (JSLiteral) 0						i32.const 0						))						local.set $offsetX;; (ExpressionStatement) form.offsetY = offset.pointers ? offset....;; (AssignmentExpression) form.offsetY = offset.pointers ? offset....;; (ConditionalExpression) offset.pointers ? offset.pointers[Squeak...;; (StaticMemberExpression) offset.pointers;; (JSIdentifier) pointers						local.get $pointers						i32.const 1						i32.eq						(if (then;; (ComputedMemberExpression) offset.pointers[Squeak.Point_y];; (StaticMemberExpression) offset.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Point_y;; (JSIdentifier) Point_y						local.get $Point_y						i32.const 4						i32.mul						i32.add)						(else;; (JSLiteral) 0						i32.const 0						))						local.set $offsetY));; (IfStatement) if (form.width === 0 || form.height === ...;; (BinaryExpression) form.width === 0 || form.height === 0;; (BinaryExpression) form.width === 0;; (StaticMemberExpression) form.width;; (JSIdentifier) width						local.get $width;; (JSLiteral) 0						i32.const 0						i32.eq;; (BinaryExpression) form.height === 0;; (StaticMemberExpression) form.height;; (JSIdentifier) height						local.get $height;; (JSLiteral) 0						i32.const 0						i32.eq						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return form;; (JSIdentifier) form						local.get $form						return));; (IfStatement) if (!form.width > 0 && form.height > 0) ...;; (UnaryExpression) !form.width > 0 && form.height > 0;; (BinaryExpression) form.width > 0 && form.height > 0;; (BinaryExpression) form.width > 0;; (StaticMemberExpression) form.width;; (JSIdentifier) width						local.get $width;; (JSLiteral) 0						i32.const 0						i32.gt_u;; (BinaryExpression) form.height > 0;; (StaticMemberExpression) form.height;; (JSIdentifier) height						local.get $height;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.and						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return));; (ExpressionStatement) form.msb = form.depth > 0;; (AssignmentExpression) form.msb = form.depth > 0;; (BinaryExpression) form.depth > 0;; (StaticMemberExpression) form.depth;; (JSIdentifier) depth						local.get $depth;; (JSLiteral) 0						i32.const 0						i32.gt_u						local.set $msb;; (IfStatement) if (!form.msb) {form.depth = -form.depth...;; (UnaryExpression) !form.msb;; (StaticMemberExpression) form.msb;; (JSIdentifier) msb						local.get $msb						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) form.depth = -form.depth;; (AssignmentExpression) form.depth = -form.depth;; (UnaryExpression) -form.depth;; (StaticMemberExpression) form.depth;; (JSIdentifier) depth						local.get $depth						local.set $temp						i32.const 0						local.get $temp						i32.sub						local.set $depth));; (IfStatement) if (!form.depth > 0) {return nil};; (UnaryExpression) !form.depth > 0;; (BinaryExpression) form.depth > 0;; (StaticMemberExpression) form.depth;; (JSIdentifier) depth						local.get $depth;; (JSLiteral) 0						i32.const 0						i32.gt_u						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return));; (ExpressionStatement) form.pixPerWord = 32 / form.depth;; (AssignmentExpression) form.pixPerWord = 32 / form.depth;; (BinaryExpression) 32 / form.depth;; (JSLiteral) 32						i32.const 32;; (StaticMemberExpression) form.depth;; (JSIdentifier) depth						local.get $depth						i32.div_s						local.set $pixPerWord;; (ExpressionStatement) form.pitch = form.width + form.pixPerWor...;; (AssignmentExpression) form.pitch = form.width + form.pixPerWor...;; (BinaryExpression) form.width + form.pixPerWord - 1 / form....;; (BinaryExpression) form.width + form.pixPerWord - 1 / form....;; (BinaryExpression) form.width + form.pixPerWord - 1;; (StaticMemberExpression) form.width;; (JSIdentifier) width						local.get $width;; (BinaryExpression) form.pixPerWord - 1;; (StaticMemberExpression) form.pixPerWord;; (JSIdentifier) pixPerWord						local.get $pixPerWord;; (JSLiteral) 1						i32.const 1						i32.sub						i32.add;; (StaticMemberExpression) form.pixPerWord;; (JSIdentifier) pixPerWord						local.get $pixPerWord						i32.div_s;; (JSLiteral) 0						i32.const 0						i32.or						local.set $pitch;; (IfStatement) if (form.bits.length !== form.pitch * fo...;; (BinaryExpression) form.bits.length !== form.pitch * form.h...;; (StaticMemberExpression) form.bits.length;; (JSIdentifier) length						local.get $length;; (BinaryExpression) form.pitch * form.height;; (StaticMemberExpression) form.pitch;; (JSIdentifier) pitch						local.get $pitch;; (StaticMemberExpression) form.height;; (JSIdentifier) height						local.get $height						i32.mul						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return));; (ReturnStatement) return form;; (JSIdentifier) form						local.get $form						return);; (JSProperty) property: theDisplay -> function() { 	re...;; (FunctionExpression) function() { 	return this.loadForm(this....(func $theDisplay						(local $temp i32)						;; (ReturnStatement) return this.loadForm(this.vm.specialObje...;; (CallExpression) this.loadForm(this.vm.specialObjects[Squ...						local.get $this;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_TheD...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_TheDisplay;; (JSIdentifier) splOb_TheDisplay						local.get $splOb_TheDisplay						i32.const 4						i32.mul						i32.add						call $loadForm						return);; (JSProperty) property: displayDirty -> function(form,...;; (FunctionExpression) function(form, rect) { 	if (!this.deferD...(func $displayDirty						(local $form i32)						(local $rect i32)						(local $temp i32)						;; (IfStatement) if (!this.deferDisplayUpdates && form ==...;; (BinaryExpression) !this.deferDisplayUpdates && form == thi...;; (UnaryExpression) !this.deferDisplayUpdates;; (StaticMemberExpression) this.deferDisplayUpdates;; (JSIdentifier) deferDisplayUpdates						local.get $deferDisplayUpdates						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (BinaryExpression) form == this.vm.specialObjects[Squeak.sp...;; (JSIdentifier) form						local.get $form;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_TheD...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_TheDisplay;; (JSIdentifier) splOb_TheDisplay						local.get $splOb_TheDisplay						i32.const 4						i32.mul						i32.add						i32.eq						i32.and						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.displayUpdate(this.theDisplay(), re...;; (CallExpression) this.displayUpdate(this.theDisplay(), re...						local.get $this;; (CallExpression) this.theDisplay()						local.get $this						call $theDisplay;; (JSIdentifier) rect						local.get $rect						call $displayUpdate)));; (JSProperty) property: displayUpdate -> function(form...;; (FunctionExpression) function(form, rect) { 	this.showForm(th...(func $displayUpdate						(local $form i32)						(local $rect i32)						(local $temp i32)						;; (ExpressionStatement) this.showForm(this.display.context, form...;; (CallExpression) this.showForm(this.display.context, form...						local.get $this;; (StaticMemberExpression) this.display.context;; (JSIdentifier) context						local.get $context;; (JSIdentifier) form						local.get $form;; (JSIdentifier) rect						local.get $rect						call $showForm;; (ExpressionStatement) this.display.lastTick = this.vm.lastTick;; (AssignmentExpression) this.display.lastTick = this.vm.lastTick;; (StaticMemberExpression) this.vm.lastTick;; (JSIdentifier) lastTick						local.get $lastTick						local.set $lastTick;; (ExpressionStatement) this.display.idle = 0;; (AssignmentExpression) this.display.idle = 0;; (JSLiteral) 0						i32.const 0						local.set $idle);; (JSProperty) property: primitiveBeep -> function(argC...;; (FunctionExpression) function(argCount) { 	var ctx = Squeak.s...(func $primitiveBeep						(local $ctx i32)						(local $temp i32)						(local $argCount i32)						(local $beep i32)												;; unwritable: (IfStatement) if (ctx) {var beep = ctx.createOscillato;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: primitiveClipboardText -> func...;; (FunctionExpression) function(argCount) { 	if (argCount === 0...(func $primitiveClipboardText						(local $temp i32)						(local $argCount i32)						(local $stringObj i32)												;; unwritable: (IfStatement) if (argCount === 0) {if (typeof this.dis;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveKeyboardNext -> funct...;; (FunctionExpression) function(argCount) { 	var next if (this....(func $primitiveKeyboardNext						(local $next i32)						(local $argCount i32)						(local $temp i32)						;; (IfStatement) if (this.display.keys) {next = this.disp...;; (StaticMemberExpression) this.display.keys;; (JSIdentifier) keys						local.get $keys						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) next = this.display.keys.shift();; (AssignmentExpression) next = this.display.keys.shift();; (CallExpression) this.display.keys.shift()						local.get $display.keys						call $shift						local.set $next)						(else;; (ExpressionStatement) next = 0;; (AssignmentExpression) next = 0;; (JSLiteral) 0						i32.const 0						local.set $next));; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.ensureSmallInt(next)						local.get $this;; (JSIdentifier) next						local.get $next						call $ensureSmallInt						call $popNandPushIfOK						return);; (JSProperty) property: primitiveKeyboardPeek -> funct...;; (FunctionExpression) function(argCount) { 	var length = this....(func $primitiveKeyboardPeek						(local $temp i32)						(local $argCount i32)						(local $length i32)						;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, lengt...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (ConditionalExpression) length ? this.ensureSmallInt(this.displa...;; (JSIdentifier) length						local.get $length						i32.const 1						i32.eq						(if (then;; (CallExpression) this.ensureSmallInt(this.display.keys[0]...						local.get $this;; (BinaryExpression) this.display.keys[0] || 0;; (ComputedMemberExpression) this.display.keys[0];; (StaticMemberExpression) this.display.keys;; (JSIdentifier) keys						local.get $keys;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add;; (JSLiteral) 0						i32.const 0						i32.or						call $ensureSmallInt)						(else;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						))						call $popNandPushIfOK						return);; (JSProperty) property: primitiveMouseButtons -> funct...;; (FunctionExpression) function(argCount) { 	this.popNandPushIf...(func $primitiveMouseButtons						(local $argCount i32)						(local $temp i32)						;; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, this....;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.ensureSmallInt(this.display.buttons...						local.get $this;; (StaticMemberExpression) this.display.buttons;; (JSIdentifier) buttons						local.get $buttons						call $ensureSmallInt						call $popNandPushIfOK;; (ExpressionStatement) this.vm.breakOut();; (CallExpression) this.vm.breakOut()						local.get $vm						call $breakOut;; (IfStatement) if (this.display.idle++ > 20) {this.vm.g...;; (BinaryExpression) this.display.idle++ > 20;; (UpdateExpression) this.display.idle++;; (StaticMemberExpression) this.display.idle;; (JSIdentifier) idle						local.get $idle						i32.const 1						i32.add;; (JSLiteral) 20						i32.const 20						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.vm.goIdle();; (CallExpression) this.vm.goIdle()						local.get $vm						call $goIdle));; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveMousePoint -> functio...;; (FunctionExpression) function(argCount) { 	var x = this.ensur...(func $primitiveMousePoint						(local $x i32)						(local $temp i32)						(local $y i32)						(local $argCount i32)						;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makePointWithXandY(x, y)						local.get $this;; (JSIdentifier) x						local.get $x;; (JSIdentifier) y						local.get $y						call $makePointWithXandY						call $popNandPushIfOK						return);; (JSProperty) property: primitiveInputSemaphore -> fun...;; (FunctionExpression) function(argCount) { 	var semaIndex = th...(func $primitiveInputSemaphore						(local $temp i32)						(local $argCount i32)						(local $semaIndex i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.inputEventSemaIndex = semaIndex;; (AssignmentExpression) this.inputEventSemaIndex = semaIndex;; (JSIdentifier) semaIndex						local.get $semaIndex						local.set $inputEventSemaIndex						;; unwritable: (ExpressionStatement) self.interpreter = this						;; unwritable: (ExpressionStatement) this.display.signalInputEvent = function;; (ExpressionStatement) this.display.signalInputEvent();; (CallExpression) this.display.signalInputEvent()						local.get $display						call $signalInputEvent;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveInputWord -> function...;; (FunctionExpression) function(argCount) { 	return this.popNan...(func $primitiveInputWord						(local $argCount i32)						(local $temp i32)						;; (ReturnStatement) return this.popNandPushIfOK(1, 0);; (CallExpression) this.popNandPushIfOK(1, 0)						local.get $this;; (JSLiteral) 1						i32.const 1;; (JSLiteral) 0						i32.const 0						call $popNandPushIfOK						return);; (JSProperty) property: primitiveGetNextEvent -> funct...;; (FunctionExpression) function(argCount) { 	this.display.idle+...(func $primitiveGetNextEvent						(local $temp i32)						(local $argCount i32)						(local $evtBuf i32)						;; (ExpressionStatement) this.display.idle++;; (UpdateExpression) this.display.idle++;; (StaticMemberExpression) this.display.idle;; (JSIdentifier) idle						local.get $idle						i32.const 1						i32.add;; (IfStatement) if (!this.display.getNextEvent) {return ...;; (UnaryExpression) !this.display.getNextEvent;; (StaticMemberExpression) this.display.getNextEvent;; (JSIdentifier) getNextEvent						local.get $getNextEvent						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.display.getNextEvent(evtBuf.pointer...;; (CallExpression) this.display.getNextEvent(evtBuf.pointer...						local.get $display;; (StaticMemberExpression) evtBuf.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) this.vm.startupTime;; (JSIdentifier) startupTime						local.get $startupTime						call $getNextEvent;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveRelinquishProcessorFo...;; (FunctionExpression) function(argCount) { 	this.vm.pop(argCou...(func $primitiveRelinquishProcessorForMicroseconds						(local $argCount i32)						(local $temp i32)						;; (ExpressionStatement) this.vm.pop(argCount);; (CallExpression) this.vm.pop(argCount)						local.get $vm;; (JSIdentifier) argCount						local.get $argCount						call $pop;; (ExpressionStatement) this.vm.goIdle();; (CallExpression) this.vm.goIdle()						local.get $vm						call $goIdle;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: millisecondClockValue -> funct...;; (FunctionExpression) function() { 	return Date.now() - this.v...(func $millisecondClockValue						(local $temp i32)												;; unwritable: (ReturnStatement) return Date.now() - this.vm.startupTime );; (JSProperty) property: millisecondClockValueSet -> fu...;; (FunctionExpression) function(clock) { 	this.vm.startupTime =...(func $millisecondClockValueSet						(local $clock i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.vm.startupTime = Date.now() - clock);; (JSProperty) property: secondClock -> function() { 	r...;; (FunctionExpression) function() { 	return this.pos32BitIntFor...(func $secondClock						(local $temp i32)												;; unwritable: (ReturnStatement) return this.pos32BitIntFor(Squeak.totalS);; (JSProperty) property: microsecondClock -> function(s...;; (FunctionExpression) function(state) { 	var millis = Date.now...(func $microsecondClock						(local $micros i32)						(local $oldMicros i32)						(local $temp i32)						(local $state i32)						(local $oldMillis i32)						(local $millis i32)												;; unwritable: (IfStatement) if (typeof performance !== 'object') {re;; (IfStatement) if (oldMillis > millis) {millis = oldMil...;; (BinaryExpression) oldMillis > millis;; (JSIdentifier) oldMillis						local.get $oldMillis;; (JSIdentifier) millis						local.get $millis						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) millis = oldMillis;; (AssignmentExpression) millis = oldMillis;; (JSIdentifier) oldMillis						local.get $oldMillis						local.set $millis));; (IfStatement) if (millis === oldMillis && micros < old...;; (BinaryExpression) millis === oldMillis && micros < oldMicr...;; (BinaryExpression) millis === oldMillis;; (JSIdentifier) millis						local.get $millis;; (JSIdentifier) oldMillis						local.get $oldMillis						i32.eq;; (BinaryExpression) micros < oldMicros;; (JSIdentifier) micros						local.get $micros;; (JSIdentifier) oldMicros						local.get $oldMicros						i32.lt_u						i32.and						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) millis++;; (UpdateExpression) millis++;; (JSIdentifier) millis						local.get $millis						i32.const 1						i32.add));; (ExpressionStatement) state.millis = millis;; (AssignmentExpression) state.millis = millis;; (JSIdentifier) millis						local.get $millis						local.set $millis;; (ExpressionStatement) state.micros = micros;; (AssignmentExpression) state.micros = micros;; (JSIdentifier) micros						local.get $micros						local.set $micros;; (ReturnStatement) return this.pos53BitIntFor(millis * 1000...;; (CallExpression) this.pos53BitIntFor(millis * 1000 + micr...						local.get $this;; (BinaryExpression) millis * 1000 + micros;; (BinaryExpression) millis * 1000;; (JSIdentifier) millis						local.get $millis;; (JSLiteral) 1000						i32.const 1000						i32.mul;; (JSIdentifier) micros						local.get $micros						i32.add						call $pos53BitIntFor						return);; (JSProperty) property: microsecondClockUTC -> functio...;; (FunctionExpression) function() { 	if (!this.microsecondClock...(func $microsecondClockUTC						(local $temp i32)						;; (IfStatement) if (!this.microsecondClockUTCState) {thi...;; (UnaryExpression) !this.microsecondClockUTCState;; (StaticMemberExpression) this.microsecondClockUTCState;; (JSIdentifier) microsecondClockUTCState						local.get $microsecondClockUTCState						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.microsecondClockUTCState = {propert...;; (AssignmentExpression) this.microsecondClockUTCState = {propert...;; (ObjectExpression) {property: epoch -> Squeak.EpochUTC, pro...						local.set $microsecondClockUTCState));; (ReturnStatement) return this.microsecondClock(this.micros...;; (CallExpression) this.microsecondClock(this.microsecondCl...						local.get $this;; (StaticMemberExpression) this.microsecondClockUTCState;; (JSIdentifier) microsecondClockUTCState						local.get $microsecondClockUTCState						call $microsecondClock						return);; (JSProperty) property: microsecondClockLocal -> funct...;; (FunctionExpression) function() { 	if (!this.microsecondClock...(func $microsecondClockLocal						(local $temp i32)						;; (IfStatement) if (!this.microsecondClockLocalState) {t...;; (UnaryExpression) !this.microsecondClockLocalState;; (StaticMemberExpression) this.microsecondClockLocalState;; (JSIdentifier) microsecondClockLocalState						local.get $microsecondClockLocalState						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.microsecondClockLocalState = {prope...;; (AssignmentExpression) this.microsecondClockLocalState = {prope...;; (ObjectExpression) {property: epoch -> Squeak.Epoch, proper...						local.set $microsecondClockLocalState));; (ReturnStatement) return this.microsecondClock(this.micros...;; (CallExpression) this.microsecondClock(this.microsecondCl...						local.get $this;; (StaticMemberExpression) this.microsecondClockLocalState;; (JSIdentifier) microsecondClockLocalState						local.get $microsecondClockLocalState						call $microsecondClock						return);; (JSProperty) property: primitiveUtcWithOffset -> func...;; (FunctionExpression) function(argCount) { 	var d = new Date()...(func $primitiveUtcWithOffset						(local $d i32)						(local $posixMicroseconds i32)						(local $timeAndOffset i32)						(local $argCount i32)						(local $stWordIndexableObject i32)						(local $temp i32)						(local $offset i32)						;; (IfStatement) if (argCount > 0) {var stWordIndexableOb...;; (BinaryExpression) argCount > 0;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) var stWordIndexableObject = this.vm.stac...;; (VariableDeclaration) var stWordIndexableObject = this.vm.stac...;; (VariableDeclarator) stWordIndexableObject = this.vm.stackVal...;; (CallExpression) this.vm.stackValue(0)						local.get $vm;; (JSLiteral) 0						i32.const 0						call $stackValue						local.set $stWordIndexableObject;; (ExpressionStatement) stWordIndexableObject.pointers[0] = posi...;; (AssignmentExpression) stWordIndexableObject.pointers[0] = posi...						local.get $stWordIndexableObject;; (JSLiteral) 0						i32.const 0;; (JSIdentifier) posixMicroseconds						local.get $posixMicroseconds						call $atPut;; (ExpressionStatement) stWordIndexableObject.pointers[1] = offs...;; (AssignmentExpression) stWordIndexableObject.pointers[1] = offs...						local.get $stWordIndexableObject;; (JSLiteral) 1						i32.const 1;; (JSIdentifier) offset						local.get $offset						call $atPut;; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, stWor...;; (CallExpression) this.popNandPushIfOK(argCount + 1, stWor...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) stWordIndexableObject						local.get $stWordIndexableObject						call $popNandPushIfOK;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return));; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, this....;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeStArray(timeAndOffset)						local.get $this;; (JSIdentifier) timeAndOffset						local.get $timeAndOffset						call $makeStArray						call $popNandPushIfOK;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveDirectoryCreate -> fu...;; (FunctionExpression) function(argCount) { 	var dirNameObj = t...(func $primitiveDirectoryCreate						(local $path i32)						(local $dirNameObj i32)						(local $argCount i32)						(local $dirName i32)						(local $temp i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (ExpressionStatement) this.success = Squeak.dirCreate(dirName)						;; unwritable: (IfStatement) if (!this.success) {var path = Squeak.sp;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: primitiveDirectoryDelete -> fu...;; (FunctionExpression) function(argCount) { 	var dirNameObj = t...(func $primitiveDirectoryDelete						(local $temp i32)						(local $dirNameObj i32)						(local $argCount i32)						(local $dirName i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (ExpressionStatement) this.success = Squeak.dirDelete(dirName);; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: primitiveDirectoryDelimitor ->...;; (FunctionExpression) function(argCount) { 	var delimitor = th...(func $primitiveDirectoryDelimitor						(local $delimitor i32)						(local $argCount i32)						(local $temp i32)						;; (ReturnStatement) return this.popNandPushIfOK(1, this.char...;; (CallExpression) this.popNandPushIfOK(1, this.charFromInt...						local.get $this;; (JSLiteral) 1						i32.const 1;; (CallExpression) this.charFromInt(delimitor.charCodeAt(0)...						local.get $this;; (CallExpression) delimitor.charCodeAt(0)						local.get $delimitor;; (JSLiteral) 0						i32.const 0						call $charCodeAt						call $charFromInt						call $popNandPushIfOK						return);; (JSProperty) property: primitiveDirectoryEntry -> fun...;; (FunctionExpression) function(argCount) { 	var dirNameObj = t...(func $primitiveDirectoryEntry						(local $temp i32)						(local $sqDirName i32)						(local $dirName i32)						(local $path i32)						(local $fileName i32)						(local $entries i32)						(local $argCount i32)						(local $dirNameObj i32)						(local $sqFileName i32)						(local $entry i32)						(local $fileNameObj i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (IfStatement) if (!entries) {var path = Squeak.splitFi;; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, this....;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeStObject(entry)						local.get $this;; (JSIdentifier) entry						local.get $entry						call $makeStObject						call $popNandPushIfOK;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveDirectoryLookup -> fu...;; (FunctionExpression) function(argCount) { 	var index = this.s...(func $primitiveDirectoryLookup						(local $temp i32)						(local $sqDirName i32)						(local $dirName i32)						(local $path i32)						(local $index i32)						(local $entries i32)						(local $keys i32)						(local $argCount i32)						(local $dirNameObj i32)						(local $entry i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (IfStatement) if (!entries) {var path = Squeak.splitFi						;; unwritable: (IfStatement) if (sqDirName === '/') {if (index === 1);; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, this....;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeStObject(entry)						local.get $this;; (JSIdentifier) entry						local.get $entry						call $makeStObject						call $popNandPushIfOK;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveDirectorySetMacTypeAn...;; (FunctionExpression) function(argCount) { 	return this.popNIf...(func $primitiveDirectorySetMacTypeAndCreator						(local $argCount i32)						(local $temp i32)						;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: primitiveFileAtEnd -> function...;; (FunctionExpression) function(argCount) { 	var handle = this....(func $primitiveFileAtEnd						(local $handle i32)						(local $argCount i32)						(local $temp i32)						;; (IfStatement) if (!this.success || !handle.file) {retu...;; (BinaryExpression) !this.success || !handle.file;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !handle.file;; (StaticMemberExpression) handle.file;; (JSIdentifier) file						local.get $file						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, this....;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeStObject(handle.filePos >= hand...						local.get $this;; (BinaryExpression) handle.filePos >= handle.file.size;; (StaticMemberExpression) handle.filePos;; (JSIdentifier) filePos						local.get $filePos;; (StaticMemberExpression) handle.file.size;; (JSIdentifier) size						local.get $size						i32.ge_u						call $makeStObject						call $popNandPushIfOK;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveFileClose -> function...;; (FunctionExpression) function(argCount) { 	var handle = this....(func $primitiveFileClose						(local $handle i32)						(local $argCount i32)						(local $temp i32)						;; (IfStatement) if (!this.success || !handle.file) {retu...;; (BinaryExpression) !this.success || !handle.file;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !handle.file;; (StaticMemberExpression) handle.file;; (JSIdentifier) file						local.get $file						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (IfStatement) if (typeof handle.file === 'string') {th;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: primitiveFileDelete -> functio...;; (FunctionExpression) function(argCount) { 	var fileNameObj = ...(func $primitiveFileDelete						(local $temp i32)						(local $argCount i32)						(local $fileName i32)						(local $fileNameObj i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (ExpressionStatement) this.success = Squeak.fileDelete(fileNam;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: primitiveFileFlush -> function...;; (FunctionExpression) function(argCount) { 	var handle = this....(func $primitiveFileFlush						(local $handle i32)						(local $argCount i32)						(local $temp i32)						;; (IfStatement) if (!this.success || !handle.file) {retu...;; (BinaryExpression) !this.success || !handle.file;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !handle.file;; (StaticMemberExpression) handle.file;; (JSIdentifier) file						local.get $file						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (IfStatement) if (typeof handle.file === 'string') {th;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: primitiveFileGetPosition -> fu...;; (FunctionExpression) function(argCount) { 	var handle = this....(func $primitiveFileGetPosition						(local $handle i32)						(local $argCount i32)						(local $temp i32)						;; (IfStatement) if (!this.success || !handle.file) {retu...;; (BinaryExpression) !this.success || !handle.file;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !handle.file;; (StaticMemberExpression) handle.file;; (JSIdentifier) file						local.get $file						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, this....;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeLargeIfNeeded(handle.filePos)						local.get $this;; (StaticMemberExpression) handle.filePos;; (JSIdentifier) filePos						local.get $filePos						call $makeLargeIfNeeded						call $popNandPushIfOK;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: makeFileHandle -> function(fil...;; (FunctionExpression) function(filename, file, writeFlag) { 	v...(func $makeFileHandle						(local $handle i32)						(local $filename i32)						(local $writeFlag i32)						(local $temp i32)						(local $file i32)						;; (ExpressionStatement) handle.file = file;; (AssignmentExpression) handle.file = file;; (JSIdentifier) file						local.get $file						local.set $file;; (ExpressionStatement) handle.fileWrite = writeFlag;; (AssignmentExpression) handle.fileWrite = writeFlag;; (JSIdentifier) writeFlag						local.get $writeFlag						local.set $fileWrite;; (ExpressionStatement) handle.filePos = 0;; (AssignmentExpression) handle.filePos = 0;; (JSLiteral) 0						i32.const 0						local.set $filePos;; (ReturnStatement) return handle;; (JSIdentifier) handle						local.get $handle						return);; (JSProperty) property: primitiveFileOpen -> function(...;; (FunctionExpression) function(argCount) { 	var writeFlag = th...(func $primitiveFileOpen						(local $handle i32)						(local $temp i32)						(local $writeFlag i32)						(local $argCount i32)						(local $fileName i32)						(local $fileNameObj i32)						(local $file i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!file) {return false};; (UnaryExpression) !file;; (JSIdentifier) file						local.get $file						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, handl...;; (CallExpression) this.popNandPushIfOK(argCount + 1, handl...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) handle						local.get $handle						call $popNandPushIfOK;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveFileRead -> function(...;; (FunctionExpression) function(argCount) { 	var count = this.s...(func $primitiveFileRead						(local $handle i32)						(local $startIndex i32)						(local $count i32)						(local $argCount i32)						(local $temp i32)						(local $arrayObj i32)						;; (IfStatement) if (!this.success || !handle.file) {retu...;; (BinaryExpression) !this.success || !handle.file;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !handle.file;; (StaticMemberExpression) handle.file;; (JSIdentifier) file						local.get $file						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!count) {return this.popNandPushIfOK...;; (UnaryExpression) !count;; (JSIdentifier) count						local.get $count						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, 0)						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSLiteral) 0						i32.const 0						call $popNandPushIfOK						return))						;; unwritable: (IfStatement) if (!arrayObj.bytes) {console.log('File ;; (IfStatement) if (startIndex < 0 || startIndex + count...;; (BinaryExpression) startIndex < 0 || startIndex + count > a...;; (BinaryExpression) startIndex < 0;; (JSIdentifier) startIndex						local.get $startIndex;; (JSLiteral) 0						i32.const 0						i32.lt_u;; (BinaryExpression) startIndex + count > arrayObj.bytes.leng...;; (BinaryExpression) startIndex + count;; (JSIdentifier) startIndex						local.get $startIndex;; (JSIdentifier) count						local.get $count						i32.add;; (StaticMemberExpression) arrayObj.bytes.length;; (JSIdentifier) length						local.get $length						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (IfStatement) if (typeof handle.file === 'string') {th						;; unwritable: (ReturnStatement) return this.fileContentsDo(handle.file, );; (JSProperty) property: primitiveFileRename -> functio...;; (FunctionExpression) function(argCount) { 	var oldNameObj = t...(func $primitiveFileRename						(local $oldName i32)						(local $argCount i32)						(local $newName i32)						(local $newNameObj i32)						(local $oldNameObj i32)						(local $temp i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (ExpressionStatement) this.success = Squeak.fileRename(oldName;; (ExpressionStatement) this.vm.breakOut();; (CallExpression) this.vm.breakOut()						local.get $vm						call $breakOut;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: primitiveFileSetPosition -> fu...;; (FunctionExpression) function(argCount) { 	var pos = this.sta...(func $primitiveFileSetPosition						(local $handle i32)						(local $argCount i32)						(local $temp i32)						(local $pos i32)						;; (IfStatement) if (!this.success || !handle.file) {retu...;; (BinaryExpression) !this.success || !handle.file;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !handle.file;; (StaticMemberExpression) handle.file;; (JSIdentifier) file						local.get $file						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) handle.filePos = pos;; (AssignmentExpression) handle.filePos = pos;; (JSIdentifier) pos						local.get $pos						local.set $filePos;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: primitiveFileSize -> function(...;; (FunctionExpression) function(argCount) { 	var handle = this....(func $primitiveFileSize						(local $handle i32)						(local $argCount i32)						(local $temp i32)						;; (IfStatement) if (!this.success || !handle.file) {retu...;; (BinaryExpression) !this.success || !handle.file;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !handle.file;; (StaticMemberExpression) handle.file;; (JSIdentifier) file						local.get $file						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, this....;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeLargeIfNeeded(handle.file.size)						local.get $this;; (StaticMemberExpression) handle.file.size;; (JSIdentifier) size						local.get $size						call $makeLargeIfNeeded						call $popNandPushIfOK;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveFileStdioHandles -> f...;; (FunctionExpression) function(argCount) { 	var handles = [nil...(func $primitiveFileStdioHandles						(local $handles i32)						(local $argCount i32)						(local $temp i32)						;; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, this....;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeStArray(handles)						local.get $this;; (JSIdentifier) handles						local.get $handles						call $makeStArray						call $popNandPushIfOK;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveFileTruncate -> funct...;; (FunctionExpression) function(argCount) { 	var pos = this.sta...(func $primitiveFileTruncate						(local $handle i32)						(local $argCount i32)						(local $temp i32)						(local $pos i32)						;; (IfStatement) if (!this.success || !handle.file || !ha...;; (BinaryExpression) !this.success || !handle.file || !handle...;; (BinaryExpression) !this.success || !handle.file;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !handle.file;; (StaticMemberExpression) handle.file;; (JSIdentifier) file						local.get $file						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or;; (UnaryExpression) !handle.fileWrite;; (StaticMemberExpression) handle.fileWrite;; (JSIdentifier) fileWrite						local.get $fileWrite						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (handle.file.size > pos) {handle.file...;; (BinaryExpression) handle.file.size > pos;; (StaticMemberExpression) handle.file.size;; (JSIdentifier) size						local.get $size;; (JSIdentifier) pos						local.get $pos						i32.gt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) handle.file.size = pos handle.file.modif...;; (ExpressionStatement) handle.file.size = pos;; (AssignmentExpression) handle.file.size = pos;; (JSIdentifier) pos						local.get $pos						local.set $size;; (ExpressionStatement) handle.file.modified = true;; (AssignmentExpression) handle.file.modified = true;; (JSLiteral) true						i32.const 1						local.set $modified;; (IfStatement) if (handle.filePos > handle.file.size) {...;; (BinaryExpression) handle.filePos > handle.file.size;; (StaticMemberExpression) handle.filePos;; (JSIdentifier) filePos						local.get $filePos;; (StaticMemberExpression) handle.file.size;; (JSIdentifier) size						local.get $size						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) handle.filePos = handle.file.size;; (AssignmentExpression) handle.filePos = handle.file.size;; (StaticMemberExpression) handle.file.size;; (JSIdentifier) size						local.get $size						local.set $filePos))));; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: primitiveDisableFileAccess -> ...;; (FunctionExpression) function(argCount) { 	return this.fakePr...(func $primitiveDisableFileAccess						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.fakePrimitive('FilePlugin.pr);; (JSProperty) property: primitiveFileWrite -> function...;; (FunctionExpression) function(argCount) { 	var count = this.s...(func $primitiveFileWrite						(local $handle i32)						(local $array i32)						(local $startIndex i32)						(local $count i32)						(local $argCount i32)						(local $temp i32)						(local $arrayObj i32)						;; (IfStatement) if (!this.success || !handle.file || !ha...;; (BinaryExpression) !this.success || !handle.file || !handle...;; (BinaryExpression) !this.success || !handle.file;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !handle.file;; (StaticMemberExpression) handle.file;; (JSIdentifier) file						local.get $file						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or;; (UnaryExpression) !handle.fileWrite;; (StaticMemberExpression) handle.fileWrite;; (JSIdentifier) fileWrite						local.get $fileWrite						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!count) {return this.popNandPushIfOK...;; (UnaryExpression) !count;; (JSIdentifier) count						local.get $count						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, 0)						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSLiteral) 0						i32.const 0						call $popNandPushIfOK						return));; (IfStatement) if (!array) {return false};; (UnaryExpression) !array;; (JSIdentifier) array						local.get $array						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (startIndex < 0 || startIndex + count...;; (BinaryExpression) startIndex < 0 || startIndex + count > a...;; (BinaryExpression) startIndex < 0;; (JSIdentifier) startIndex						local.get $startIndex;; (JSLiteral) 0						i32.const 0						i32.lt_u;; (BinaryExpression) startIndex + count > array.length;; (BinaryExpression) startIndex + count;; (JSIdentifier) startIndex						local.get $startIndex;; (JSIdentifier) count						local.get $count						i32.add;; (StaticMemberExpression) array.length;; (JSIdentifier) length						local.get $length						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (IfStatement) if (typeof handle.file === 'string') {th						;; unwritable: (ReturnStatement) return this.fileContentsDo(handle.file, );; (JSProperty) property: fileOpen -> function(filename,...;; (FunctionExpression) function(filename, writeFlag) { 	if (typ...(func $fileOpen						(local $file i32)						(local $temp i32)						(local $filename i32)						(local $writeFlag i32)						(local $path i32)						(local $directory i32)						(local $entry i32)						(local $contents i32)												;; unwritable: (IfStatement) if (typeof SqueakFiles == 'undefined') {;; (IfStatement) if (!path.basename) {return nil};; (UnaryExpression) !path.basename;; (StaticMemberExpression) path.basename;; (JSIdentifier) basename						local.get $basename						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return));; (IfStatement) if (!directory) {return nil};; (UnaryExpression) !directory;; (JSIdentifier) directory						local.get $directory						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return))						;; unwritable: (IfStatement) if (entry) {var file = SqueakFiles[path.;; (ExpressionStatement) SqueakFiles[file.name] = file;; (AssignmentExpression) SqueakFiles[file.name] = file						local.get $'SqueakFiles';; (StaticMemberExpression) file.name;; (JSIdentifier) name						local.get $name;; (JSIdentifier) file						local.get $file						call $atPut;; (ReturnStatement) return file;; (JSIdentifier) file						local.get $file						return);; (JSProperty) property: fileClose -> function(file) { ...;; (FunctionExpression) function(file) { 	Squeak.flushFile(file)...(func $fileClose						(local $temp i32)						(local $file i32)												;; unwritable: (ExpressionStatement) Squeak.flushFile(file)						;; unwritable: (IfStatement) if (--file.refCount == 0) {delete Squeak);; (JSProperty) property: fileContentsDo -> function(fil...;; (FunctionExpression) function(file, func) { 	if (file.content...(func $fileContentsDo						(local $temp i32)						(local $func i32)						(local $file i32)												;; unwritable: (IfStatement) if (file.contents) {func(file) } else {i;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: fileConsoleBuffer -> {property...;; (JSProperty) property: fileConsoleWrite -> function(l...;; (FunctionExpression) function(logOrError, array, startIndex, ...(func $fileConsoleWrite						(local $logOrError i32)						(local $array i32)						(local $startIndex i32)						(local $count i32)						(local $bytes i32)						(local $buffer i32)						(local $lines i32)						(local $temp i32)												;; unwritable: (IfStatement) if (lines) {console[logOrError](lines[1];; (ExpressionStatement) this.fileConsoleBuffer[logOrError] = buf...;; (AssignmentExpression) this.fileConsoleBuffer[logOrError] = buf...						local.get $this;; (JSIdentifier) logOrError						local.get $logOrError;; (JSIdentifier) buffer						local.get $buffer						call $atPut);; (JSProperty) property: fileConsoleFlush -> function(l...;; (FunctionExpression) function(logOrError) { 	var buffer = thi...(func $fileConsoleFlush						(local $logOrError i32)						(local $buffer i32)						(local $temp i32)												;; unwritable: (IfStatement) if (buffer) {console[logOrError](buffer));; (JSProperty) property: primitiveDropRequestFileHandle...;; (FunctionExpression) function(argCount) { 	var index = this.s...(func $primitiveDropRequestFileHandle						(local $fileNames i32)						(local $handle i32)						(local $argCount i32)						(local $fileName i32)						(local $index i32)						(local $temp i32)						(local $file i32)						;; (IfStatement) if (index < 1 || index > fileNames.lengt...;; (BinaryExpression) index < 1 || index > fileNames.length;; (BinaryExpression) index < 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.lt_u;; (BinaryExpression) index > fileNames.length;; (JSIdentifier) index						local.get $index;; (StaticMemberExpression) fileNames.length;; (JSIdentifier) length						local.get $length						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!file) {return false};; (UnaryExpression) !file;; (JSIdentifier) file						local.get $file						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.popNandPushIfOK(argCount + 1, handl...;; (CallExpression) this.popNandPushIfOK(argCount + 1, handl...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) handle						local.get $handle						call $popNandPushIfOK;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: primitiveDropRequestFileName -...;; (FunctionExpression) function(argCount) { 	var index = this.s...(func $primitiveDropRequestFileName						(local $fileNames i32)						(local $argCount i32)						(local $temp i32)						(local $index i32)						(local $result i32)						;; (IfStatement) if (index < 1 || index > fileNames.lengt...;; (BinaryExpression) index < 1 || index > fileNames.length;; (BinaryExpression) index < 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.lt_u;; (BinaryExpression) index > fileNames.length;; (JSIdentifier) index						local.get $index;; (StaticMemberExpression) fileNames.length;; (JSIdentifier) length						local.get $length						i32.gt_u						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, resul...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) result						local.get $result						call $popNandPushIfOK						return);; (JSProperty) property: snd_primitiveSoundStart -> fun...;; (FunctionExpression) function(argCount) { 	return this.snd_pr...(func $snd_primitiveSoundStart						(local $argCount i32)						(local $temp i32)						;; (ReturnStatement) return this.snd_primitiveSoundStartWithS...;; (CallExpression) this.snd_primitiveSoundStartWithSemaphor...						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $snd_primitiveSoundStartWithSemaphore						return);; (JSProperty) property: snd_primitiveSoundStartWithSem...;; (FunctionExpression) function(argCount) { 	var bufFrames = th...(func $snd_primitiveSoundStartWithSemaphore						(local $samplesPerSec i32)						(local $bufFrames i32)						(local $argCount i32)						(local $temp i32)						(local $stereoFlag i32)						(local $semaIndex i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (ExpressionStatement) this.audioContext = Squeak.startAudioOut						;; unwritable: (IfStatement) if (!this.audioContext) {this.vm.warnOnc;; (ExpressionStatement) this.audioSema = semaIndex;; (AssignmentExpression) this.audioSema = semaIndex;; (JSIdentifier) semaIndex						local.get $semaIndex						local.set $audioSema;; (ExpressionStatement) this.audioNextTimeSlot = 0;; (AssignmentExpression) this.audioNextTimeSlot = 0;; (JSLiteral) 0						i32.const 0						local.set $audioNextTimeSlot						;; unwritable: (ExpressionStatement) this.audioBuffersReady = []						;; unwritable: (ExpressionStatement) this.audioBuffersUnused = [this.audioCon						;; unwritable: (ExpressionStatement) console.log('sound: started');; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: snd_playNextBuffer -> function...;; (FunctionExpression) function() { 	if (!this.audioContext || ...(func $snd_playNextBuffer						(local $source i32)						(local $temp i32)						;; (IfStatement) if (!this.audioContext || this.audioBuff...;; (BinaryExpression) !this.audioContext || this.audioBuffersR...;; (UnaryExpression) !this.audioContext;; (StaticMemberExpression) this.audioContext;; (JSIdentifier) audioContext						local.get $audioContext						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (BinaryExpression) this.audioBuffersReady.length === 0;; (StaticMemberExpression) this.audioBuffersReady.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 0						i32.const 0						i32.eq						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 						return));; (ExpressionStatement) source.buffer = this.audioBuffersReady.s...;; (AssignmentExpression) source.buffer = this.audioBuffersReady.s...;; (CallExpression) this.audioBuffersReady.shift()						local.get $audioBuffersReady						call $shift						local.set $buffer;; (ExpressionStatement) source.connect(this.audioContext.destina...;; (CallExpression) source.connect(this.audioContext.destina...						local.get $source;; (StaticMemberExpression) this.audioContext.destination;; (JSIdentifier) destination						local.get $destination						call $connect						;; unwritable: (IfStatement) if (this.audioNextTimeSlot < this.audioC;; (ExpressionStatement) source.start(this.audioNextTimeSlot);; (CallExpression) source.start(this.audioNextTimeSlot)						local.get $source;; (StaticMemberExpression) this.audioNextTimeSlot;; (JSIdentifier) audioNextTimeSlot						local.get $audioNextTimeSlot						call $start;; (ExpressionStatement) this.audioNextTimeSlot += source.buffer....;; (AssignmentExpression) this.audioNextTimeSlot += source.buffer....;; (StaticMemberExpression) this.audioNextTimeSlot;; (JSIdentifier) audioNextTimeSlot						local.get $audioNextTimeSlot;; (StaticMemberExpression) source.buffer.duration;; (JSIdentifier) duration						local.get $duration						i32.add						local.set $audioNextTimeSlot						;; unwritable: (ExpressionStatement) self.setTimeout(function() { 	if (!this.;; (ExpressionStatement) this.snd_playNextBuffer();; (CallExpression) this.snd_playNextBuffer()						local.get $this						call $snd_playNextBuffer);; (JSProperty) property: snd_primitiveSoundAvailableSpa...;; (FunctionExpression) function(argCount) { 	if (!this.audioCon...(func $snd_primitiveSoundAvailableSpace						(local $buf i32)						(local $temp i32)						(local $argCount i32)						(local $available i32)												;; unwritable: (IfStatement) if (!this.audioContext) {console.log('so;; (IfStatement) if (this.audioBuffersUnused.length > 0) ...;; (BinaryExpression) this.audioBuffersUnused.length > 0;; (StaticMemberExpression) this.audioBuffersUnused.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 0						i32.const 0						i32.gt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) var buf = this.audioBuffersUnused[0] ava...;; (VariableDeclaration) var buf = this.audioBuffersUnused[0];; (VariableDeclarator) buf = this.audioBuffersUnused[0];; (ComputedMemberExpression) this.audioBuffersUnused[0];; (StaticMemberExpression) this.audioBuffersUnused;; (JSIdentifier) audioBuffersUnused						local.get $audioBuffersUnused;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add						local.set $buf;; (ExpressionStatement) available = buf.length * buf.numberOfCha...;; (AssignmentExpression) available = buf.length * buf.numberOfCha...;; (BinaryExpression) buf.length * buf.numberOfChannels * 2;; (BinaryExpression) buf.length * buf.numberOfChannels;; (StaticMemberExpression) buf.length;; (JSIdentifier) length						local.get $length;; (StaticMemberExpression) buf.numberOfChannels;; (JSIdentifier) numberOfChannels						local.get $numberOfChannels						i32.mul;; (JSLiteral) 2						i32.const 2						i32.mul						local.set $available));; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, avail...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) available						local.get $available						call $popNandPushIfOK						return);; (JSProperty) property: snd_primitiveSoundPlaySamples ...;; (FunctionExpression) function(argCount) { 	if (!this.audioCon...(func $snd_primitiveSoundPlaySamples						(local $buffer i32)						(local $startIndex i32)						(local $temp i32)						(local $channel i32)						(local $index i32)						(local $i i32)						(local $channels i32)						(local $sqSamples i32)						(local $count i32)						(local $argCount i32)						(local $jsSamples i32)												;; unwritable: (IfStatement) if (!this.audioContext || this.audioBuff;; (IfStatement) if (!this.success || !sqSamples) {return...;; (BinaryExpression) !this.success || !sqSamples;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !sqSamples;; (JSIdentifier) sqSamples						local.get $sqSamples						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ForStatement) for (var channel = 0; channel < channels...;; (VariableDeclaration) var channel = 0;; (VariableDeclarator) channel = 0;; (JSLiteral) 0						i32.const 0						local.set $channel						(loop $loop_1;; (BlockStatement) var jsSamples = buffer.getChannelData(ch...;; (VariableDeclaration) var jsSamples = buffer.getChannelData(ch...;; (VariableDeclarator) jsSamples = buffer.getChannelData(channe...;; (CallExpression) buffer.getChannelData(channel)						local.get $buffer;; (JSIdentifier) channel						local.get $channel						call $getChannelData						local.set $jsSamples;; (VariableDeclarator) index = startIndex + channel;; (BinaryExpression) startIndex + channel;; (JSIdentifier) startIndex						local.get $startIndex;; (JSIdentifier) channel						local.get $channel						i32.add						local.set $index;; (ForStatement) for (var i = 0; i < count; i++) {jsSampl...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_2;; (BlockStatement) jsSamples[i] = sqSamples[index] / 32768 ...;; (ExpressionStatement) jsSamples[i] = sqSamples[index] / 32768;; (AssignmentExpression) jsSamples[i] = sqSamples[index] / 32768						local.get $'jsSamples';; (JSIdentifier) i						local.get $i;; (BinaryExpression) sqSamples[index] / 32768;; (ComputedMemberExpression) sqSamples[index];; (JSIdentifier) sqSamples						local.get $sqSamples;; (JSIdentifier) index						local.get $index						i32.const 4						i32.mul						i32.add;; (JSLiteral) 32768						i32.const 32768						i32.div_s						call $atPut;; (ExpressionStatement) index += channels;; (AssignmentExpression) index += channels;; (JSIdentifier) index						local.get $index;; (JSIdentifier) channels						local.get $channels						i32.add						local.set $index;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < count;; (JSIdentifier) i						local.get $i;; (JSIdentifier) count						local.get $count						i32.lt_u						i32.const 0						br_if $loop_2);; (UpdateExpression) channel++;; (JSIdentifier) channel						local.get $channel						i32.const 1						i32.add;; (BinaryExpression) channel < channels;; (JSIdentifier) channel						local.get $channel;; (JSIdentifier) channels						local.get $channels						i32.lt_u						i32.const 0						br_if $loop_1);; (ExpressionStatement) this.audioBuffersReady.push(buffer);; (CallExpression) this.audioBuffersReady.push(buffer)						local.get $audioBuffersReady;; (JSIdentifier) buffer						local.get $buffer						call $push;; (ExpressionStatement) this.snd_playNextBuffer();; (CallExpression) this.snd_playNextBuffer()						local.get $this						call $snd_playNextBuffer;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: snd_primitiveSoundPlaySilence ...;; (FunctionExpression) function(argCount) { 	if (!this.audioCon...(func $snd_primitiveSoundPlaySilence						(local $channels i32)						(local $buffer i32)						(local $count i32)						(local $channel i32)						(local $jsSamples i32)						(local $argCount i32)						(local $i i32)						(local $temp i32)												;; unwritable: (IfStatement) if (!this.audioContext || this.audioBuff;; (ForStatement) for (var channel = 0; channel < channels...;; (VariableDeclaration) var channel = 0;; (VariableDeclarator) channel = 0;; (JSLiteral) 0						i32.const 0						local.set $channel						(loop $loop_1;; (BlockStatement) var jsSamples = buffer.getChannelData(ch...;; (VariableDeclaration) var jsSamples = buffer.getChannelData(ch...;; (VariableDeclarator) jsSamples = buffer.getChannelData(channe...;; (CallExpression) buffer.getChannelData(channel)						local.get $buffer;; (JSIdentifier) channel						local.get $channel						call $getChannelData						local.set $jsSamples;; (ForStatement) for (var i = 0; i < count; i++) {jsSampl...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_2;; (ExpressionStatement) jsSamples[i] = 0;; (AssignmentExpression) jsSamples[i] = 0						local.get $'jsSamples';; (JSIdentifier) i						local.get $i;; (JSLiteral) 0						i32.const 0						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < count;; (JSIdentifier) i						local.get $i;; (JSIdentifier) count						local.get $count						i32.lt_u						i32.const 0						br_if $loop_2);; (UpdateExpression) channel++;; (JSIdentifier) channel						local.get $channel						i32.const 1						i32.add;; (BinaryExpression) channel < channels;; (JSIdentifier) channel						local.get $channel;; (JSIdentifier) channels						local.get $channels						i32.lt_u						i32.const 0						br_if $loop_1);; (ExpressionStatement) this.audioBuffersReady.push(buffer);; (CallExpression) this.audioBuffersReady.push(buffer)						local.get $audioBuffersReady;; (JSIdentifier) buffer						local.get $buffer						call $push;; (ExpressionStatement) this.snd_playNextBuffer();; (CallExpression) this.snd_playNextBuffer()						local.get $this						call $snd_playNextBuffer;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, count...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) count						local.get $count						call $popNandPushIfOK						return);; (JSProperty) property: snd_primitiveSoundStop -> func...;; (FunctionExpression) function(argCount) { 	if (this.audioCont...(func $snd_primitiveSoundStop						(local $argCount i32)						(local $temp i32)												;; unwritable: (IfStatement) if (this.audioContext) {this.audioContex;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: snd_primitiveSoundStartRecordi...;; (FunctionExpression) function(argCount) { 	if (argCount !== 3...(func $snd_primitiveSoundStartRecording						(local $samplesPerSec i32)						(local $method i32)						(local $temp i32)						(local $stereoFlag i32)						(local $rcvr i32)						(local $unfreeze i32)						(local $self i32)						(local $argCount i32)						(local $semaIndex i32)						;; (IfStatement) if (argCount !== 3) {return false};; (BinaryExpression) argCount !== 3;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 3						i32.const 3						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (ExpressionStatement) Squeak.startAudioIn(function(audioContex;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: snd_recordNextBuffer -> functi...;; (FunctionExpression) function(audioBuffer) { 	if (!this.audio...(func $snd_recordNextBuffer						(local $temp i32)						(local $audioBuffer i32)						;; (IfStatement) if (!this.audioInContext) {return };; (UnaryExpression) !this.audioInContext;; (StaticMemberExpression) this.audioInContext;; (JSIdentifier) audioInContext						local.get $audioInContext						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return 						return));; (IfStatement) if (this.audioInBuffers.length > 5) {thi...;; (BinaryExpression) this.audioInBuffers.length > 5;; (StaticMemberExpression) this.audioInBuffers.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 5						i32.const 5						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.audioInBuffers.shift();; (CallExpression) this.audioInBuffers.shift()						local.get $audioInBuffers						call $shift));; (ExpressionStatement) this.audioInBuffers.push(audioBuffer);; (CallExpression) this.audioInBuffers.push(audioBuffer)						local.get $audioInBuffers;; (JSIdentifier) audioBuffer						local.get $audioBuffer						call $push;; (IfStatement) if (this.audioInSema) {this.signalSemaph...;; (StaticMemberExpression) this.audioInSema;; (JSIdentifier) audioInSema						local.get $audioInSema						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.signalSemaphoreWithIndex(this.audio...;; (CallExpression) this.signalSemaphoreWithIndex(this.audio...						local.get $this;; (StaticMemberExpression) this.audioInSema;; (JSIdentifier) audioInSema						local.get $audioInSema						call $signalSemaphoreWithIndex));; (ExpressionStatement) this.vm.forceInterruptCheck();; (CallExpression) this.vm.forceInterruptCheck()						local.get $vm						call $forceInterruptCheck);; (JSProperty) property: snd_primitiveSoundGetRecording...;; (FunctionExpression) function(argCount) { 	if (!this.audioInC...(func $snd_primitiveSoundGetRecordingSampleRate						(local $actualRate i32)						(local $argCount i32)						(local $temp i32)						;; (IfStatement) if (!this.audioInContext) {return false};; (UnaryExpression) !this.audioInContext;; (StaticMemberExpression) this.audioInContext;; (JSIdentifier) audioInContext						local.get $audioInContext						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (ExpressionStatement) console.log('sound: actual recording rat;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, actua...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) actualRate						local.get $actualRate						call $popNandPushIfOK						return);; (JSProperty) property: snd_primitiveSoundRecordSample...;; (FunctionExpression) function(argCount) { 	var sqSamples = th...(func $snd_primitiveSoundRecordSamples						(local $buffer i32)						(local $sqStep i32)						(local $jsStep i32)						(local $temp i32)						(local $channel i32)						(local $sqIndex i32)						(local $sampleCount i32)						(local $i i32)						(local $sqCount i32)						(local $channels i32)						(local $sqSamples i32)						(local $argCount i32)						(local $jsCount i32)						(local $count i32)						(local $jsSamples i32)						(local $jsIndex i32)						(local $sqStartIndex i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (WhileStatement) while (sqStartIndex < sqSamples.length) ...						(loop $loop_1;; (BlockStatement) if (this.audioInBuffers.length === 0) {b...;; (IfStatement) if (this.audioInBuffers.length === 0) {b...;; (BinaryExpression) this.audioInBuffers.length === 0;; (StaticMemberExpression) this.audioInBuffers.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (BreakStatement) break						br $loop_1_continue));; (BinaryExpression) sqStartIndex < sqSamples.length;; (JSIdentifier) sqStartIndex						local.get $sqStartIndex;; (StaticMemberExpression) sqSamples.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, sampl...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) sampleCount						local.get $sampleCount						call $popNandPushIfOK						return);; (JSProperty) property: snd_primitiveSoundStopRecordin...;; (FunctionExpression) function(argCount) { 	if (this.audioInCo...(func $snd_primitiveSoundStopRecording						(local $argCount i32)						(local $temp i32)												;; unwritable: (IfStatement) if (this.audioInContext) {this.audioInSo;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: snd_primitiveSoundSetRecordLev...;; (FunctionExpression) function(argCount) { 	return true }(func $snd_primitiveSoundSetRecordLevel						(local $argCount i32)						(local $temp i32)						;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: jpeg2_primJPEGPluginIsPresent ...;; (FunctionExpression) function(argCount) { 	return this.popNan...(func $jpeg2_primJPEGPluginIsPresent						(local $argCount i32)						(local $temp i32)						;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (StaticMemberExpression) this.vm.trueObj;; (JSIdentifier) trueObj						local.get $trueObj						call $popNandPushIfOK						return);; (JSProperty) property: jpeg2_primImageHeight -> funct...;; (FunctionExpression) function(argCount) { 	var decompressStru...(func $jpeg2_primImageHeight						(local $height i32)						(local $temp i32)						(local $argCount i32)						(local $decompressStruct i32)						;; (IfStatement) if (!decompressStruct) {return false};; (UnaryExpression) !decompressStruct;; (JSIdentifier) decompressStruct						local.get $decompressStruct						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, heigh...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) height						local.get $height						call $popNandPushIfOK						return);; (JSProperty) property: jpeg2_primImageWidth -> functi...;; (FunctionExpression) function(argCount) { 	var decompressStru...(func $jpeg2_primImageWidth						(local $width i32)						(local $argCount i32)						(local $temp i32)						(local $decompressStruct i32)						;; (IfStatement) if (!decompressStruct) {return false};; (UnaryExpression) !decompressStruct;; (JSIdentifier) decompressStruct						local.get $decompressStruct						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, width...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) width						local.get $width						call $popNandPushIfOK						return);; (JSProperty) property: jpeg2_primJPEGCompressStructSi...;; (FunctionExpression) function(argCount) { 	return this.popNan...(func $jpeg2_primJPEGCompressStructSize						(local $argCount i32)						(local $temp i32)						;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, 0)						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSLiteral) 0						i32.const 0						call $popNandPushIfOK						return);; (JSProperty) property: jpeg2_primJPEGDecompressStruct...;; (FunctionExpression) function(argCount) { 	return this.popNan...(func $jpeg2_primJPEGDecompressStructSize						(local $argCount i32)						(local $temp i32)						;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, 8)						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSLiteral) 8						i32.const 8						call $popNandPushIfOK						return);; (JSProperty) property: jpeg2_primJPEGErrorMgr2StructS...;; (FunctionExpression) function(argCount) { 	return this.popNan...(func $jpeg2_primJPEGErrorMgr2StructSize						(local $argCount i32)						(local $temp i32)						;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, 0)						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSLiteral) 0						i32.const 0						call $popNandPushIfOK						return);; (JSProperty) property: jpeg2_primJPEGReadHeaderfromBy...;; (FunctionExpression) function(argCount) { 	var decompressStru...(func $jpeg2_primJPEGReadHeaderfromByteArrayerrorMgr						(local $unfreeze i32)						(local $argCount i32)						(local $temp i32)						(local $decompressStruct i32)						(local $source i32)						;; (IfStatement) if (!decompressStruct || !source) {retur...;; (BinaryExpression) !decompressStruct || !source;; (UnaryExpression) !decompressStruct;; (JSIdentifier) decompressStruct						local.get $decompressStruct						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !source;; (JSIdentifier) source						local.get $source						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (ExpressionStatement) this.jpeg2_readImageFromBytes(source, fu;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: jpeg2_primJPEGReadImagefromByt...;; (FunctionExpression) function(argCount) { 	var source = this....(func $jpeg2_primJPEGReadImagefromByteArrayonFormdoDitheringerrorMgr						(local $state i32)						(local $temp i32)						(local $image i32)						(local $form i32)						(local $source i32)						(local $formBits i32)						(local $argCount i32)						(local $depth i32)						(local $ditherFlag i32)						;; (IfStatement) if (!this.success || !source || !form) {...;; (BinaryExpression) !this.success || !source || !form;; (BinaryExpression) !this.success || !source;; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !source;; (JSIdentifier) source						local.get $source						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or;; (UnaryExpression) !form;; (JSIdentifier) form						local.get $form						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (IfStatement) if (!state || state.src !== source) {con;; (IfStatement) if (depth === 32) {this.jpeg2_copyPixels...;; (BinaryExpression) depth === 32;; (JSIdentifier) depth						local.get $depth;; (JSLiteral) 32						i32.const 32						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.jpeg2_copyPixelsToForm32(image, for...;; (ExpressionStatement) this.jpeg2_copyPixelsToForm32(image, for...;; (CallExpression) this.jpeg2_copyPixelsToForm32(image, for...						local.get $this;; (JSIdentifier) image						local.get $image;; (JSIdentifier) formBits						local.get $formBits						call $jpeg2_copyPixelsToForm32)						(else;; (IfStatement) if (depth === 16) {if (ditherFlag) {this...;; (BinaryExpression) depth === 16;; (JSIdentifier) depth						local.get $depth;; (JSLiteral) 16						i32.const 16						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (ditherFlag) {this.jpeg2_ditherPixels...;; (IfStatement) if (ditherFlag) {this.jpeg2_ditherPixels...;; (JSIdentifier) ditherFlag						local.get $ditherFlag						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.jpeg2_ditherPixelsToForm16(image, f...;; (CallExpression) this.jpeg2_ditherPixelsToForm16(image, f...						local.get $this;; (JSIdentifier) image						local.get $image;; (JSIdentifier) formBits						local.get $formBits						call $jpeg2_ditherPixelsToForm16)						(else;; (ExpressionStatement) this.jpeg2_copyPixelsToForm16(image, for...;; (CallExpression) this.jpeg2_copyPixelsToForm16(image, for...						local.get $this;; (JSIdentifier) image						local.get $image;; (JSIdentifier) formBits						local.get $formBits						call $jpeg2_copyPixelsToForm16)))						(else;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))));; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: jpeg2_primJPEGWriteImageonByte...;; (FunctionExpression) function(argCount) { 	this.vm.warnOnce('...(func $jpeg2_primJPEGWriteImageonByteArrayformqualityprogressiveJPEGerrorMgr						(local $argCount i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.vm.warnOnce('JPEGReadWritePlugin2: ;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: jpeg2_readImageFromBytes -> fu...;; (FunctionExpression) function(bytes, thenDo, errorDo) { 	var ...(func $jpeg2_readImageFromBytes						(local $errorDo i32)						(local $bytes i32)						(local $image i32)						(local $temp i32)						(local $blob i32)						(local $thenDo i32)						;; (ExpressionStatement) image.onload = function() { 	thenDo(imag...;; (AssignmentExpression) image.onload = function() { 	thenDo(imag...;; (FunctionExpression) function() { 	thenDo(image) }(func $nil						(local $temp i32)						;; (ExpressionStatement) thenDo(image);; (CallExpression) thenDo(image);; (JSIdentifier) image						local.get $image						call $thenDo)						local.set $onload;; (ExpressionStatement) image.onerror = function() { 	console.wa...;; (AssignmentExpression) image.onerror = function() { 	console.wa...;; (FunctionExpression) function() { 	console.warn('could not re...(func $nil						(local $temp i32)												;; unwritable: (ExpressionStatement) console.warn('could not render JPEG');; (ExpressionStatement) errorDo();; (CallExpression) errorDo()						call $errorDo)						local.set $onerror						;; unwritable: (ExpressionStatement) image.src = self.URL || self.webkitURL.c);; (JSProperty) property: jpeg2_getPixelsFromImage -> fu...;; (FunctionExpression) function(image) { 	var canvas = document...(func $jpeg2_getPixelsFromImage						(local $image i32)						(local $canvas i32)						(local $temp i32)						(local $context i32)						;; (ExpressionStatement) canvas.width = image.width;; (AssignmentExpression) canvas.width = image.width;; (StaticMemberExpression) image.width;; (JSIdentifier) width						local.get $width						local.set $width;; (ExpressionStatement) canvas.height = image.height;; (AssignmentExpression) canvas.height = image.height;; (StaticMemberExpression) image.height;; (JSIdentifier) height						local.get $height						local.set $height;; (ExpressionStatement) context.drawImage(image, 0, 0);; (CallExpression) context.drawImage(image, 0, 0)						local.get $context;; (JSIdentifier) image						local.get $image;; (JSLiteral) 0						i32.const 0;; (JSLiteral) 0						i32.const 0						call $drawImage;; (ReturnStatement) return context.getImageData(0, 0, image....;; (CallExpression) context.getImageData(0, 0, image.width, ...						local.get $context;; (JSLiteral) 0						i32.const 0;; (JSLiteral) 0						i32.const 0;; (StaticMemberExpression) image.width;; (JSIdentifier) width						local.get $width;; (StaticMemberExpression) image.height;; (JSIdentifier) height						local.get $height						call $getImageData						return);; (JSProperty) property: jpeg2_copyPixelsToForm32 -> fu...;; (FunctionExpression) function(image, formBits) { 	var pixels ...(func $jpeg2_copyPixelsToForm32						(local $image i32)						(local $b i32)						(local $i i32)						(local $r i32)						(local $g i32)						(local $pixels i32)						(local $formBits i32)						(local $temp i32)						;; (ForStatement) for (var i = 0; i < formBits.length; i++...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (BlockStatement) var r = pixels[i * 4 + 0], g = pixels[i ...;; (VariableDeclaration) var r = pixels[i * 4 + 0], g = pixels[i ...;; (VariableDeclarator) r = pixels[i * 4 + 0];; (ComputedMemberExpression) pixels[i * 4 + 0];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i * 4 + 0;; (BinaryExpression) i * 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.mul;; (JSLiteral) 0						i32.const 0						i32.add						i32.const 4						i32.mul						i32.add						local.set $r;; (VariableDeclarator) g = pixels[i * 4 + 1];; (ComputedMemberExpression) pixels[i * 4 + 1];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i * 4 + 1;; (BinaryExpression) i * 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.mul;; (JSLiteral) 1						i32.const 1						i32.add						i32.const 4						i32.mul						i32.add						local.set $g;; (VariableDeclarator) b = pixels[i * 4 + 2];; (ComputedMemberExpression) pixels[i * 4 + 2];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i * 4 + 2;; (BinaryExpression) i * 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.mul;; (JSLiteral) 2						i32.const 2						i32.add						i32.const 4						i32.mul						i32.add						local.set $b;; (ExpressionStatement) formBits[i] = 4.27819008e9 | r << 16 | g...;; (AssignmentExpression) formBits[i] = 4.27819008e9 | r << 16 | g...						local.get $'formBits';; (JSIdentifier) i						local.get $i;; (BinaryExpression) 4.27819008e9 | r << 16 | g << 8 | b;; (BinaryExpression) 4.27819008e9 | r << 16 | g << 8;; (BinaryExpression) 4.27819008e9 | r << 16;; (JSLiteral) 4.27819008e9						i32.const 4278190080;; (BinaryExpression) r << 16;; (JSIdentifier) r						local.get $r;; (JSLiteral) 16						i32.const 16						i32.shl						i32.or;; (BinaryExpression) g << 8;; (JSIdentifier) g						local.get $g;; (JSLiteral) 8						i32.const 8						i32.shl						i32.or;; (JSIdentifier) b						local.get $b						i32.or						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < formBits.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) formBits.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_1));; (JSProperty) property: jpeg2_copyPixelsToForm16 -> fu...;; (FunctionExpression) function(image, formBits) { 	var width =...(func $jpeg2_copyPixelsToForm16						(local $temp i32)						(local $image i32)						(local $b2 i32)						(local $formPix i32)						(local $x i32)						(local $g1 i32)						(local $height i32)						(local $r2 i32)						(local $i i32)						(local $b1 i32)						(local $formBits i32)						(local $width i32)						(local $r1 i32)						(local $pixels i32)						(local $y i32)						(local $g2 i32)						;; (ForStatement) for (var y = 0; y < height; y++) {for (v...;; (VariableDeclaration) var y = 0;; (VariableDeclarator) y = 0;; (JSLiteral) 0						i32.const 0						local.set $y						(loop $loop_1;; (ForStatement) for (var x = 0; x < width; x += 2) {var ...;; (VariableDeclaration) var x = 0;; (VariableDeclarator) x = 0;; (JSLiteral) 0						i32.const 0						local.set $x						(loop $loop_2;; (BlockStatement) var i = y * height + x, r1 = pixels[i * ...;; (VariableDeclaration) var i = y * height + x, r1 = pixels[i * ...;; (VariableDeclarator) i = y * height + x;; (BinaryExpression) y * height + x;; (BinaryExpression) y * height;; (JSIdentifier) y						local.get $y;; (JSIdentifier) height						local.get $height						i32.mul;; (JSIdentifier) x						local.get $x						i32.add						local.set $i;; (VariableDeclarator) r1 = pixels[i * 4 + 0] >> 3;; (BinaryExpression) pixels[i * 4 + 0] >> 3;; (ComputedMemberExpression) pixels[i * 4 + 0];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i * 4 + 0;; (BinaryExpression) i * 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.mul;; (JSLiteral) 0						i32.const 0						i32.add						i32.const 4						i32.mul						i32.add;; (JSLiteral) 3						i32.const 3						i32.shr_s						local.set $r1;; (VariableDeclarator) g1 = pixels[i * 4 + 1] >> 3;; (BinaryExpression) pixels[i * 4 + 1] >> 3;; (ComputedMemberExpression) pixels[i * 4 + 1];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i * 4 + 1;; (BinaryExpression) i * 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.mul;; (JSLiteral) 1						i32.const 1						i32.add						i32.const 4						i32.mul						i32.add;; (JSLiteral) 3						i32.const 3						i32.shr_s						local.set $g1;; (VariableDeclarator) b1 = pixels[i * 4 + 2] >> 3;; (BinaryExpression) pixels[i * 4 + 2] >> 3;; (ComputedMemberExpression) pixels[i * 4 + 2];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i * 4 + 2;; (BinaryExpression) i * 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.mul;; (JSLiteral) 2						i32.const 2						i32.add						i32.const 4						i32.mul						i32.add;; (JSLiteral) 3						i32.const 3						i32.shr_s						local.set $b1;; (VariableDeclarator) r2 = pixels[i * 4 + 4] >> 3;; (BinaryExpression) pixels[i * 4 + 4] >> 3;; (ComputedMemberExpression) pixels[i * 4 + 4];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i * 4 + 4;; (BinaryExpression) i * 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.mul;; (JSLiteral) 4						i32.const 4						i32.add						i32.const 4						i32.mul						i32.add;; (JSLiteral) 3						i32.const 3						i32.shr_s						local.set $r2;; (VariableDeclarator) g2 = pixels[i * 4 + 5] >> 3;; (BinaryExpression) pixels[i * 4 + 5] >> 3;; (ComputedMemberExpression) pixels[i * 4 + 5];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i * 4 + 5;; (BinaryExpression) i * 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.mul;; (JSLiteral) 5						i32.const 5						i32.add						i32.const 4						i32.mul						i32.add;; (JSLiteral) 3						i32.const 3						i32.shr_s						local.set $g2;; (VariableDeclarator) b2 = pixels[i * 4 + 6] >> 3;; (BinaryExpression) pixels[i * 4 + 6] >> 3;; (ComputedMemberExpression) pixels[i * 4 + 6];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i * 4 + 6;; (BinaryExpression) i * 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.mul;; (JSLiteral) 6						i32.const 6						i32.add						i32.const 4						i32.mul						i32.add;; (JSLiteral) 3						i32.const 3						i32.shr_s						local.set $b2;; (VariableDeclarator) formPix = r1 << 10 | g1 << 5 | b1;; (BinaryExpression) r1 << 10 | g1 << 5 | b1;; (BinaryExpression) r1 << 10 | g1 << 5;; (BinaryExpression) r1 << 10;; (JSIdentifier) r1						local.get $r1;; (JSLiteral) 10						i32.const 10						i32.shl;; (BinaryExpression) g1 << 5;; (JSIdentifier) g1						local.get $g1;; (JSLiteral) 5						i32.const 5						i32.shl						i32.or;; (JSIdentifier) b1						local.get $b1						i32.or						local.set $formPix;; (IfStatement) if (formPix === 0) {formPix = 1};; (BinaryExpression) formPix === 0;; (JSIdentifier) formPix						local.get $formPix;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) formPix = 1;; (AssignmentExpression) formPix = 1;; (JSLiteral) 1						i32.const 1						local.set $formPix));; (ExpressionStatement) formPix = formPix << 16 | r2 << 10 | g2 ...;; (AssignmentExpression) formPix = formPix << 16 | r2 << 10 | g2 ...;; (BinaryExpression) formPix << 16 | r2 << 10 | g2 << 5 | b2;; (BinaryExpression) formPix << 16 | r2 << 10 | g2 << 5;; (BinaryExpression) formPix << 16 | r2 << 10;; (BinaryExpression) formPix << 16;; (JSIdentifier) formPix						local.get $formPix;; (JSLiteral) 16						i32.const 16						i32.shl;; (BinaryExpression) r2 << 10;; (JSIdentifier) r2						local.get $r2;; (JSLiteral) 10						i32.const 10						i32.shl						i32.or;; (BinaryExpression) g2 << 5;; (JSIdentifier) g2						local.get $g2;; (JSLiteral) 5						i32.const 5						i32.shl						i32.or;; (JSIdentifier) b2						local.get $b2						i32.or						local.set $formPix;; (IfStatement) if (formPix & 65535 === 0) {formPix = fo...;; (BinaryExpression) formPix & 65535 === 0;; (BinaryExpression) formPix & 65535;; (JSIdentifier) formPix						local.get $formPix;; (JSLiteral) 65535						i32.const 65535						i32.and;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) formPix = formPix | 1;; (AssignmentExpression) formPix = formPix | 1;; (BinaryExpression) formPix | 1;; (JSIdentifier) formPix						local.get $formPix;; (JSLiteral) 1						i32.const 1						i32.or						local.set $formPix));; (ExpressionStatement) formBits[i >> 1] = formPix;; (AssignmentExpression) formBits[i >> 1] = formPix						local.get $'formBits';; (BinaryExpression) i >> 1;; (JSIdentifier) i						local.get $i;; (JSLiteral) 1						i32.const 1						i32.shr_s;; (JSIdentifier) formPix						local.get $formPix						call $atPut;; (AssignmentExpression) x += 2;; (JSIdentifier) x						local.get $x;; (JSLiteral) 2						i32.const 2						i32.add						local.set $x;; (BinaryExpression) x < width;; (JSIdentifier) x						local.get $x;; (JSIdentifier) width						local.get $width						i32.lt_u						i32.const 0						br_if $loop_2);; (UpdateExpression) y++;; (JSIdentifier) y						local.get $y						i32.const 1						i32.add;; (BinaryExpression) y < height;; (JSIdentifier) y						local.get $y;; (JSIdentifier) height						local.get $height						i32.lt_u						i32.const 0						br_if $loop_1));; (JSProperty) property: jpeg2_ditherPixelsToForm16 -> ...;; (FunctionExpression) function(image, formBits) { 	var width =...(func $jpeg2_ditherPixelsToForm16						(local $ditherMatrix2 i32)						(local $g1 i32)						(local $r1 i32)						(local $dmv2 i32)						(local $i i32)						(local $ditherMatrix1 i32)						(local $b2 i32)						(local $formPix i32)						(local $dmv1 i32)						(local $pixels i32)						(local $y i32)						(local $b1 i32)						(local $dmi i32)						(local $temp i32)						(local $x i32)						(local $width i32)						(local $image i32)						(local $dmo i32)						(local $v i32)						(local $height i32)						(local $formBits i32)						(local $di i32)						(local $g2 i32)						(local $r2 i32)						;; (ForStatement) for (var y = 0; y < height; y++) {for (v...;; (VariableDeclaration) var y = 0;; (VariableDeclarator) y = 0;; (JSLiteral) 0						i32.const 0						local.set $y						(loop $loop_1;; (ForStatement) for (var x = 0; x < width; x++) {var i =...;; (VariableDeclaration) var x = 0;; (VariableDeclarator) x = 0;; (JSLiteral) 0						i32.const 0						local.set $x						(loop $loop_2;; (BlockStatement) var i = y * height + 2 * x << 2, r1 = pi...;; (VariableDeclaration) var i = y * height + 2 * x << 2, r1 = pi...;; (VariableDeclarator) i = y * height + 2 * x << 2;; (BinaryExpression) y * height + 2 * x << 2;; (BinaryExpression) y * height + 2 * x;; (BinaryExpression) y * height;; (JSIdentifier) y						local.get $y;; (JSIdentifier) height						local.get $height						i32.mul;; (BinaryExpression) 2 * x;; (JSLiteral) 2						i32.const 2;; (JSIdentifier) x						local.get $x						i32.mul						i32.add;; (JSLiteral) 2						i32.const 2						i32.shl						local.set $i;; (VariableDeclarator) r1 = pixels[i + 0];; (ComputedMemberExpression) pixels[i + 0];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i + 0;; (JSIdentifier) i						local.get $i;; (JSLiteral) 0						i32.const 0						i32.add						i32.const 4						i32.mul						i32.add						local.set $r1;; (VariableDeclarator) g1 = pixels[i + 1];; (ComputedMemberExpression) pixels[i + 1];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i + 1;; (JSIdentifier) i						local.get $i;; (JSLiteral) 1						i32.const 1						i32.add						i32.const 4						i32.mul						i32.add						local.set $g1;; (VariableDeclarator) b1 = pixels[i + 2];; (ComputedMemberExpression) pixels[i + 2];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i + 2;; (JSIdentifier) i						local.get $i;; (JSLiteral) 2						i32.const 2						i32.add						i32.const 4						i32.mul						i32.add						local.set $b1;; (VariableDeclarator) r2 = pixels[i + 4];; (ComputedMemberExpression) pixels[i + 4];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i + 4;; (JSIdentifier) i						local.get $i;; (JSLiteral) 4						i32.const 4						i32.add						i32.const 4						i32.mul						i32.add						local.set $r2;; (VariableDeclarator) g2 = pixels[i + 5];; (ComputedMemberExpression) pixels[i + 5];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i + 5;; (JSIdentifier) i						local.get $i;; (JSLiteral) 5						i32.const 5						i32.add						i32.const 4						i32.mul						i32.add						local.set $g2;; (VariableDeclarator) b2 = pixels[i + 6];; (ComputedMemberExpression) pixels[i + 6];; (JSIdentifier) pixels						local.get $pixels;; (BinaryExpression) i + 6;; (JSIdentifier) i						local.get $i;; (JSLiteral) 6						i32.const 6						i32.add						i32.const 4						i32.mul						i32.add						local.set $b2;; (VariableDeclaration) var v = y & 3 << 1 | x & 1, dmv1 = dithe...;; (VariableDeclarator) v = y & 3 << 1 | x & 1;; (BinaryExpression) y & 3 << 1 | x & 1;; (BinaryExpression) y & 3 << 1;; (BinaryExpression) y & 3;; (JSIdentifier) y						local.get $y;; (JSLiteral) 3						i32.const 3						i32.and;; (JSLiteral) 1						i32.const 1						i32.shl;; (BinaryExpression) x & 1;; (JSIdentifier) x						local.get $x;; (JSLiteral) 1						i32.const 1						i32.and						i32.or						local.set $v;; (VariableDeclarator) dmv1 = ditherMatrix1[v];; (ComputedMemberExpression) ditherMatrix1[v];; (JSIdentifier) ditherMatrix1						local.get $ditherMatrix1;; (JSIdentifier) v						local.get $v						i32.const 4						i32.mul						i32.add						local.set $dmv1;; (VariableDeclarator) dmv2 = ditherMatrix2[v];; (ComputedMemberExpression) ditherMatrix2[v];; (JSIdentifier) ditherMatrix2						local.get $ditherMatrix2;; (JSIdentifier) v						local.get $v						i32.const 4						i32.mul						i32.add						local.set $dmv2;; (VariableDeclarator) di;; (VariableDeclarator) dmi;; (VariableDeclarator) dmo;; (ExpressionStatement) an active SequenceExpression with proper...;; (SequenceExpression) an active SequenceExpression with proper...;; (IfStatement) if (dmv1 < dmi) {r1 = dmo + 1 } else {r1...;; (BinaryExpression) dmv1 < dmi;; (JSIdentifier) dmv1						local.get $dmv1;; (JSIdentifier) dmi						local.get $dmi						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) r1 = dmo + 1 ;; (ExpressionStatement) r1 = dmo + 1;; (AssignmentExpression) r1 = dmo + 1;; (BinaryExpression) dmo + 1;; (JSIdentifier) dmo						local.get $dmo;; (JSLiteral) 1						i32.const 1						i32.add						local.set $r1)						(else;; (BlockStatement) r1 = dmo ;; (ExpressionStatement) r1 = dmo;; (AssignmentExpression) r1 = dmo;; (JSIdentifier) dmo						local.get $dmo						local.set $r1));; (EmptyStatement) ;; (ExpressionStatement) di = g1 * 496 >> 8;; (AssignmentExpression) di = g1 * 496 >> 8;; (BinaryExpression) g1 * 496 >> 8;; (BinaryExpression) g1 * 496;; (JSIdentifier) g1						local.get $g1;; (JSLiteral) 496						i32.const 496						i32.mul;; (JSLiteral) 8						i32.const 8						i32.shr_s						local.set $di;; (ExpressionStatement) dmi = di & 15;; (AssignmentExpression) dmi = di & 15;; (BinaryExpression) di & 15;; (JSIdentifier) di						local.get $di;; (JSLiteral) 15						i32.const 15						i32.and						local.set $dmi;; (ExpressionStatement) dmo = di >> 4;; (AssignmentExpression) dmo = di >> 4;; (BinaryExpression) di >> 4;; (JSIdentifier) di						local.get $di;; (JSLiteral) 4						i32.const 4						i32.shr_s						local.set $dmo;; (IfStatement) if (dmv1 < dmi) {g1 = dmo + 1 } else {g1...;; (BinaryExpression) dmv1 < dmi;; (JSIdentifier) dmv1						local.get $dmv1;; (JSIdentifier) dmi						local.get $dmi						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) g1 = dmo + 1 ;; (ExpressionStatement) g1 = dmo + 1;; (AssignmentExpression) g1 = dmo + 1;; (BinaryExpression) dmo + 1;; (JSIdentifier) dmo						local.get $dmo;; (JSLiteral) 1						i32.const 1						i32.add						local.set $g1)						(else;; (BlockStatement) g1 = dmo ;; (ExpressionStatement) g1 = dmo;; (AssignmentExpression) g1 = dmo;; (JSIdentifier) dmo						local.get $dmo						local.set $g1));; (EmptyStatement) ;; (ExpressionStatement) di = b1 * 496 >> 8;; (AssignmentExpression) di = b1 * 496 >> 8;; (BinaryExpression) b1 * 496 >> 8;; (BinaryExpression) b1 * 496;; (JSIdentifier) b1						local.get $b1;; (JSLiteral) 496						i32.const 496						i32.mul;; (JSLiteral) 8						i32.const 8						i32.shr_s						local.set $di;; (ExpressionStatement) dmi = di & 15;; (AssignmentExpression) dmi = di & 15;; (BinaryExpression) di & 15;; (JSIdentifier) di						local.get $di;; (JSLiteral) 15						i32.const 15						i32.and						local.set $dmi;; (ExpressionStatement) dmo = di >> 4;; (AssignmentExpression) dmo = di >> 4;; (BinaryExpression) di >> 4;; (JSIdentifier) di						local.get $di;; (JSLiteral) 4						i32.const 4						i32.shr_s						local.set $dmo;; (IfStatement) if (dmv1 < dmi) {b1 = dmo + 1 } else {b1...;; (BinaryExpression) dmv1 < dmi;; (JSIdentifier) dmv1						local.get $dmv1;; (JSIdentifier) dmi						local.get $dmi						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) b1 = dmo + 1 ;; (ExpressionStatement) b1 = dmo + 1;; (AssignmentExpression) b1 = dmo + 1;; (BinaryExpression) dmo + 1;; (JSIdentifier) dmo						local.get $dmo;; (JSLiteral) 1						i32.const 1						i32.add						local.set $b1)						(else;; (BlockStatement) b1 = dmo ;; (ExpressionStatement) b1 = dmo;; (AssignmentExpression) b1 = dmo;; (JSIdentifier) dmo						local.get $dmo						local.set $b1));; (EmptyStatement) ;; (ExpressionStatement) di = r2 * 496 >> 8;; (AssignmentExpression) di = r2 * 496 >> 8;; (BinaryExpression) r2 * 496 >> 8;; (BinaryExpression) r2 * 496;; (JSIdentifier) r2						local.get $r2;; (JSLiteral) 496						i32.const 496						i32.mul;; (JSLiteral) 8						i32.const 8						i32.shr_s						local.set $di;; (ExpressionStatement) dmi = di & 15;; (AssignmentExpression) dmi = di & 15;; (BinaryExpression) di & 15;; (JSIdentifier) di						local.get $di;; (JSLiteral) 15						i32.const 15						i32.and						local.set $dmi;; (ExpressionStatement) dmo = di >> 4;; (AssignmentExpression) dmo = di >> 4;; (BinaryExpression) di >> 4;; (JSIdentifier) di						local.get $di;; (JSLiteral) 4						i32.const 4						i32.shr_s						local.set $dmo;; (IfStatement) if (dmv2 < dmi) {r2 = dmo + 1 } else {r2...;; (BinaryExpression) dmv2 < dmi;; (JSIdentifier) dmv2						local.get $dmv2;; (JSIdentifier) dmi						local.get $dmi						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) r2 = dmo + 1 ;; (ExpressionStatement) r2 = dmo + 1;; (AssignmentExpression) r2 = dmo + 1;; (BinaryExpression) dmo + 1;; (JSIdentifier) dmo						local.get $dmo;; (JSLiteral) 1						i32.const 1						i32.add						local.set $r2)						(else;; (BlockStatement) r2 = dmo ;; (ExpressionStatement) r2 = dmo;; (AssignmentExpression) r2 = dmo;; (JSIdentifier) dmo						local.get $dmo						local.set $r2));; (EmptyStatement) ;; (ExpressionStatement) di = g2 * 496 >> 8;; (AssignmentExpression) di = g2 * 496 >> 8;; (BinaryExpression) g2 * 496 >> 8;; (BinaryExpression) g2 * 496;; (JSIdentifier) g2						local.get $g2;; (JSLiteral) 496						i32.const 496						i32.mul;; (JSLiteral) 8						i32.const 8						i32.shr_s						local.set $di;; (ExpressionStatement) dmi = di & 15;; (AssignmentExpression) dmi = di & 15;; (BinaryExpression) di & 15;; (JSIdentifier) di						local.get $di;; (JSLiteral) 15						i32.const 15						i32.and						local.set $dmi;; (ExpressionStatement) dmo = di >> 4;; (AssignmentExpression) dmo = di >> 4;; (BinaryExpression) di >> 4;; (JSIdentifier) di						local.get $di;; (JSLiteral) 4						i32.const 4						i32.shr_s						local.set $dmo;; (IfStatement) if (dmv2 < dmi) {g2 = dmo + 1 } else {g2...;; (BinaryExpression) dmv2 < dmi;; (JSIdentifier) dmv2						local.get $dmv2;; (JSIdentifier) dmi						local.get $dmi						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) g2 = dmo + 1 ;; (ExpressionStatement) g2 = dmo + 1;; (AssignmentExpression) g2 = dmo + 1;; (BinaryExpression) dmo + 1;; (JSIdentifier) dmo						local.get $dmo;; (JSLiteral) 1						i32.const 1						i32.add						local.set $g2)						(else;; (BlockStatement) g2 = dmo ;; (ExpressionStatement) g2 = dmo;; (AssignmentExpression) g2 = dmo;; (JSIdentifier) dmo						local.get $dmo						local.set $g2));; (EmptyStatement) ;; (ExpressionStatement) di = b2 * 496 >> 8;; (AssignmentExpression) di = b2 * 496 >> 8;; (BinaryExpression) b2 * 496 >> 8;; (BinaryExpression) b2 * 496;; (JSIdentifier) b2						local.get $b2;; (JSLiteral) 496						i32.const 496						i32.mul;; (JSLiteral) 8						i32.const 8						i32.shr_s						local.set $di;; (ExpressionStatement) dmi = di & 15;; (AssignmentExpression) dmi = di & 15;; (BinaryExpression) di & 15;; (JSIdentifier) di						local.get $di;; (JSLiteral) 15						i32.const 15						i32.and						local.set $dmi;; (ExpressionStatement) dmo = di >> 4;; (AssignmentExpression) dmo = di >> 4;; (BinaryExpression) di >> 4;; (JSIdentifier) di						local.get $di;; (JSLiteral) 4						i32.const 4						i32.shr_s						local.set $dmo;; (IfStatement) if (dmv2 < dmi) {b2 = dmo + 1 } else {b2...;; (BinaryExpression) dmv2 < dmi;; (JSIdentifier) dmv2						local.get $dmv2;; (JSIdentifier) dmi						local.get $dmi						i32.lt_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) b2 = dmo + 1 ;; (ExpressionStatement) b2 = dmo + 1;; (AssignmentExpression) b2 = dmo + 1;; (BinaryExpression) dmo + 1;; (JSIdentifier) dmo						local.get $dmo;; (JSLiteral) 1						i32.const 1						i32.add						local.set $b2)						(else;; (BlockStatement) b2 = dmo ;; (ExpressionStatement) b2 = dmo;; (AssignmentExpression) b2 = dmo;; (JSIdentifier) dmo						local.get $dmo						local.set $b2));; (EmptyStatement) ;; (VariableDeclaration) var formPix = r1 << 10 | g1 << 5 | b1;; (VariableDeclarator) formPix = r1 << 10 | g1 << 5 | b1;; (BinaryExpression) r1 << 10 | g1 << 5 | b1;; (BinaryExpression) r1 << 10 | g1 << 5;; (BinaryExpression) r1 << 10;; (JSIdentifier) r1						local.get $r1;; (JSLiteral) 10						i32.const 10						i32.shl;; (BinaryExpression) g1 << 5;; (JSIdentifier) g1						local.get $g1;; (JSLiteral) 5						i32.const 5						i32.shl						i32.or;; (JSIdentifier) b1						local.get $b1						i32.or						local.set $formPix;; (IfStatement) if (formPix === 0) {formPix = 1};; (BinaryExpression) formPix === 0;; (JSIdentifier) formPix						local.get $formPix;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) formPix = 1;; (AssignmentExpression) formPix = 1;; (JSLiteral) 1						i32.const 1						local.set $formPix));; (ExpressionStatement) formPix = formPix << 16 | r2 << 10 | g2 ...;; (AssignmentExpression) formPix = formPix << 16 | r2 << 10 | g2 ...;; (BinaryExpression) formPix << 16 | r2 << 10 | g2 << 5 | b2;; (BinaryExpression) formPix << 16 | r2 << 10 | g2 << 5;; (BinaryExpression) formPix << 16 | r2 << 10;; (BinaryExpression) formPix << 16;; (JSIdentifier) formPix						local.get $formPix;; (JSLiteral) 16						i32.const 16						i32.shl;; (BinaryExpression) r2 << 10;; (JSIdentifier) r2						local.get $r2;; (JSLiteral) 10						i32.const 10						i32.shl						i32.or;; (BinaryExpression) g2 << 5;; (JSIdentifier) g2						local.get $g2;; (JSLiteral) 5						i32.const 5						i32.shl						i32.or;; (JSIdentifier) b2						local.get $b2						i32.or						local.set $formPix;; (IfStatement) if (formPix & 65535 === 0) {formPix = fo...;; (BinaryExpression) formPix & 65535 === 0;; (BinaryExpression) formPix & 65535;; (JSIdentifier) formPix						local.get $formPix;; (JSLiteral) 65535						i32.const 65535						i32.and;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) formPix = formPix | 1;; (AssignmentExpression) formPix = formPix | 1;; (BinaryExpression) formPix | 1;; (JSIdentifier) formPix						local.get $formPix;; (JSLiteral) 1						i32.const 1						i32.or						local.set $formPix));; (ExpressionStatement) formBits[i >> 3] = formPix;; (AssignmentExpression) formBits[i >> 3] = formPix						local.get $'formBits';; (BinaryExpression) i >> 3;; (JSIdentifier) i						local.get $i;; (JSLiteral) 3						i32.const 3						i32.shr_s;; (JSIdentifier) formPix						local.get $formPix						call $atPut;; (UpdateExpression) x++;; (JSIdentifier) x						local.get $x						i32.const 1						i32.add;; (BinaryExpression) x < width;; (JSIdentifier) x						local.get $x;; (JSIdentifier) width						local.get $width						i32.lt_u						i32.const 0						br_if $loop_2);; (UpdateExpression) y++;; (JSIdentifier) y						local.get $y						i32.const 1						i32.add;; (BinaryExpression) y < height;; (JSIdentifier) y						local.get $y;; (JSIdentifier) height						local.get $height						i32.lt_u						i32.const 0						br_if $loop_1));; (JSProperty) property: scratch_primitiveOpenURL -> fu...;; (FunctionExpression) function(argCount) { 	var url = this.sta...(func $scratch_primitiveOpenURL						(local $url i32)						(local $path i32)						(local $template i32)						(local $argCount i32)						(local $temp i32)												;; unwritable: (IfStatement) if (url == '') {return false}						;; unwritable: (IfStatement) if (/^\/SqueakJS\//.test(url)) {url = ur						;; unwritable: (ExpressionStatement) self.open(url, '_blank');; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: scratch_primitiveGetFolderPath...;; (FunctionExpression) function(argCount) { 	var index = this.s...(func $scratch_primitiveGetFolderPath						(local $path i32)						(local $temp i32)						(local $argCount i32)						(local $index i32)						;; (IfStatement) if (!this.success) {return false};; (UnaryExpression) !this.success;; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (SwitchStatement) switch (index) { case 1: path = '/' brea;; (IfStatement) if (!path) {return false};; (UnaryExpression) !path;; (JSIdentifier) path						local.get $path						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.vm.popNandPush(argCount + 1, this.m...;; (CallExpression) this.vm.popNandPush(argCount + 1, this.m...						local.get $vm;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeStString(this.filenameToSqueak(...						local.get $this;; (CallExpression) this.filenameToSqueak(path)						local.get $this;; (JSIdentifier) path						local.get $path						call $filenameToSqueak						call $makeStString						call $popNandPush;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: js_primitiveDoUnderstand -> fu...;; (FunctionExpression) function(argCount) { 	var rcvr = this.st...(func $js_primitiveDoUnderstand						(local $message i32)						(local $propName i32)						(local $stResult i32)						(local $temp i32)						(local $rcvr i32)						(local $selector i32)						(local $isGlobal i32)						(local $argCount i32)						(local $obj i32)						(local $jsResult i32)						(local $args i32)						(local $propValue i32)						(local $newArgs i32)						;; (TryStatement) an active TryStatement with properties: ...;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, stRes...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) stResult						local.get $stResult						call $popNandPushIfOK						return);; (JSProperty) property: js_primitiveAsString -> functi...;; (FunctionExpression) function(argCount) { 	var obj = this.js_...(func $js_primitiveAsString						(local $obj i32)						(local $argCount i32)						(local $temp i32)						;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, this....						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (CallExpression) this.makeStString(String(obj))						local.get $this;; (CallExpression) String(obj);; (JSIdentifier) obj						local.get $obj						call $String						call $makeStString						call $popNandPushIfOK						return);; (JSProperty) property: js_primitiveNewWithParameters ...;; (FunctionExpression) function(argCount) { 	var receiverOop = ...(func $js_primitiveNewWithParameters						(local $temp i32)						(local $result i32)						(local $receiverOop i32)						(local $resultOop i32)						(local $parametersOop i32)						(local $resultJS i32)						(local $argCount i32)						(local $parametersJS i32)						(local $receiverJS i32)						;; (TryStatement) an active TryStatement with properties: ...;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, resul...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) resultOop						local.get $resultOop						call $popNandPushIfOK						return);; (JSProperty) property: js_primitiveTypeof -> function...;; (FunctionExpression) function(argCount) { 	var obj = this.js_...(func $js_primitiveTypeof						(local $obj i32)						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.popNandPushIfOK(argCount + 1);; (JSProperty) property: js_primitiveAt -> function(arg...;; (FunctionExpression) function(argCount) { 	var rcvr = this.st...(func $js_primitiveAt						(local $propValue i32)						(local $rcvr i32)						(local $jsRcvr i32)						(local $jsPropName i32)						(local $argCount i32)						(local $propName i32)						(local $temp i32)						(local $jsPropValue i32)						;; (TryStatement) an active TryStatement with properties: ...;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, propV...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) propValue						local.get $propValue						call $popNandPushIfOK						return);; (JSProperty) property: js_primitiveAtPut -> function(...;; (FunctionExpression) function(argCount) { 	var rcvr = this.st...(func $js_primitiveAtPut						(local $propValue i32)						(local $rcvr i32)						(local $jsRcvr i32)						(local $jsPropName i32)						(local $argCount i32)						(local $propName i32)						(local $temp i32)						(local $jsPropValue i32)						;; (TryStatement) an active TryStatement with properties: ...;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, propV...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) propValue						local.get $propValue						call $popNandPushIfOK						return);; (JSProperty) property: js_primitiveSqueakAsJSObject -...;; (FunctionExpression) function(argCount) { 	var rcvr = this.st...(func $js_primitiveSqueakAsJSObject						(local $rcvr i32)						(local $temp i32)						(local $argCount i32)						(local $arg i32)						;; (IfStatement) if (this.success) {rcvr.jsObject = arg};; (StaticMemberExpression) this.success;; (JSIdentifier) success						local.get $success						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) rcvr.jsObject = arg;; (AssignmentExpression) rcvr.jsObject = arg;; (JSIdentifier) arg						local.get $arg						local.set $jsObject));; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: js_primitiveInitCallbacks -> f...;; (FunctionExpression) function(argCount) { 	this.js_callbackSe...(func $js_primitiveInitCallbacks						(local $argCount i32)						(local $temp i32)						;; (ExpressionStatement) this.js_callbackSema = this.stackInteger...;; (AssignmentExpression) this.js_callbackSema = this.stackInteger...;; (CallExpression) this.stackInteger(0)						local.get $this;; (JSLiteral) 0						i32.const 0						call $stackInteger						local.set $js_callbackSema;; (ExpressionStatement) this.js_activeCallback = nil;; (AssignmentExpression) this.js_activeCallback = nil;; (JSLiteral) nil						i32.const 0						local.set $js_activeCallback;; (ReturnStatement) return this.popNIfOK(argCount);; (CallExpression) this.popNIfOK(argCount)						local.get $this;; (JSIdentifier) argCount						local.get $argCount						call $popNIfOK						return);; (JSProperty) property: js_primitiveGetActiveCallbackB...;; (FunctionExpression) function(argCount) { 	var callback = thi...(func $js_primitiveGetActiveCallbackBlock						(local $temp i32)						(local $argCount i32)						(local $callback i32)												;; unwritable: (IfStatement) if (!callback) {return this.js_setError(;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, callb...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (StaticMemberExpression) callback.block;; (JSIdentifier) block						local.get $block						call $popNandPushIfOK						return);; (JSProperty) property: js_primitiveGetActiveCallbackA...;; (FunctionExpression) function(argCount) { 	var proxyClass = t...(func $js_primitiveGetActiveCallbackArgs						(local $array i32)						(local $callback i32)						(local $argCount i32)						(local $proxyClass i32)						(local $temp i32)												;; unwritable: (IfStatement) if (!callback) {return this.js_setError(;; (TryStatement) an active TryStatement with properties: ...);; (JSProperty) property: js_primitiveReturnFromCallback...;; (FunctionExpression) function(argCount) { 	if (argCount !== 1...(func $js_primitiveReturnFromCallback						(local $argCount i32)						(local $temp i32)						;; (IfStatement) if (argCount !== 1) {return false};; (BinaryExpression) argCount !== 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (IfStatement) if (!this.js_activeCallback) {return thi;; (ExpressionStatement) this.js_activeCallback.result = this.vm....;; (AssignmentExpression) this.js_activeCallback.result = this.vm....;; (CallExpression) this.vm.pop()						local.get $vm						call $pop						local.set $result;; (ExpressionStatement) this.vm.breakOut();; (CallExpression) this.vm.breakOut()						local.get $vm						call $breakOut;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: js_primitiveGetError -> functi...;; (FunctionExpression) function(argCount) { 	var error = this.m...(func $js_primitiveGetError						(local $temp i32)						(local $argCount i32)						(local $error i32)						;; (ExpressionStatement) this.js_error = nil;; (AssignmentExpression) this.js_error = nil;; (JSLiteral) nil						i32.const 0						local.set $js_error;; (ReturnStatement) return this.popNandPushIfOK(argCount + 1...;; (CallExpression) this.popNandPushIfOK(argCount + 1, error...						local.get $this;; (BinaryExpression) argCount + 1;; (JSIdentifier) argCount						local.get $argCount;; (JSLiteral) 1						i32.const 1						i32.add;; (JSIdentifier) error						local.get $error						call $popNandPushIfOK						return);; (JSProperty) property: js_setError -> function(err) {...;; (FunctionExpression) function(err) { 	this.js_error = String(...(func $js_setError						(local $err i32)						(local $temp i32)						;; (ExpressionStatement) this.js_error = String(err);; (AssignmentExpression) this.js_error = String(err);; (CallExpression) String(err);; (JSIdentifier) err						local.get $err						call $String						local.set $js_error;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: js_fromStObject -> function(ob...;; (FunctionExpression) function(obj) { 	if (typeof obj === 'num...(func $js_fromStObject						(local $obj i32)						(local $temp i32)												;; unwritable: (IfStatement) if (typeof obj === 'number') {return obj;; (IfStatement) if (obj.jsObject) {return obj.jsObject};; (StaticMemberExpression) obj.jsObject;; (JSIdentifier) jsObject						local.get $jsObject						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return obj.jsObject;; (StaticMemberExpression) obj.jsObject;; (JSIdentifier) jsObject						local.get $jsObject						return));; (IfStatement) if (obj.isFloat) {return obj.float};; (StaticMemberExpression) obj.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return obj.float;; (StaticMemberExpression) obj.float;; (JSIdentifier) float						local.get $float						return));; (IfStatement) if (obj.isNil) {return nil};; (StaticMemberExpression) obj.isNil;; (JSIdentifier) isNil						local.get $isNil						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return nil;; (JSLiteral) nil						i32.const 0						return));; (IfStatement) if (obj.isTrue) {return true};; (StaticMemberExpression) obj.isTrue;; (JSIdentifier) isTrue						local.get $isTrue						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return));; (IfStatement) if (obj.isFalse) {return false};; (StaticMemberExpression) obj.isFalse;; (JSIdentifier) isFalse						local.get $isFalse						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (IfStatement) if (obj.bytes || obj.sqClass === this.vm...;; (BinaryExpression) obj.bytes || obj.sqClass === this.vm.spe...;; (StaticMemberExpression) obj.bytes;; (JSIdentifier) bytes						local.get $bytes;; (BinaryExpression) obj.sqClass === this.vm.specialObjects[S...;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassString;; (JSIdentifier) splOb_ClassString						local.get $splOb_ClassString						i32.const 4						i32.mul						i32.add						i32.eq						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return obj.bytesAsString();; (CallExpression) obj.bytesAsString()						local.get $obj						call $bytesAsString						return))						;; unwritable: (IfStatement) if (obj.sqClass === this.vm.specialObjec;; (IfStatement) if (obj.sqClass === this.vm.specialObjec...;; (BinaryExpression) obj.sqClass === this.vm.specialObjects[S...;; (BinaryExpression) obj.sqClass === this.vm.specialObjects[S...;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassBlockContext;; (JSIdentifier) splOb_ClassBlockContext						local.get $splOb_ClassBlockContext						i32.const 4						i32.mul						i32.add						i32.eq;; (BinaryExpression) obj.sqClass === this.vm.specialObjects[S...;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassBlockClosure;; (JSIdentifier) splOb_ClassBlockClosure						local.get $splOb_ClassBlockClosure						i32.const 4						i32.mul						i32.add						i32.eq						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.js_fromStBlock(obj);; (CallExpression) this.js_fromStBlock(obj)						local.get $this;; (JSIdentifier) obj						local.get $obj						call $js_fromStBlock						return));; (ThrowStatement) throw Error('asJSArgument needed for ' +...						unreachable);; (JSProperty) property: js_fromStArray -> function(obj...;; (FunctionExpression) function(objs, maybeDict) { 	var result ...(func $js_fromStArray						(local $i i32)						(local $temp i32)						(local $objs i32)						(local $maybeDict i32)						(local $result i32)						(local $jsArray i32)												;; unwritable: (IfStatement) if (objs.length > 0 && maybeDict && this;; (ReturnStatement) return result;; (JSIdentifier) result						local.get $result						return);; (JSProperty) property: js_fromStDict -> function(objs...;; (FunctionExpression) function(objs) { 	var jsDict = {} for (v...(func $js_fromStDict						(local $jsKey i32)						(local $jsDict i32)						(local $i i32)						(local $temp i32)						(local $assoc i32)						(local $objs i32)						(local $jsValue i32)						;; (ForStatement) for (var i = 0; i < objs.length; i++) {v...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (BlockStatement) var assoc = objs[i].pointers if (!assoc ...;; (VariableDeclaration) var assoc = objs[i].pointers;; (VariableDeclarator) assoc = objs[i].pointers;; (StaticMemberExpression) objs[i].pointers;; (JSIdentifier) pointers						local.get $pointers						local.set $assoc;; (IfStatement) if (!assoc || assoc.length !== 2) {throw...;; (BinaryExpression) !assoc || assoc.length !== 2;; (UnaryExpression) !assoc;; (JSIdentifier) assoc						local.get $assoc						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (BinaryExpression) assoc.length !== 2;; (StaticMemberExpression) assoc.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 2						i32.const 2						i32.ne						i32.or						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error(assoc + ' is not an Associat...						unreachable));; (VariableDeclaration) var jsKey = this.js_fromStObject(assoc[0...;; (VariableDeclarator) jsKey = this.js_fromStObject(assoc[0]);; (CallExpression) this.js_fromStObject(assoc[0])						local.get $this;; (ComputedMemberExpression) assoc[0];; (JSIdentifier) assoc						local.get $assoc;; (JSLiteral) 0						i32.const 0						i32.const 4						i32.mul						i32.add						call $js_fromStObject						local.set $jsKey;; (VariableDeclarator) jsValue = this.js_fromStObject(assoc[1]);; (CallExpression) this.js_fromStObject(assoc[1])						local.get $this;; (ComputedMemberExpression) assoc[1];; (JSIdentifier) assoc						local.get $assoc;; (JSLiteral) 1						i32.const 1						i32.const 4						i32.mul						i32.add						call $js_fromStObject						local.set $jsValue;; (ExpressionStatement) jsDict[jsKey] = jsValue;; (AssignmentExpression) jsDict[jsKey] = jsValue						local.get $'jsDict';; (JSIdentifier) jsKey						local.get $jsKey;; (JSIdentifier) jsValue						local.get $jsValue						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < objs.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) objs.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return jsDict;; (JSIdentifier) jsDict						local.get $jsDict						return);; (JSProperty) property: js_fromStBlock -> function(blo...;; (FunctionExpression) function(block) { 	var numArgs if (!this...(func $js_fromStBlock						(local $squeak i32)						(local $block i32)						(local $temp i32)						(local $numArgs i32)						;; (IfStatement) if (!this.js_callbackSema) {throw Error(...;; (UnaryExpression) !this.js_callbackSema;; (StaticMemberExpression) this.js_callbackSema;; (JSIdentifier) js_callbackSema						local.get $js_callbackSema						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('CallbackSemaphore not set')						unreachable));; (ExpressionStatement) this.vm.reclaimableContextCount = 0;; (AssignmentExpression) this.vm.reclaimableContextCount = 0;; (JSLiteral) 0						i32.const 0						local.set $reclaimableContextCount;; (IfStatement) if (block.sqClass === SqueakJS.vm.specia...;; (BinaryExpression) block.sqClass === SqueakJS.vm.specialObj...;; (StaticMemberExpression) block.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) SqueakJS.vm.specialObjects[Squeak.splOb_...;; (StaticMemberExpression) SqueakJS.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassBlockContext;; (JSIdentifier) splOb_ClassBlockContext						local.get $splOb_ClassBlockContext						i32.const 4						i32.mul						i32.add						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) numArgs = block.pointers[Squeak.BlockCon...;; (ExpressionStatement) numArgs = block.pointers[Squeak.BlockCon...;; (AssignmentExpression) numArgs = block.pointers[Squeak.BlockCon...;; (ComputedMemberExpression) block.pointers[Squeak.BlockContext_argum...;; (StaticMemberExpression) block.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.BlockContext_argumentCount;; (JSIdentifier) BlockContext_argumentCount						local.get $BlockContext_argumentCount						i32.const 4						i32.mul						i32.add						local.set $numArgs)						(else;; (BlockStatement) numArgs = block.pointers[Squeak.Closure_...;; (ExpressionStatement) numArgs = block.pointers[Squeak.Closure_...;; (AssignmentExpression) numArgs = block.pointers[Squeak.Closure_...;; (ComputedMemberExpression) block.pointers[Squeak.Closure_numArgs];; (StaticMemberExpression) block.pointers;; (JSIdentifier) pointers						local.get $pointers;; (StaticMemberExpression) Squeak.Closure_numArgs;; (JSIdentifier) Closure_numArgs						local.get $Closure_numArgs						i32.const 4						i32.mul						i32.add						local.set $numArgs));; (ReturnStatement) return function() { 	var args = [] for (...;; (FunctionExpression) function() { 	var args = [] for (var i =...(func $evalSqueakBlock						(local $temp i32)						(local $args i32)						(local $i i32)						;; (ForStatement) for (var i = 0; i < numArgs; i++) {args....;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (ExpressionStatement) args.push(arguments[i]);; (CallExpression) args.push(arguments[i])						local.get $args;; (ComputedMemberExpression) arguments[i];; (JSIdentifier) arguments						local.get $arguments;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						call $push;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < numArgs;; (JSIdentifier) i						local.get $i;; (JSIdentifier) numArgs						local.get $numArgs						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return new Promise(function(resolve, rej...;; (NewExpression) new Promise(function(resolve, reject) { ...						unreachable						return)						return);; (JSProperty) property: js_executeCallbackAsync -> fun...;; (FunctionExpression) function(block, args, resolve, reject) {...(func $js_executeCallbackAsync						(local $reject i32)						(local $squeak i32)						(local $block i32)						(local $resolve i32)						(local $temp i32)						(local $args i32);; (FunctionDeclaration) function again() {squeak.js_executeCallb...;; (FunctionExpression) function() { 	squeak.js_executeCallbackA...(func $again	(local $temp i32)	;; (ExpressionStatement) squeak.js_executeCallbackAsync(block, ar...;; (CallExpression) squeak.js_executeCallbackAsync(block, ar...						local.get $squeak;; (JSIdentifier) block						local.get $block;; (JSIdentifier) args						local.get $args;; (JSIdentifier) resolve						local.get $resolve;; (JSIdentifier) reject						local.get $reject						call $js_executeCallbackAsync)						;; (IfStatement) if (!this.js_activeCallback && !this.vm....;; (BinaryExpression) !this.js_activeCallback && !this.vm.froz...;; (UnaryExpression) !this.js_activeCallback;; (StaticMemberExpression) this.js_activeCallback;; (JSIdentifier) js_activeCallback						local.get $js_activeCallback						local.set $temp						i32.const -1						local.get $temp						i32.sub;; (UnaryExpression) !this.vm.frozen;; (StaticMemberExpression) this.vm.frozen;; (JSIdentifier) frozen						local.get $frozen						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.and						i32.const 0						i32.ne						(if (then;; (BlockStatement) this.js_executeCallback(block, args, res...;; (ExpressionStatement) this.js_executeCallback(block, args, res...;; (CallExpression) this.js_executeCallback(block, args, res...						local.get $this;; (JSIdentifier) block						local.get $block;; (JSIdentifier) args						local.get $args;; (JSIdentifier) resolve						local.get $resolve;; (JSIdentifier) reject						local.get $reject						call $js_executeCallback)						(else;; (BlockStatement) setTimeout(again, 0) ;; (ExpressionStatement) setTimeout(again, 0);; (CallExpression) setTimeout(again, 0);; (JSIdentifier) again						local.get $again;; (JSLiteral) 0						i32.const 0						call $setTimeout)));; (JSProperty) property: js_executeCallback -> function...;; (FunctionExpression) function(block, args, resolve, reject) {...(func $js_executeCallback						(local $reject i32)						(local $block i32)						(local $resolve i32)						(local $timeout i32)						(local $temp i32)						(local $result i32)						(local $args i32)												;; unwritable: (IfStatement) if (this.js_activeCallback) {return cons;; (ExpressionStatement) this.js_activeCallback = {property: bloc...;; (AssignmentExpression) this.js_activeCallback = {property: bloc...;; (ObjectExpression) {property: block -> block, property: arg...						local.set $js_activeCallback;; (ExpressionStatement) this.signalSemaphoreWithIndex(this.js_ca...;; (CallExpression) this.signalSemaphoreWithIndex(this.js_ca...						local.get $this;; (StaticMemberExpression) this.js_callbackSema;; (JSIdentifier) js_callbackSema						local.get $js_callbackSema						call $signalSemaphoreWithIndex;; (ExpressionStatement) this.vm.forceInterruptCheck();; (CallExpression) this.vm.forceInterruptCheck()						local.get $vm						call $forceInterruptCheck						;; unwritable: (WhileStatement) while (Date.now() < timeout && !this.js_;; (IfStatement) if (!result) {timeout = timeout + 1 };; (UnaryExpression) !result;; (JSIdentifier) result						local.get $result						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (BlockStatement) timeout = timeout + 1 ;; (ExpressionStatement) timeout = timeout + 1;; (AssignmentExpression) timeout = timeout + 1;; (BinaryExpression) timeout + 1;; (JSIdentifier) timeout						local.get $timeout;; (JSLiteral) 1						i32.const 1						i32.add						local.set $timeout));; (ExpressionStatement) this.js_activeCallback = nil;; (AssignmentExpression) this.js_activeCallback = nil;; (JSLiteral) nil						i32.const 0						local.set $js_activeCallback						;; unwritable: (IfStatement) if (result) {an active TryStatement with);; (JSProperty) property: js_objectOrGlobal -> function(...;; (FunctionExpression) function(sqObject) { 	return 'jsObject' ...(func $js_objectOrGlobal						(local $sqObject i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return 'jsObject' in sqObject ? sqObject);; (JSProperty) property: ffi_primitiveCalloutWithArgs -...;; (FunctionExpression) function(argCount) { 	var extLibFunc = t...(func $ffi_primitiveCalloutWithArgs						(local $argsObj i32)						(local $funcName i32)						(local $moduleName i32)						(local $extLibFunc i32)						(local $argCount i32)						(local $temp i32)						(local $args i32)						;; (IfStatement) if (!this.isKindOf(extLibFunc, Squeak.sp...;; (UnaryExpression) !this.isKindOf(extLibFunc, Squeak.splOb_...;; (CallExpression) this.isKindOf(extLibFunc, Squeak.splOb_C...						local.get $this;; (JSIdentifier) extLibFunc						local.get $extLibFunc;; (StaticMemberExpression) Squeak.splOb_ClassExternalFunction;; (JSIdentifier) splOb_ClassExternalFunction						local.get $splOb_ClassExternalFunction						call $isKindOf						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return))						;; unwritable: (ExpressionStatement) this.vm.warnOnce('FFI: ignoring ' + modu;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: ffi_primitiveFFIAllocate -> fu...;; (FunctionExpression) function(argCount) { 	var externalObject...(func $ffi_primitiveFFIAllocate						(local $temp i32)						(local $argCount i32)						(local $externalObject i32)						;; (ExpressionStatement) externalObject = this.instantiateClass(t...;; (AssignmentExpression) externalObject = this.instantiateClass(t...;; (CallExpression) this.instantiateClass(this.vm.specialObj...						local.get $this;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassExternalAddress;; (JSIdentifier) splOb_ClassExternalAddress						local.get $splOb_ClassExternalAddress						i32.const 4						i32.mul						i32.add;; (JSLiteral) 1						i32.const 1						call $instantiateClass						local.set $externalObject						;; unwritable: (ExpressionStatement) Squeak.ExternalObjects[Squeak.ExternalOb;; (ReturnStatement) return this.popNandPushIfOK(1, externalO...;; (CallExpression) this.popNandPushIfOK(1, externalObject)						local.get $this;; (JSLiteral) 1						i32.const 1;; (JSIdentifier) externalObject						local.get $externalObject						call $popNandPushIfOK						return);; (JSProperty) property: ffi_primitiveCalloutWithArgs -...;; (FunctionExpression) function(argCount) { 	var functionSpec =...(func $ffi_primitiveCalloutWithArgs						(local $functionName i32)						(local $functionSpec i32)						(local $argCount i32)						(local $temp i32)						(local $args i32)						;; (ForStatement) for (i = 3; i <= functionSpec.pointers[2...;; (AssignmentExpression) i = 3;; (JSLiteral) 3						i32.const 3						local.set $i						(loop $loop_1;; (BlockStatement) args.push(this.vm.stackValue(i)) ;; (ExpressionStatement) args.push(this.vm.stackValue(i));; (CallExpression) args.push(this.vm.stackValue(i))						local.get $args;; (CallExpression) this.vm.stackValue(i)						local.get $vm;; (JSIdentifier) i						local.get $i						call $stackValue						call $push;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i <= functionSpec.pointers[2].pointers.l...;; (JSIdentifier) i						local.get $i;; (BinaryExpression) functionSpec.pointers[2].pointers.length...;; (BinaryExpression) functionSpec.pointers[2].pointers.length...;; (StaticMemberExpression) functionSpec.pointers[2].pointers.length;; (JSIdentifier) length						local.get $length;; (JSLiteral) 1						i32.const 1						i32.sub;; (JSLiteral) 3						i32.const 3						i32.add						i32.le_u						i32.const 0						br_if $loop_1)						;; unwritable: (SwitchStatement) switch (functionName) { case 'memcpy': a);; (JSProperty) property: primitiveFloatArrayAt -> funct...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFloatArrayAt						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FloatArrayPl);; (JSProperty) property: primitiveFloatArrayMulFloatArr...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFloatArrayMulFloatArray						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FloatArrayPl);; (JSProperty) property: primitiveFloatArrayAddScalar -...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFloatArrayAddScalar						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FloatArrayPl);; (JSProperty) property: primitiveFloatArrayDivFloatArr...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFloatArrayDivFloatArray						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FloatArrayPl);; (JSProperty) property: primitiveFloatArrayDivScalar -...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFloatArrayDivScalar						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FloatArrayPl);; (JSProperty) property: primitiveFloatArrayHash -> fun...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFloatArrayHash						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FloatArrayPl);; (JSProperty) property: primitiveFloatArrayAtPut -> fu...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFloatArrayAtPut						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FloatArrayPl);; (JSProperty) property: primitiveFloatArrayMulScalar -...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFloatArrayMulScalar						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FloatArrayPl);; (JSProperty) property: primitiveFloatArrayAddFloatArr...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFloatArrayAddFloatArray						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FloatArrayPl);; (JSProperty) property: primitiveFloatArraySubScalar -...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFloatArraySubScalar						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FloatArrayPl);; (JSProperty) property: primitiveFloatArraySubFloatArr...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFloatArraySubFloatArray						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FloatArrayPl);; (JSProperty) property: primitiveFloatArrayEqual -> fu...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFloatArrayEqual						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FloatArrayPl);; (JSProperty) property: primitiveFloatArrayDotProduct ...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFloatArrayDotProduct						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FloatArrayPl);; (JSProperty) property: m23PrimitiveInvertRectInto -> ...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $m23PrimitiveInvertRectInto						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('Matrix2x3Plu);; (JSProperty) property: m23PrimitiveTransformPoint -> ...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $m23PrimitiveTransformPoint						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('Matrix2x3Plu);; (JSProperty) property: m23PrimitiveIsPureTranslation ...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $m23PrimitiveIsPureTranslation						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('Matrix2x3Plu);; (JSProperty) property: m23PrimitiveComposeMatrix -> f...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $m23PrimitiveComposeMatrix						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('Matrix2x3Plu);; (JSProperty) property: m23PrimitiveTransformRectInto ...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $m23PrimitiveTransformRectInto						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('Matrix2x3Plu);; (JSProperty) property: m23PrimitiveIsIdentity -> func...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $m23PrimitiveIsIdentity						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('Matrix2x3Plu);; (JSProperty) property: m23PrimitiveInvertPoint -> fun...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $m23PrimitiveInvertPoint						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('Matrix2x3Plu);; (JSProperty) property: primitiveDeflateBlock -> funct...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveDeflateBlock						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('ZipPlugin', );; (JSProperty) property: primitiveDeflateUpdateHashTabl...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveDeflateUpdateHashTable						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('ZipPlugin', );; (JSProperty) property: primitiveUpdateGZipCrc32 -> fu...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveUpdateGZipCrc32						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('ZipPlugin', );; (JSProperty) property: primitiveInflateDecompressBloc...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveInflateDecompressBlock						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('ZipPlugin', );; (JSProperty) property: primitiveZipSendBlock -> funct...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveZipSendBlock						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('ZipPlugin', );; (JSProperty) property: primitiveFFTTransformData -> f...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFFTTransformData						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FFTPlugin', );; (JSProperty) property: primitiveFFTScaleData -> funct...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFFTScaleData						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FFTPlugin', );; (JSProperty) property: primitiveFFTPermuteData -> fun...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $primitiveFFTPermuteData						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('FFTPlugin', );; (JSProperty) property: gePrimitiveMergeFillFrom -> fu...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveMergeFillFrom						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveCopyBuffer -> funct...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveCopyBuffer						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveAddRect -> function...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveAddRect						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveAddGradientFill -> ...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveAddGradientFill						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveSetClipRect -> func...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveSetClipRect						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveSetBitBltPlugin -> ...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveSetBitBltPlugin						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveRegisterExternalEdg...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveRegisterExternalEdge						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveGetClipRect -> func...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveGetClipRect						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveAddBezier -> functi...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveAddBezier						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveInitializeProcessin...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveInitializeProcessing						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveRenderImage -> func...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveRenderImage						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveGetOffset -> functi...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveGetOffset						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveSetDepth -> functio...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveSetDepth						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveAddBezierShape -> f...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveAddBezierShape						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveSetEdgeTransform ->...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveSetEdgeTransform						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveGetTimes -> functio...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveGetTimes						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveNextActiveEdgeEntry...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveNextActiveEdgeEntry						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveAddBitmapFill -> fu...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveAddBitmapFill						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveGetDepth -> functio...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveGetDepth						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveAbortProcessing -> ...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveAbortProcessing						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveNextGlobalEdgeEntry...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveNextGlobalEdgeEntry						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveGetFailureReason ->...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveGetFailureReason						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveDisplaySpanBuffer -...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveDisplaySpanBuffer						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveGetCounts -> functi...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveGetCounts						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveChangedActiveEdgeEn...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveChangedActiveEdgeEntry						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveRenderScanline -> f...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveRenderScanline						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveGetBezierStats -> f...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveGetBezierStats						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveFinishedProcessing ...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveFinishedProcessing						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveNeedsFlush -> funct...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveNeedsFlush						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveAddLine -> function...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveAddLine						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveSetOffset -> functi...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveSetOffset						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveNextFillEntry -> fu...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveNextFillEntry						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveInitializeBuffer ->...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveInitializeBuffer						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveDoProfileStats -> f...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveDoProfileStats						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveAddActiveEdgeEntry ...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveAddActiveEdgeEntry						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveSetAALevel -> funct...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveSetAALevel						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveNeedsFlushPut -> fu...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveNeedsFlushPut						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveAddCompressedShape ...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveAddCompressedShape						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveSetColorTransform -...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveSetColorTransform						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveAddOval -> function...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveAddOval						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveRegisterExternalFil...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveRegisterExternalFill						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveAddPolygon -> funct...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveAddPolygon						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: gePrimitiveGetAALevel -> funct...;; (FunctionExpression) function(argCount) { 	return this.namedP...(func $gePrimitiveGetAALevel						(local $argCount i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return this.namedPrimitive('B2DPlugin', );; (JSProperty) property: VM_PROXY_MAJOR -> 1;; (JSProperty) property: VM_PROXY_MINOR -> 11;; (JSProperty) property: initialize -> function(vm) { 	...;; (FunctionExpression) function(vm) { 	this.vm = vm this.remapp...(func $initialize						(local $vm i32)						(local $temp i32)						;; (ExpressionStatement) this.vm = vm;; (AssignmentExpression) this.vm = vm;; (JSIdentifier) vm						local.get $vm						local.set $vm						;; unwritable: (ExpressionStatement) this.remappableOops = []						;; unwritable: (ExpressionStatement) Object.defineProperty(this, 'successFlag);; (JSProperty) property: majorVersion -> function() { 	...;; (FunctionExpression) function() { 	return this.VM_PROXY_MAJOR...(func $majorVersion						(local $temp i32)						;; (ReturnStatement) return this.VM_PROXY_MAJOR;; (StaticMemberExpression) this.VM_PROXY_MAJOR;; (JSIdentifier) VM_PROXY_MAJOR						local.get $VM_PROXY_MAJOR						return);; (JSProperty) property: minorVersion -> function() { 	...;; (FunctionExpression) function() { 	return this.VM_PROXY_MINOR...(func $minorVersion						(local $temp i32)						;; (ReturnStatement) return this.VM_PROXY_MINOR;; (StaticMemberExpression) this.VM_PROXY_MINOR;; (JSIdentifier) VM_PROXY_MINOR						local.get $VM_PROXY_MINOR						return);; (JSProperty) property: failed -> function() { 	return...;; (FunctionExpression) function() { 	return !this.successFlag }(func $failed						(local $temp i32)						;; (ReturnStatement) return !this.successFlag;; (UnaryExpression) !this.successFlag;; (StaticMemberExpression) this.successFlag;; (JSIdentifier) successFlag						local.get $successFlag						local.set $temp						i32.const -1						local.get $temp						i32.sub						return);; (JSProperty) property: primitiveFail -> function() { ...;; (FunctionExpression) function() { 	this.successFlag = false }(func $primitiveFail						(local $temp i32)						;; (ExpressionStatement) this.successFlag = false;; (AssignmentExpression) this.successFlag = false;; (JSLiteral) false						i32.const 0						local.set $successFlag);; (JSProperty) property: primitiveFailFor -> function(r...;; (FunctionExpression) function(reasonCode) { 	this.successFlag...(func $primitiveFailFor						(local $reasonCode i32)						(local $temp i32)						;; (ExpressionStatement) this.successFlag = false;; (AssignmentExpression) this.successFlag = false;; (JSLiteral) false						i32.const 0						local.set $successFlag);; (JSProperty) property: success -> function(boolean) {...;; (FunctionExpression) function(boolean) { 	if (!boolean) {this...(func $success						(local $boolean i32)						(local $temp i32)						;; (IfStatement) if (!boolean) {this.successFlag = false};; (UnaryExpression) !boolean;; (JSIdentifier) boolean						local.get $boolean						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.successFlag = false;; (AssignmentExpression) this.successFlag = false;; (JSLiteral) false						i32.const 0						local.set $successFlag)));; (JSProperty) property: pop -> function(n) { 	this.vm....;; (FunctionExpression) function(n) { 	this.vm.popN(n) }(func $pop						(local $temp i32)						(local $n i32)						;; (ExpressionStatement) this.vm.popN(n);; (CallExpression) this.vm.popN(n)						local.get $vm;; (JSIdentifier) n						local.get $n						call $popN);; (JSProperty) property: popthenPush -> function(n, obj...;; (FunctionExpression) function(n, obj) { 	this.vm.popNandPush(...(func $popthenPush						(local $obj i32)						(local $temp i32)						(local $n i32)						;; (ExpressionStatement) this.vm.popNandPush(n, obj);; (CallExpression) this.vm.popNandPush(n, obj)						local.get $vm;; (JSIdentifier) n						local.get $n;; (JSIdentifier) obj						local.get $obj						call $popNandPush);; (JSProperty) property: push -> function(obj) { 	this....;; (FunctionExpression) function(obj) { 	this.vm.push(obj) }(func $push						(local $obj i32)						(local $temp i32)						;; (ExpressionStatement) this.vm.push(obj);; (CallExpression) this.vm.push(obj)						local.get $vm;; (JSIdentifier) obj						local.get $obj						call $push);; (JSProperty) property: pushBool -> function(bool) { 	...;; (FunctionExpression) function(bool) { 	this.vm.push(bool ? th...(func $pushBool						(local $temp i32)						(local $bool i32)						;; (ExpressionStatement) this.vm.push(bool ? this.vm.trueObj : th...;; (CallExpression) this.vm.push(bool ? this.vm.trueObj : th...						local.get $vm;; (ConditionalExpression) bool ? this.vm.trueObj : this.vm.falseOb...;; (JSIdentifier) bool						local.get $bool						i32.const 1						i32.eq						(if (then;; (StaticMemberExpression) this.vm.trueObj;; (JSIdentifier) trueObj						local.get $trueObj)						(else;; (StaticMemberExpression) this.vm.falseObj;; (JSIdentifier) falseObj						local.get $falseObj						))						call $push);; (JSProperty) property: pushInteger -> function(int) {...;; (FunctionExpression) function(int) { 	this.vm.push(int) }(func $pushInteger						(local $int i32)						(local $temp i32)						;; (ExpressionStatement) this.vm.push(int);; (CallExpression) this.vm.push(int)						local.get $vm;; (JSIdentifier) int						local.get $int						call $push);; (JSProperty) property: pushFloat -> function(num) { 	...;; (FunctionExpression) function(num) { 	this.vm.push(this.float...(func $pushFloat						(local $num i32)						(local $temp i32)						;; (ExpressionStatement) this.vm.push(this.floatObjectOf(num));; (CallExpression) this.vm.push(this.floatObjectOf(num))						local.get $vm;; (CallExpression) this.floatObjectOf(num)						local.get $this;; (JSIdentifier) num						local.get $num						call $floatObjectOf						call $push);; (JSProperty) property: stackValue -> function(n) { 	r...;; (FunctionExpression) function(n) { 	return this.vm.stackValue...(func $stackValue						(local $temp i32)						(local $n i32)						;; (ReturnStatement) return this.vm.stackValue(n);; (CallExpression) this.vm.stackValue(n)						local.get $vm;; (JSIdentifier) n						local.get $n						call $stackValue						return);; (JSProperty) property: stackIntegerValue -> function(...;; (FunctionExpression) function(n) { 	var int = this.vm.stackVa...(func $stackIntegerValue						(local $temp i32)						(local $int i32)						(local $n i32)												;; unwritable: (IfStatement) if (typeof int === 'number') {return int;; (ExpressionStatement) this.successFlag = false;; (AssignmentExpression) this.successFlag = false;; (JSLiteral) false						i32.const 0						local.set $successFlag;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return);; (JSProperty) property: stackFloatValue -> function(n)...;; (FunctionExpression) function(n) { 	this.vm.success = true va...(func $stackFloatValue						(local $float i32)						(local $temp i32)						(local $n i32)						;; (ExpressionStatement) this.vm.success = true;; (AssignmentExpression) this.vm.success = true;; (JSLiteral) true						i32.const 1						local.set $success;; (IfStatement) if (this.vm.success) {return float};; (StaticMemberExpression) this.vm.success;; (JSIdentifier) success						local.get $success						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return float;; (JSIdentifier) float						local.get $float						return));; (ExpressionStatement) this.successFlag = false;; (AssignmentExpression) this.successFlag = false;; (JSLiteral) false						i32.const 0						local.set $successFlag;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return);; (JSProperty) property: stackObjectValue -> function(n...;; (FunctionExpression) function(n) { 	var obj = this.vm.stackVa...(func $stackObjectValue						(local $obj i32)						(local $temp i32)						(local $n i32)												;; unwritable: (IfStatement) if (typeof obj !== 'number') {return obj;; (ExpressionStatement) this.successFlag = false;; (AssignmentExpression) this.successFlag = false;; (JSLiteral) false						i32.const 0						local.set $successFlag;; (ReturnStatement) return this.vm.nilObj;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						return);; (JSProperty) property: stackBytes -> function(n) { 	v...;; (FunctionExpression) function(n) { 	var oop = this.vm.stackVa...(func $stackBytes						(local $temp i32)						(local $oop i32)						(local $n i32)						;; (IfStatement) if (oop.bytes) {return oop.bytes};; (StaticMemberExpression) oop.bytes;; (JSIdentifier) bytes						local.get $bytes						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return oop.bytes;; (StaticMemberExpression) oop.bytes;; (JSIdentifier) bytes						local.get $bytes						return))						;; unwritable: (IfStatement) if (typeof oop === 'number' || !oop.isBy						;; unwritable: (ReturnStatement) return []);; (JSProperty) property: stackWords -> function(n) { 	v...;; (FunctionExpression) function(n) { 	var oop = this.vm.stackVa...(func $stackWords						(local $temp i32)						(local $oop i32)						(local $n i32)						;; (IfStatement) if (oop.words) {return oop.words};; (StaticMemberExpression) oop.words;; (JSIdentifier) words						local.get $words						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return oop.words;; (StaticMemberExpression) oop.words;; (JSIdentifier) words						local.get $words						return))						;; unwritable: (IfStatement) if (typeof oop === 'number' || !oop.isWo						;; unwritable: (ReturnStatement) return []);; (JSProperty) property: stackInt32Array -> function(n)...;; (FunctionExpression) function(n) { 	var oop = this.vm.stackVa...(func $stackInt32Array						(local $temp i32)						(local $oop i32)						(local $n i32)						;; (IfStatement) if (oop.words) {return oop.wordsAsInt32A...;; (StaticMemberExpression) oop.words;; (JSIdentifier) words						local.get $words						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return oop.wordsAsInt32Array();; (CallExpression) oop.wordsAsInt32Array()						local.get $oop						call $wordsAsInt32Array						return))						;; unwritable: (IfStatement) if (typeof oop === 'number' || !oop.isWo						;; unwritable: (ReturnStatement) return []);; (JSProperty) property: stackInt16Array -> function(n)...;; (FunctionExpression) function(n) { 	var oop = this.vm.stackVa...(func $stackInt16Array						(local $temp i32)						(local $oop i32)						(local $n i32)						;; (IfStatement) if (oop.words) {return oop.wordsAsInt16A...;; (StaticMemberExpression) oop.words;; (JSIdentifier) words						local.get $words						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return oop.wordsAsInt16Array();; (CallExpression) oop.wordsAsInt16Array()						local.get $oop						call $wordsAsInt16Array						return))						;; unwritable: (IfStatement) if (typeof oop === 'number' || !oop.isWo						;; unwritable: (ReturnStatement) return []);; (JSProperty) property: stackUint16Array -> function(n...;; (FunctionExpression) function(n) { 	var oop = this.vm.stackVa...(func $stackUint16Array						(local $temp i32)						(local $oop i32)						(local $n i32)						;; (IfStatement) if (oop.words) {return oop.wordsAsUint16...;; (StaticMemberExpression) oop.words;; (JSIdentifier) words						local.get $words						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return oop.wordsAsUint16Array();; (CallExpression) oop.wordsAsUint16Array()						local.get $oop						call $wordsAsUint16Array						return))						;; unwritable: (IfStatement) if (typeof oop === 'number' || !oop.isWo						;; unwritable: (ReturnStatement) return []);; (JSProperty) property: isBytes -> function(obj) { 	re...;; (FunctionExpression) function(obj) { 	return typeof obj !== '...(func $isBytes						(local $obj i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return typeof obj !== 'number' && obj.is);; (JSProperty) property: isWords -> function(obj) { 	re...;; (FunctionExpression) function(obj) { 	return typeof obj !== '...(func $isWords						(local $obj i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return typeof obj !== 'number' && obj.is);; (JSProperty) property: isWordsOrBytes -> function(obj...;; (FunctionExpression) function(obj) { 	return typeof obj !== '...(func $isWordsOrBytes						(local $obj i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return typeof obj !== 'number' && obj.is);; (JSProperty) property: isPointers -> function(obj) { ...;; (FunctionExpression) function(obj) { 	return typeof obj !== '...(func $isPointers						(local $obj i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return typeof obj !== 'number' && obj.is);; (JSProperty) property: isIntegerValue -> function(obj...;; (FunctionExpression) function(obj) { 	return typeof obj === '...(func $isIntegerValue						(local $obj i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return typeof obj === 'number' && obj >=);; (JSProperty) property: isArray -> function(obj) { 	re...;; (FunctionExpression) function(obj) { 	return obj.sqClass === ...(func $isArray						(local $obj i32)						(local $temp i32)						;; (ReturnStatement) return obj.sqClass === this.vm.specialOb...;; (BinaryExpression) obj.sqClass === this.vm.specialObjects[S...;; (StaticMemberExpression) obj.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassArray;; (JSIdentifier) splOb_ClassArray						local.get $splOb_ClassArray						i32.const 4						i32.mul						i32.add						i32.eq						return);; (JSProperty) property: isMemberOf -> function(obj, cl...;; (FunctionExpression) function(obj, className) { 	var nameByte...(func $isMemberOf						(local $className i32)						(local $i i32)						(local $temp i32)						(local $obj i32)						(local $nameBytes i32)						;; (IfStatement) if (className.length !== nameBytes.lengt...;; (BinaryExpression) className.length !== nameBytes.length;; (StaticMemberExpression) className.length;; (JSIdentifier) length						local.get $length;; (StaticMemberExpression) nameBytes.length;; (JSIdentifier) length						local.get $length						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ForStatement) for (var i = 0; i < className.length; i+...;; (VariableDeclaration) var i = 0;; (VariableDeclarator) i = 0;; (JSLiteral) 0						i32.const 0						local.set $i						(loop $loop_1;; (IfStatement) if (className.charCodeAt(i) !== nameByte...;; (BinaryExpression) className.charCodeAt(i) !== nameBytes[i];; (CallExpression) className.charCodeAt(i)						local.get $className;; (JSIdentifier) i						local.get $i						call $charCodeAt;; (ComputedMemberExpression) nameBytes[i];; (JSIdentifier) nameBytes						local.get $nameBytes;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add						i32.ne						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < className.length;; (JSIdentifier) i						local.get $i;; (StaticMemberExpression) className.length;; (JSIdentifier) length						local.get $length						i32.lt_u						i32.const 0						br_if $loop_1);; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return);; (JSProperty) property: booleanValueOf -> function(obj...;; (FunctionExpression) function(obj) { 	if (obj.isTrue) {return...(func $booleanValueOf						(local $obj i32)						(local $temp i32)						;; (IfStatement) if (obj.isTrue) {return true};; (StaticMemberExpression) obj.isTrue;; (JSIdentifier) isTrue						local.get $isTrue						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return true;; (JSLiteral) true						i32.const 1						return));; (IfStatement) if (obj.isFalse) {return false};; (StaticMemberExpression) obj.isFalse;; (JSIdentifier) isFalse						local.get $isFalse						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return));; (ExpressionStatement) this.successFlag = false;; (AssignmentExpression) this.successFlag = false;; (JSLiteral) false						i32.const 0						local.set $successFlag;; (ReturnStatement) return false;; (JSLiteral) false						i32.const 0						return);; (JSProperty) property: positive32BitValueOf -> functi...;; (FunctionExpression) function(obj) { 	return this.vm.primHand...(func $positive32BitValueOf						(local $obj i32)						(local $temp i32)						;; (ReturnStatement) return this.vm.primHandler.positive32Bit...;; (CallExpression) this.vm.primHandler.positive32BitValueOf...						local.get $vm.primHandler;; (JSIdentifier) obj						local.get $obj						call $positive32BitValueOf						return);; (JSProperty) property: positive32BitIntegerFor -> fun...;; (FunctionExpression) function(int) { 	return this.vm.primHand...(func $positive32BitIntegerFor						(local $int i32)						(local $temp i32)						;; (ReturnStatement) return this.vm.primHandler.pos32BitIntFo...;; (CallExpression) this.vm.primHandler.pos32BitIntFor(int)						local.get $vm.primHandler;; (JSIdentifier) int						local.get $int						call $pos32BitIntFor						return);; (JSProperty) property: floatValueOf -> function(obj) ...;; (FunctionExpression) function(obj) { 	if (obj.isFloat) {retur...(func $floatValueOf						(local $obj i32)						(local $temp i32)						;; (IfStatement) if (obj.isFloat) {return obj.float};; (StaticMemberExpression) obj.isFloat;; (JSIdentifier) isFloat						local.get $isFloat						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return obj.float;; (StaticMemberExpression) obj.float;; (JSIdentifier) float						local.get $float						return));; (ExpressionStatement) this.successFlag = false;; (AssignmentExpression) this.successFlag = false;; (JSLiteral) false						i32.const 0						local.set $successFlag;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return);; (JSProperty) property: floatObjectOf -> function(num)...;; (FunctionExpression) function(num) { 	return this.vm.primHand...(func $floatObjectOf						(local $num i32)						(local $temp i32)						;; (ReturnStatement) return this.vm.primHandler.makeFloat(num...;; (CallExpression) this.vm.primHandler.makeFloat(num)						local.get $vm.primHandler;; (JSIdentifier) num						local.get $num						call $makeFloat						return);; (JSProperty) property: fetchPointerofObject -> functi...;; (FunctionExpression) function(n, obj) { 	return obj.pointers[...(func $fetchPointerofObject						(local $obj i32)						(local $temp i32)						(local $n i32)						;; (ReturnStatement) return obj.pointers[n];; (ComputedMemberExpression) obj.pointers[n];; (StaticMemberExpression) obj.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSIdentifier) n						local.get $n						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: fetchBytesofObject -> function...;; (FunctionExpression) function(n, obj) { 	var oop = obj.pointe...(func $fetchBytesofObject						(local $temp i32)						(local $n i32)						(local $obj i32)						(local $oop i32)						;; (IfStatement) if (oop.bytes) {return oop.bytes};; (StaticMemberExpression) oop.bytes;; (JSIdentifier) bytes						local.get $bytes						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return oop.bytes;; (StaticMemberExpression) oop.bytes;; (JSIdentifier) bytes						local.get $bytes						return));; (IfStatement) if (oop.words) {return oop.wordsAsUint8A...;; (StaticMemberExpression) oop.words;; (JSIdentifier) words						local.get $words						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return oop.wordsAsUint8Array();; (CallExpression) oop.wordsAsUint8Array()						local.get $oop						call $wordsAsUint8Array						return))						;; unwritable: (IfStatement) if (typeof oop === 'number' || !oop.isWo						;; unwritable: (ReturnStatement) return []);; (JSProperty) property: fetchWordsofObject -> function...;; (FunctionExpression) function(n, obj) { 	var oop = obj.pointe...(func $fetchWordsofObject						(local $temp i32)						(local $n i32)						(local $obj i32)						(local $oop i32)						;; (IfStatement) if (oop.words) {return oop.words};; (StaticMemberExpression) oop.words;; (JSIdentifier) words						local.get $words						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return oop.words;; (StaticMemberExpression) oop.words;; (JSIdentifier) words						local.get $words						return))						;; unwritable: (IfStatement) if (typeof oop === 'number' || !oop.isWo						;; unwritable: (ReturnStatement) return []);; (JSProperty) property: fetchInt32ArrayofObject -> fun...;; (FunctionExpression) function(n, obj) { 	var oop = obj.pointe...(func $fetchInt32ArrayofObject						(local $temp i32)						(local $n i32)						(local $obj i32)						(local $oop i32)						;; (IfStatement) if (oop.words) {return oop.wordsAsInt32A...;; (StaticMemberExpression) oop.words;; (JSIdentifier) words						local.get $words						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return oop.wordsAsInt32Array();; (CallExpression) oop.wordsAsInt32Array()						local.get $oop						call $wordsAsInt32Array						return))						;; unwritable: (IfStatement) if (typeof oop === 'number' || !oop.isWo						;; unwritable: (ReturnStatement) return []);; (JSProperty) property: fetchInt16ArrayofObject -> fun...;; (FunctionExpression) function(n, obj) { 	var oop = obj.pointe...(func $fetchInt16ArrayofObject						(local $temp i32)						(local $n i32)						(local $obj i32)						(local $oop i32)						;; (IfStatement) if (oop.words) {return oop.wordsAsInt16A...;; (StaticMemberExpression) oop.words;; (JSIdentifier) words						local.get $words						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return oop.wordsAsInt16Array();; (CallExpression) oop.wordsAsInt16Array()						local.get $oop						call $wordsAsInt16Array						return))						;; unwritable: (IfStatement) if (typeof oop === 'number' || !oop.isWo						;; unwritable: (ReturnStatement) return []);; (JSProperty) property: fetchUint16ArrayofObject -> fu...;; (FunctionExpression) function(n, obj) { 	var oop = obj.pointe...(func $fetchUint16ArrayofObject						(local $temp i32)						(local $n i32)						(local $obj i32)						(local $oop i32)						;; (IfStatement) if (oop.words) {return oop.wordsAsUint16...;; (StaticMemberExpression) oop.words;; (JSIdentifier) words						local.get $words						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return oop.wordsAsUint16Array();; (CallExpression) oop.wordsAsUint16Array()						local.get $oop						call $wordsAsUint16Array						return))						;; unwritable: (IfStatement) if (typeof oop === 'number' || !oop.isWo						;; unwritable: (ReturnStatement) return []);; (JSProperty) property: fetchIntegerofObject -> functi...;; (FunctionExpression) function(n, obj) { 	var int = obj.pointe...(func $fetchIntegerofObject						(local $temp i32)						(local $n i32)						(local $obj i32)						(local $int i32)												;; unwritable: (IfStatement) if (typeof int === 'number') {return int;; (ExpressionStatement) this.successFlag = false;; (AssignmentExpression) this.successFlag = false;; (JSLiteral) false						i32.const 0						local.set $successFlag;; (ReturnStatement) return 0;; (JSLiteral) 0						i32.const 0						return);; (JSProperty) property: fetchLong32ofObject -> functio...;; (FunctionExpression) function(n, obj) { 	return obj.words[n] ...(func $fetchLong32ofObject						(local $obj i32)						(local $temp i32)						(local $n i32)						;; (ReturnStatement) return obj.words[n];; (ComputedMemberExpression) obj.words[n];; (StaticMemberExpression) obj.words;; (JSIdentifier) words						local.get $words;; (JSIdentifier) n						local.get $n						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: fetchFloatofObject -> function...;; (FunctionExpression) function(n, obj) { 	return this.floatVal...(func $fetchFloatofObject						(local $obj i32)						(local $temp i32)						(local $n i32)						;; (ReturnStatement) return this.floatValueOf(obj.pointers[n]...;; (CallExpression) this.floatValueOf(obj.pointers[n])						local.get $this;; (ComputedMemberExpression) obj.pointers[n];; (StaticMemberExpression) obj.pointers;; (JSIdentifier) pointers						local.get $pointers;; (JSIdentifier) n						local.get $n						i32.const 4						i32.mul						i32.add						call $floatValueOf						return);; (JSProperty) property: storeIntegerofObjectwithValue ...;; (FunctionExpression) function(n, obj, value) { 	if (typeof va...(func $storeIntegerofObjectwithValue						(local $value i32)						(local $temp i32)						(local $n i32)						(local $obj i32)												;; unwritable: (IfStatement) if (typeof value === 'number') {obj.poin);; (JSProperty) property: storePointerofObjectwithValue ...;; (FunctionExpression) function(n, obj, value) { 	obj.pointers[...(func $storePointerofObjectwithValue						(local $value i32)						(local $temp i32)						(local $n i32)						(local $obj i32)						;; (ExpressionStatement) obj.pointers[n] = value;; (AssignmentExpression) obj.pointers[n] = value						local.get $obj;; (JSIdentifier) n						local.get $n;; (JSIdentifier) value						local.get $value						call $atPut);; (JSProperty) property: stObjectatput -> function(arra...;; (FunctionExpression) function(array, index, obj) { 	if (array...(func $stObjectatput						(local $array i32)						(local $temp i32)						(local $index i32)						(local $obj i32)						;; (IfStatement) if (array.sqClass !== this.classArray())...;; (BinaryExpression) array.sqClass !== this.classArray();; (StaticMemberExpression) array.sqClass;; (JSIdentifier) sqClass						local.get $sqClass;; (CallExpression) this.classArray()						local.get $this						call $classArray						i32.ne						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('Array expected')						unreachable));; (IfStatement) if (index < 1 || index >= array.pointers...;; (BinaryExpression) index < 1 || index >= array.pointers.len...;; (BinaryExpression) index < 1;; (JSIdentifier) index						local.get $index;; (JSLiteral) 1						i32.const 1						i32.lt_u;; (BinaryExpression) index >= array.pointers.length;; (JSIdentifier) index						local.get $index;; (StaticMemberExpression) array.pointers.length;; (JSIdentifier) length						local.get $length						i32.ge_u						i32.or						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.successFlag = false;; (AssignmentExpression) this.successFlag = false;; (JSLiteral) false						i32.const 0						local.set $successFlag						return));; (ExpressionStatement) array.pointers[index] = obj;; (AssignmentExpression) array.pointers[index] = obj						local.get $array;; (JSIdentifier) index						local.get $index;; (JSIdentifier) obj						local.get $obj						call $atPut);; (JSProperty) property: isKindOfInteger -> function(ob...;; (FunctionExpression) function(obj) { 	return typeof obj === '...(func $isKindOfInteger						(local $obj i32)						(local $temp i32)												;; unwritable: (ReturnStatement) return typeof obj === 'number' || obj.sq);; (JSProperty) property: classArray -> function() { 	re...;; (FunctionExpression) function() { 	return this.vm.specialObje...(func $classArray						(local $temp i32)						;; (ReturnStatement) return this.vm.specialObjects[Squeak.spl...;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassArray;; (JSIdentifier) splOb_ClassArray						local.get $splOb_ClassArray						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: classBitmap -> function() { 	r...;; (FunctionExpression) function() { 	return this.vm.specialObje...(func $classBitmap						(local $temp i32)						;; (ReturnStatement) return this.vm.specialObjects[Squeak.spl...;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassBitmap;; (JSIdentifier) splOb_ClassBitmap						local.get $splOb_ClassBitmap						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: classSmallInteger -> function(...;; (FunctionExpression) function() { 	return this.vm.specialObje...(func $classSmallInteger						(local $temp i32)						;; (ReturnStatement) return this.vm.specialObjects[Squeak.spl...;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassInteger;; (JSIdentifier) splOb_ClassInteger						local.get $splOb_ClassInteger						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: classLargePositiveInteger -> f...;; (FunctionExpression) function() { 	return this.vm.specialObje...(func $classLargePositiveInteger						(local $temp i32)						;; (ReturnStatement) return this.vm.specialObjects[Squeak.spl...;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassLargePositiveInteger;; (JSIdentifier) splOb_ClassLargePositiveInteger						local.get $splOb_ClassLargePositiveInteger						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: classLargeNegativeInteger -> f...;; (FunctionExpression) function() { 	return this.vm.specialObje...(func $classLargeNegativeInteger						(local $temp i32)						;; (ReturnStatement) return this.vm.specialObjects[Squeak.spl...;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassLargeNegativeInteger;; (JSIdentifier) splOb_ClassLargeNegativeInteger						local.get $splOb_ClassLargeNegativeInteger						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: classPoint -> function() { 	re...;; (FunctionExpression) function() { 	return this.vm.specialObje...(func $classPoint						(local $temp i32)						;; (ReturnStatement) return this.vm.specialObjects[Squeak.spl...;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassPoint;; (JSIdentifier) splOb_ClassPoint						local.get $splOb_ClassPoint						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: classString -> function() { 	r...;; (FunctionExpression) function() { 	return this.vm.specialObje...(func $classString						(local $temp i32)						;; (ReturnStatement) return this.vm.specialObjects[Squeak.spl...;; (ComputedMemberExpression) this.vm.specialObjects[Squeak.splOb_Clas...;; (StaticMemberExpression) this.vm.specialObjects;; (JSIdentifier) specialObjects						local.get $specialObjects;; (StaticMemberExpression) Squeak.splOb_ClassString;; (JSIdentifier) splOb_ClassString						local.get $splOb_ClassString						i32.const 4						i32.mul						i32.add						return);; (JSProperty) property: nilObject -> function() { 	ret...;; (FunctionExpression) function() { 	return this.vm.nilObj }(func $nilObject						(local $temp i32)						;; (ReturnStatement) return this.vm.nilObj;; (StaticMemberExpression) this.vm.nilObj;; (JSIdentifier) nilObj						local.get $nilObj						return);; (JSProperty) property: falseObject -> function() { 	r...;; (FunctionExpression) function() { 	return this.vm.falseObj }(func $falseObject						(local $temp i32)						;; (ReturnStatement) return this.vm.falseObj;; (StaticMemberExpression) this.vm.falseObj;; (JSIdentifier) falseObj						local.get $falseObj						return);; (JSProperty) property: trueObject -> function() { 	re...;; (FunctionExpression) function() { 	return this.vm.trueObj }(func $trueObject						(local $temp i32)						;; (ReturnStatement) return this.vm.trueObj;; (StaticMemberExpression) this.vm.trueObj;; (JSIdentifier) trueObj						local.get $trueObj						return);; (JSProperty) property: instantiateClassindexableSize ...;; (FunctionExpression) function(aClass, indexableSize) { 	retur...(func $instantiateClassindexableSize						(local $indexableSize i32)						(local $aClass i32)						(local $temp i32)						;; (ReturnStatement) return this.vm.instantiateClass(aClass, ...;; (CallExpression) this.vm.instantiateClass(aClass, indexab...						local.get $vm;; (JSIdentifier) aClass						local.get $aClass;; (JSIdentifier) indexableSize						local.get $indexableSize						call $instantiateClass						return);; (JSProperty) property: methodArgumentCount -> functio...;; (FunctionExpression) function() { 	return this.argCount }(func $methodArgumentCount						(local $temp i32)						;; (ReturnStatement) return this.argCount;; (StaticMemberExpression) this.argCount;; (JSIdentifier) argCount						local.get $argCount						return);; (JSProperty) property: yourself -> function() { 	retu...;; (FunctionExpression) function() { 	return this }(func $yourself						(local $temp i32)						;; (ReturnStatement) return this;; (ThisExpression) this						return);; (JSProperty) property: makePointwithxValueyValue -> f...;; (FunctionExpression) function(x, y) { 	return this.vm.primHan...(func $makePointwithxValueyValue						(local $y i32)						(local $temp i32)						(local $x i32)						;; (ReturnStatement) return this.vm.primHandler.makePointWith...;; (CallExpression) this.vm.primHandler.makePointWithXandY(x...						local.get $vm.primHandler;; (JSIdentifier) x						local.get $x;; (JSIdentifier) y						local.get $y						call $makePointWithXandY						return);; (JSProperty) property: pushRemappableOop -> function(...;; (FunctionExpression) function(obj) { 	this.remappableOops.pus...(func $pushRemappableOop						(local $obj i32)						(local $temp i32)						;; (ExpressionStatement) this.remappableOops.push(obj);; (CallExpression) this.remappableOops.push(obj)						local.get $remappableOops;; (JSIdentifier) obj						local.get $obj						call $push);; (JSProperty) property: popRemappableOop -> function()...;; (FunctionExpression) function() { 	return this.remappableOops...(func $popRemappableOop						(local $temp i32)						;; (ReturnStatement) return this.remappableOops.pop();; (CallExpression) this.remappableOops.pop()						local.get $remappableOops						call $pop						return);; (JSProperty) property: showDisplayBitsLeftTopRightBot...;; (FunctionExpression) function(form, left, top, right, bottom)...(func $showDisplayBitsLeftTopRightBottom						(local $left i32)						(local $right i32)						(local $bottom i32)						(local $top i32)						(local $rect i32)						(local $form i32)						(local $temp i32)						;; (IfStatement) if (left < right && top < bottom) {var r...;; (BinaryExpression) left < right && top < bottom;; (BinaryExpression) left < right;; (JSIdentifier) left						local.get $left;; (JSIdentifier) right						local.get $right						i32.lt_u;; (BinaryExpression) top < bottom;; (JSIdentifier) top						local.get $top;; (JSIdentifier) bottom						local.get $bottom						i32.lt_u						i32.and						i32.const 0						i32.ne						(if (then;; (BlockStatement) var rect = {property: left -> left, prop...;; (VariableDeclaration) var rect = {property: left -> left, prop...;; (VariableDeclarator) rect = {property: left -> left, property...;; (ObjectExpression) {property: left -> left, property: top -...						local.set $rect;; (ExpressionStatement) this.vm.primHandler.displayDirty(form, r...;; (CallExpression) this.vm.primHandler.displayDirty(form, r...						local.get $vm.primHandler;; (JSIdentifier) form						local.get $form;; (JSIdentifier) rect						local.get $rect						call $displayDirty)));; (JSProperty) property: ioLoadFunctionFrom -> function...;; (FunctionExpression) function(funcName, pluginName) { 	return...(func $ioLoadFunctionFrom						(local $funcName i32)						(local $pluginName i32)						(local $temp i32)						;; (ReturnStatement) return this.vm.primHandler.loadFunctionF...;; (CallExpression) this.vm.primHandler.loadFunctionFrom(fun...						local.get $vm.primHandler;; (JSIdentifier) funcName						local.get $funcName;; (JSIdentifier) pluginName						local.get $pluginName						call $loadFunctionFrom						return);; (JSProperty) property: initialize -> function(method,...;; (FunctionExpression) function(method, vm) { 	this.method = me...(func $initialize						(local $vm i32)						(local $temp i32)						(local $method i32)						;; (ExpressionStatement) this.method = method;; (AssignmentExpression) this.method = method;; (JSIdentifier) method						local.get $method						local.set $method;; (ExpressionStatement) this.vm = vm;; (AssignmentExpression) this.vm = vm;; (JSIdentifier) vm						local.get $vm						local.set $vm);; (JSProperty) property: printInstructions -> function(...;; (FunctionExpression) function(indent, highlight, highlightPC)...(func $printInstructions						(local $indent i32)						(local $highlightPC i32)						(local $temp i32)						(local $highlight i32)						;; (ExpressionStatement) this.indent = indent;; (AssignmentExpression) this.indent = indent;; (JSIdentifier) indent						local.get $indent						local.set $indent;; (ExpressionStatement) this.highlight = highlight;; (AssignmentExpression) this.highlight = highlight;; (JSIdentifier) highlight						local.get $highlight						local.set $highlight;; (ExpressionStatement) this.highlightPC = highlightPC;; (AssignmentExpression) this.highlightPC = highlightPC;; (JSIdentifier) highlightPC						local.get $highlightPC						local.set $highlightPC;; (ExpressionStatement) this.innerIndents = {};; (AssignmentExpression) this.innerIndents = {};; (ObjectExpression) {}						local.set $innerIndents						;; unwritable: (ExpressionStatement) this.result = '';; (ExpressionStatement) this.scanner = new Squeak.InstructionStr...;; (AssignmentExpression) this.scanner = new Squeak.InstructionStr...;; (NewExpression) new Squeak.InstructionStream(this.method...						unreachable						local.set $scanner;; (ExpressionStatement) this.oldPC = this.scanner.pc;; (AssignmentExpression) this.oldPC = this.scanner.pc;; (StaticMemberExpression) this.scanner.pc;; (JSIdentifier) pc						local.get $pc						local.set $oldPC;; (ExpressionStatement) this.endPC = 0;; (AssignmentExpression) this.endPC = 0;; (JSLiteral) 0						i32.const 0						local.set $endPC;; (ExpressionStatement) this.done = false;; (AssignmentExpression) this.done = false;; (JSLiteral) false						i32.const 0						local.set $done;; (WhileStatement) while (!this.done) {this.scanner.interpr...						(loop $loop_1;; (ExpressionStatement) this.scanner.interpretNextInstructionFor...;; (CallExpression) this.scanner.interpretNextInstructionFor...						local.get $scanner;; (ThisExpression) this						call $interpretNextInstructionFor;; (UnaryExpression) !this.done;; (StaticMemberExpression) this.done;; (JSIdentifier) done						local.get $done						local.set $temp						i32.const -1						local.get $temp						i32.sub						i32.const 0						i32.eq						br_if $loop_1)						(block $loop_1_continue);; (ReturnStatement) return this.result;; (StaticMemberExpression) this.result;; (JSIdentifier) result						local.get $result						return);; (JSProperty) property: print -> function(instruction)...;; (FunctionExpression) function(instruction) { 	if (this.oldPC ...(func $print						(local $i i32)						(local $temp i32)						(local $instruction i32)						;; (IfStatement) if (this.oldPC === this.highlightPC) {if...;; (BinaryExpression) this.oldPC === this.highlightPC;; (StaticMemberExpression) this.oldPC;; (JSIdentifier) oldPC						local.get $oldPC;; (StaticMemberExpression) this.highlightPC;; (JSIdentifier) highlightPC						local.get $highlightPC						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (this.highlight) {this.result += this...;; (IfStatement) if (this.highlight) {this.result += this...;; (StaticMemberExpression) this.highlight;; (JSIdentifier) highlight						local.get $highlight						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.result += this.highlight;; (AssignmentExpression) this.result += this.highlight;; (StaticMemberExpression) this.result;; (JSIdentifier) result						local.get $result;; (StaticMemberExpression) this.highlight;; (JSIdentifier) highlight						local.get $highlight						i32.add						local.set $result)))						(else;; (BlockStatement) if (this.indent) {this.result += this.in...;; (IfStatement) if (this.indent) {this.result += this.in...;; (StaticMemberExpression) this.indent;; (JSIdentifier) indent						local.get $indent						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.result += this.indent;; (AssignmentExpression) this.result += this.indent;; (StaticMemberExpression) this.result;; (JSIdentifier) result						local.get $result;; (StaticMemberExpression) this.indent;; (JSIdentifier) indent						local.get $indent						i32.add						local.set $result))));; (ExpressionStatement) this.result += this.oldPC;; (AssignmentExpression) this.result += this.oldPC;; (StaticMemberExpression) this.result;; (JSIdentifier) result						local.get $result;; (StaticMemberExpression) this.oldPC;; (JSIdentifier) oldPC						local.get $oldPC						i32.add						local.set $result						;; unwritable: (ForStatement) for (var i = 0; i < this.innerIndents[th						;; unwritable: (ExpressionStatement) this.result += ' <'						;; unwritable: (ForStatement) for (var i = this.oldPC; i < this.scanne						;; unwritable: (ExpressionStatement) this.result += '> ' + instruction + '
';; (ExpressionStatement) this.oldPC = this.scanner.pc;; (AssignmentExpression) this.oldPC = this.scanner.pc;; (StaticMemberExpression) this.scanner.pc;; (JSIdentifier) pc						local.get $pc						local.set $oldPC);; (JSProperty) property: blockReturnTop -> function() {...;; (FunctionExpression) function() { 	this.print('blockReturn') ...(func $blockReturnTop						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('blockReturn'));; (JSProperty) property: doDup -> function() { 	this.pr...;; (FunctionExpression) function() { 	this.print('dup') }(func $doDup						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('dup'));; (JSProperty) property: doPop -> function() { 	this.pr...;; (FunctionExpression) function() { 	this.print('pop') }(func $doPop						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('pop'));; (JSProperty) property: jump -> function(offset) { 	th...;; (FunctionExpression) function(offset) { 	this.print('jumpTo: ...(func $jump						(local $offset i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('jumpTo: ' + this.scanner.pc ;; (IfStatement) if (this.scanner.pc + offset > this.endP...;; (BinaryExpression) this.scanner.pc + offset > this.endPC;; (BinaryExpression) this.scanner.pc + offset;; (StaticMemberExpression) this.scanner.pc;; (JSIdentifier) pc						local.get $pc;; (JSIdentifier) offset						local.get $offset						i32.add;; (StaticMemberExpression) this.endPC;; (JSIdentifier) endPC						local.get $endPC						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.endPC = this.scanner.pc + offset;; (AssignmentExpression) this.endPC = this.scanner.pc + offset;; (BinaryExpression) this.scanner.pc + offset;; (StaticMemberExpression) this.scanner.pc;; (JSIdentifier) pc						local.get $pc;; (JSIdentifier) offset						local.get $offset						i32.add						local.set $endPC)));; (JSProperty) property: jumpIf -> function(condition, ...;; (FunctionExpression) function(condition, offset) { 	this.prin...(func $jumpIf						(local $offset i32)						(local $condition i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print(condition ? 'jumpIfTrue: ' : ;; (IfStatement) if (this.scanner.pc + offset > this.endP...;; (BinaryExpression) this.scanner.pc + offset > this.endPC;; (BinaryExpression) this.scanner.pc + offset;; (StaticMemberExpression) this.scanner.pc;; (JSIdentifier) pc						local.get $pc;; (JSIdentifier) offset						local.get $offset						i32.add;; (StaticMemberExpression) this.endPC;; (JSIdentifier) endPC						local.get $endPC						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.endPC = this.scanner.pc + offset;; (AssignmentExpression) this.endPC = this.scanner.pc + offset;; (BinaryExpression) this.scanner.pc + offset;; (StaticMemberExpression) this.scanner.pc;; (JSIdentifier) pc						local.get $pc;; (JSIdentifier) offset						local.get $offset						i32.add						local.set $endPC)));; (JSProperty) property: methodReturnReceiver -> functi...;; (FunctionExpression) function() { 	this.print('return: receiv...(func $methodReturnReceiver						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('return: receiver');; (ExpressionStatement) this.done = this.scanner.pc > this.endPC;; (AssignmentExpression) this.done = this.scanner.pc > this.endPC;; (BinaryExpression) this.scanner.pc > this.endPC;; (StaticMemberExpression) this.scanner.pc;; (JSIdentifier) pc						local.get $pc;; (StaticMemberExpression) this.endPC;; (JSIdentifier) endPC						local.get $endPC						i32.gt_u						local.set $done);; (JSProperty) property: methodReturnTop -> function() ...;; (FunctionExpression) function() { 	this.print('return: topOfS...(func $methodReturnTop						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('return: topOfStack');; (ExpressionStatement) this.done = this.scanner.pc > this.endPC;; (AssignmentExpression) this.done = this.scanner.pc > this.endPC;; (BinaryExpression) this.scanner.pc > this.endPC;; (StaticMemberExpression) this.scanner.pc;; (JSIdentifier) pc						local.get $pc;; (StaticMemberExpression) this.endPC;; (JSIdentifier) endPC						local.get $endPC						i32.gt_u						local.set $done);; (JSProperty) property: methodReturnConstant -> functi...;; (FunctionExpression) function(obj) { 	this.print('returnConst...(func $methodReturnConstant						(local $obj i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('returnConst: ' + obj.toStrin;; (ExpressionStatement) this.done = this.scanner.pc > this.endPC;; (AssignmentExpression) this.done = this.scanner.pc > this.endPC;; (BinaryExpression) this.scanner.pc > this.endPC;; (StaticMemberExpression) this.scanner.pc;; (JSIdentifier) pc						local.get $pc;; (StaticMemberExpression) this.endPC;; (JSIdentifier) endPC						local.get $endPC						i32.gt_u						local.set $done);; (JSProperty) property: popIntoLiteralVariable -> func...;; (FunctionExpression) function(anAssociation) { 	this.print('p...(func $popIntoLiteralVariable						(local $anAssociation i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('popIntoBinding: ' + anAssoci);; (JSProperty) property: popIntoReceiverVariable -> fun...;; (FunctionExpression) function(offset) { 	this.print('popIntoI...(func $popIntoReceiverVariable						(local $offset i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('popIntoInstVar: ' + offset));; (JSProperty) property: popIntoTemporaryVariable -> fu...;; (FunctionExpression) function(offset) { 	this.print('popIntoT...(func $popIntoTemporaryVariable						(local $offset i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('popIntoTemp: ' + offset));; (JSProperty) property: pushActiveContext -> function(...;; (FunctionExpression) function() { 	this.print('push: thisCont...(func $pushActiveContext						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('push: thisContext'));; (JSProperty) property: pushConstant -> function(obj) ...;; (FunctionExpression) function(obj) { 	var value = obj.sqInstN...(func $pushConstant						(local $obj i32)						(local $value i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('pushConst: ' + value));; (JSProperty) property: pushLiteralVariable -> functio...;; (FunctionExpression) function(anAssociation) { 	this.print('p...(func $pushLiteralVariable						(local $anAssociation i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('pushBinding: ' + anAssociati);; (JSProperty) property: pushReceiver -> function() { 	...;; (FunctionExpression) function() { 	this.print('push: self') }(func $pushReceiver						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('push: self'));; (JSProperty) property: pushReceiverVariable -> functi...;; (FunctionExpression) function(offset) { 	this.print('pushInst...(func $pushReceiverVariable						(local $offset i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('pushInstVar: ' + offset));; (JSProperty) property: pushTemporaryVariable -> funct...;; (FunctionExpression) function(offset) { 	this.print('pushTemp...(func $pushTemporaryVariable						(local $offset i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('pushTemp: ' + offset));; (JSProperty) property: send -> function(selector, num...;; (FunctionExpression) function(selector, numberArguments, supe...(func $send						(local $supered i32)						(local $selector i32)						(local $temp i32)						(local $numberArguments i32)												;; unwritable: (ExpressionStatement) this.print(supered ? 'superSend: #' : 's);; (JSProperty) property: storeIntoLiteralVariable -> fu...;; (FunctionExpression) function(anAssociation) { 	this.print('s...(func $storeIntoLiteralVariable						(local $anAssociation i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('storeIntoBinding: ' + anAsso);; (JSProperty) property: storeIntoReceiverVariable -> f...;; (FunctionExpression) function(offset) { 	this.print('storeInt...(func $storeIntoReceiverVariable						(local $offset i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('storeIntoInstVar: ' + offset);; (JSProperty) property: storeIntoTemporaryVariable -> ...;; (FunctionExpression) function(offset) { 	this.print('storeInt...(func $storeIntoTemporaryVariable						(local $offset i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('storeIntoTemp: ' + offset));; (JSProperty) property: pushNewArray -> function(size)...;; (FunctionExpression) function(size) { 	this.print('push: (Arr...(func $pushNewArray						(local $temp i32)						(local $size i32)												;; unwritable: (ExpressionStatement) this.print('push: (Array new: ' + size +);; (JSProperty) property: popIntoNewArray -> function(nu...;; (FunctionExpression) function(numElements) { 	this.print('pop...(func $popIntoNewArray						(local $numElements i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('pop: ' + numElements + ' int);; (JSProperty) property: pushRemoteTemp -> function(off...;; (FunctionExpression) function(offset, arrayOffset) { 	this.pr...(func $pushRemoteTemp						(local $arrayOffset i32)						(local $offset i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('push: ' + offset + ' ofTemp:);; (JSProperty) property: storeIntoRemoteTemp -> functio...;; (FunctionExpression) function(offset, arrayOffset) { 	this.pr...(func $storeIntoRemoteTemp						(local $arrayOffset i32)						(local $offset i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('storeInto: ' + offset + ' of);; (JSProperty) property: popIntoRemoteTemp -> function(...;; (FunctionExpression) function(offset, arrayOffset) { 	this.pr...(func $popIntoRemoteTemp						(local $arrayOffset i32)						(local $offset i32)						(local $temp i32)												;; unwritable: (ExpressionStatement) this.print('popInto: ' + offset + ' ofTe);; (JSProperty) property: pushClosureCopy -> function(nu...;; (FunctionExpression) function(numCopied, numArgs, blockSize) ...(func $pushClosureCopy						(local $blockSize i32)						(local $i i32)						(local $numCopied i32)						(local $from i32)						(local $numArgs i32)						(local $temp i32)						(local $to i32)												;; unwritable: (ExpressionStatement) this.print('closure(' + from + '-' + to ;; (ForStatement) for (var i = from; i < to; i++) {this.in...;; (VariableDeclaration) var i = from;; (VariableDeclarator) i = from;; (JSIdentifier) from						local.get $from						local.set $i						(loop $loop_1;; (ExpressionStatement) this.innerIndents[i] = this.innerIndents...;; (AssignmentExpression) this.innerIndents[i] = this.innerIndents...						local.get $this;; (JSIdentifier) i						local.get $i;; (BinaryExpression) this.innerIndents[i] || 0 + 1;; (BinaryExpression) this.innerIndents[i] || 0;; (ComputedMemberExpression) this.innerIndents[i];; (StaticMemberExpression) this.innerIndents;; (JSIdentifier) innerIndents						local.get $innerIndents;; (JSIdentifier) i						local.get $i						i32.const 4						i32.mul						i32.add;; (JSLiteral) 0						i32.const 0						i32.or;; (JSLiteral) 1						i32.const 1						i32.add						call $atPut;; (UpdateExpression) i++;; (JSIdentifier) i						local.get $i						i32.const 1						i32.add;; (BinaryExpression) i < to;; (JSIdentifier) i						local.get $i;; (JSIdentifier) to						local.get $to						i32.lt_u						i32.const 0						br_if $loop_1);; (IfStatement) if (to > this.endPC) {this.endPC = to};; (BinaryExpression) to > this.endPC;; (JSIdentifier) to						local.get $to;; (StaticMemberExpression) this.endPC;; (JSIdentifier) endPC						local.get $endPC						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ExpressionStatement) this.endPC = to;; (AssignmentExpression) this.endPC = to;; (JSIdentifier) to						local.get $to						local.set $endPC)));; (JSProperty) property: callPrimitive -> function(prim...;; (FunctionExpression) function(primitiveIndex) { 	this.print('...(func $callPrimitive						(local $temp i32)						(local $primitiveIndex i32)												;; unwritable: (ExpressionStatement) this.print('primitive: ' + primitiveInde);; (JSProperty) property: initialize -> function(method,...;; (FunctionExpression) function(method, vm) { 	this.vm = vm thi...(func $initialize						(local $vm i32)						(local $temp i32)						(local $method i32)						;; (ExpressionStatement) this.vm = vm;; (AssignmentExpression) this.vm = vm;; (JSIdentifier) vm						local.get $vm						local.set $vm;; (ExpressionStatement) this.method = method;; (AssignmentExpression) this.method = method;; (JSIdentifier) method						local.get $method						local.set $method;; (ExpressionStatement) this.pc = 0;; (AssignmentExpression) this.pc = 0;; (JSLiteral) 0						i32.const 0						local.set $pc						;; unwritable: (ExpressionStatement) this.specialConstants = [vm.trueObj, vm.);; (JSProperty) property: interpretNextInstructionFor ->...;; (FunctionExpression) function(client) { 	var method = this.me...(func $interpretNextInstructionFor						(local $client i32)						(local $offset i32)						(local $method i32)						(local $type i32)						(local $temp i32)						(local $byte i32)						;; (IfStatement) if (type === 0) {return client.pushRecei...;; (BinaryExpression) type === 0;; (JSIdentifier) type						local.get $type;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushReceiverVariable(offse...;; (CallExpression) client.pushReceiverVariable(offset)						local.get $client;; (JSIdentifier) offset						local.get $offset						call $pushReceiverVariable						return));; (IfStatement) if (type === 1) {return client.pushTempo...;; (BinaryExpression) type === 1;; (JSIdentifier) type						local.get $type;; (JSLiteral) 1						i32.const 1						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushTemporaryVariable(offs...;; (CallExpression) client.pushTemporaryVariable(offset)						local.get $client;; (JSIdentifier) offset						local.get $offset						call $pushTemporaryVariable						return));; (IfStatement) if (type === 2) {return client.pushConst...;; (BinaryExpression) type === 2;; (JSIdentifier) type						local.get $type;; (JSLiteral) 2						i32.const 2						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushConstant(method.method...;; (CallExpression) client.pushConstant(method.methodGetLite...						local.get $client;; (CallExpression) method.methodGetLiteral(offset)						local.get $method;; (JSIdentifier) offset						local.get $offset						call $methodGetLiteral						call $pushConstant						return));; (IfStatement) if (type === 3) {return client.pushConst...;; (BinaryExpression) type === 3;; (JSIdentifier) type						local.get $type;; (JSLiteral) 3						i32.const 3						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushConstant(method.method...;; (CallExpression) client.pushConstant(method.methodGetLite...						local.get $client;; (CallExpression) method.methodGetLiteral(offset + 16)						local.get $method;; (BinaryExpression) offset + 16;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 16						i32.const 16						i32.add						call $methodGetLiteral						call $pushConstant						return));; (IfStatement) if (type === 4) {return client.pushLiter...;; (BinaryExpression) type === 4;; (JSIdentifier) type						local.get $type;; (JSLiteral) 4						i32.const 4						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushLiteralVariable(method...;; (CallExpression) client.pushLiteralVariable(method.method...						local.get $client;; (CallExpression) method.methodGetLiteral(offset)						local.get $method;; (JSIdentifier) offset						local.get $offset						call $methodGetLiteral						call $pushLiteralVariable						return));; (IfStatement) if (type === 5) {return client.pushLiter...;; (BinaryExpression) type === 5;; (JSIdentifier) type						local.get $type;; (JSLiteral) 5						i32.const 5						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushLiteralVariable(method...;; (CallExpression) client.pushLiteralVariable(method.method...						local.get $client;; (CallExpression) method.methodGetLiteral(offset + 16)						local.get $method;; (BinaryExpression) offset + 16;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 16						i32.const 16						i32.add						call $methodGetLiteral						call $pushLiteralVariable						return));; (IfStatement) if (type === 6) {if (offset < 8) {return...;; (BinaryExpression) type === 6;; (JSIdentifier) type						local.get $type;; (JSLiteral) 6						i32.const 6						i32.eq						i32.const 0						i32.ne						(if (then;; (IfStatement) if (offset < 8) {return client.popIntoRe...;; (BinaryExpression) offset < 8;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 8						i32.const 8						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.popIntoReceiverVariable(of...;; (CallExpression) client.popIntoReceiverVariable(offset)						local.get $client;; (JSIdentifier) offset						local.get $offset						call $popIntoReceiverVariable						return)						(else;; (ReturnStatement) return client.popIntoTemporaryVariable(o...;; (CallExpression) client.popIntoTemporaryVariable(offset -...						local.get $client;; (BinaryExpression) offset - 8;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 8						i32.const 8						i32.sub						call $popIntoTemporaryVariable						return))));; (IfStatement) if (type === 7) {if (offset === 0) {retu...;; (BinaryExpression) type === 7;; (JSIdentifier) type						local.get $type;; (JSLiteral) 7						i32.const 7						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (offset === 0) {return client.pushRec...;; (IfStatement) if (offset === 0) {return client.pushRec...;; (BinaryExpression) offset === 0;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushReceiver();; (CallExpression) client.pushReceiver()						local.get $client						call $pushReceiver						return));; (IfStatement) if (offset < 8) {return client.pushConst...;; (BinaryExpression) offset < 8;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 8						i32.const 8						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushConstant(this.specialC...;; (CallExpression) client.pushConstant(this.specialConstant...						local.get $client;; (ComputedMemberExpression) this.specialConstants[offset - 1];; (StaticMemberExpression) this.specialConstants;; (JSIdentifier) specialConstants						local.get $specialConstants;; (BinaryExpression) offset - 1;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 1						i32.const 1						i32.sub						i32.const 4						i32.mul						i32.add						call $pushConstant						return));; (IfStatement) if (offset === 8) {return client.methodR...;; (BinaryExpression) offset === 8;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 8						i32.const 8						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.methodReturnReceiver();; (CallExpression) client.methodReturnReceiver()						local.get $client						call $methodReturnReceiver						return));; (IfStatement) if (offset < 12) {return client.methodRe...;; (BinaryExpression) offset < 12;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 12						i32.const 12						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.methodReturnConstant(this....;; (CallExpression) client.methodReturnConstant(this.special...						local.get $client;; (ComputedMemberExpression) this.specialConstants[offset - 9];; (StaticMemberExpression) this.specialConstants;; (JSIdentifier) specialConstants						local.get $specialConstants;; (BinaryExpression) offset - 9;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 9						i32.const 9						i32.sub						i32.const 4						i32.mul						i32.add						call $methodReturnConstant						return));; (IfStatement) if (offset === 12) {return client.method...;; (BinaryExpression) offset === 12;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 12						i32.const 12						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.methodReturnTop();; (CallExpression) client.methodReturnTop()						local.get $client						call $methodReturnTop						return));; (IfStatement) if (offset === 13) {return client.blockR...;; (BinaryExpression) offset === 13;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 13						i32.const 13						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.blockReturnTop();; (CallExpression) client.blockReturnTop()						local.get $client						call $blockReturnTop						return));; (IfStatement) if (offset > 13) {throw Error('unusedByt...;; (BinaryExpression) offset > 13;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 13						i32.const 13						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('unusedBytecode')						unreachable))));; (IfStatement) if (type === 8) {return this.interpretEx...;; (BinaryExpression) type === 8;; (JSIdentifier) type						local.get $type;; (JSLiteral) 8						i32.const 8						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return this.interpretExtension(offset, m...;; (CallExpression) this.interpretExtension(offset, method, ...						local.get $this;; (JSIdentifier) offset						local.get $offset;; (JSIdentifier) method						local.get $method;; (JSIdentifier) client						local.get $client						call $interpretExtension						return));; (IfStatement) if (type === 9) {if (offset < 8) {return...;; (BinaryExpression) type === 9;; (JSIdentifier) type						local.get $type;; (JSLiteral) 9						i32.const 9						i32.eq						i32.const 0						i32.ne						(if (then;; (IfStatement) if (offset < 8) {return client.jump(offs...;; (BinaryExpression) offset < 8;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 8						i32.const 8						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.jump(offset + 1);; (CallExpression) client.jump(offset + 1)						local.get $client;; (BinaryExpression) offset + 1;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 1						i32.const 1						i32.add						call $jump						return)						(else;; (ReturnStatement) return client.jumpIf(false, offset - 8 +...;; (CallExpression) client.jumpIf(false, offset - 8 + 1)						local.get $client;; (JSLiteral) false						i32.const 0;; (BinaryExpression) offset - 8 + 1;; (BinaryExpression) offset - 8;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 8						i32.const 8						i32.sub;; (JSLiteral) 1						i32.const 1						i32.add						call $jumpIf						return))));; (IfStatement) if (type === 10) {byte = this.method.byt...;; (BinaryExpression) type === 10;; (JSIdentifier) type						local.get $type;; (JSLiteral) 10						i32.const 10						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) byte = this.method.bytes[this.pc++] if (...;; (ExpressionStatement) byte = this.method.bytes[this.pc++];; (AssignmentExpression) byte = this.method.bytes[this.pc++];; (ComputedMemberExpression) this.method.bytes[this.pc++];; (StaticMemberExpression) this.method.bytes;; (JSIdentifier) bytes						local.get $bytes;; (UpdateExpression) this.pc++;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc						i32.const 1						i32.add						i32.const 4						i32.mul						i32.add						local.set $byte;; (IfStatement) if (offset < 8) {return client.jump(offs...;; (BinaryExpression) offset < 8;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 8						i32.const 8						i32.lt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.jump(offset - 4 * 256 + by...;; (CallExpression) client.jump(offset - 4 * 256 + byte)						local.get $client;; (BinaryExpression) offset - 4 * 256 + byte;; (BinaryExpression) offset - 4 * 256;; (BinaryExpression) offset - 4;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 4						i32.const 4						i32.sub;; (JSLiteral) 256						i32.const 256						i32.mul;; (JSIdentifier) byte						local.get $byte						i32.add						call $jump						return)						(else;; (ReturnStatement) return client.jumpIf(offset < 12, offset...;; (CallExpression) client.jumpIf(offset < 12, offset & 3 * ...						local.get $client;; (BinaryExpression) offset < 12;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 12						i32.const 12						i32.lt_u;; (BinaryExpression) offset & 3 * 256 + byte;; (BinaryExpression) offset & 3 * 256;; (BinaryExpression) offset & 3;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 3						i32.const 3						i32.and;; (JSLiteral) 256						i32.const 256						i32.mul;; (JSIdentifier) byte						local.get $byte						i32.add						call $jumpIf						return))));; (IfStatement) if (type === 11) {return client.send(thi...;; (BinaryExpression) type === 11;; (JSIdentifier) type						local.get $type;; (JSLiteral) 11						i32.const 11						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.send(this.vm.specialSelect...;; (CallExpression) client.send(this.vm.specialSelectors[2 *...						local.get $client;; (ComputedMemberExpression) this.vm.specialSelectors[2 * offset];; (StaticMemberExpression) this.vm.specialSelectors;; (JSIdentifier) specialSelectors						local.get $specialSelectors;; (BinaryExpression) 2 * offset;; (JSLiteral) 2						i32.const 2;; (JSIdentifier) offset						local.get $offset						i32.mul						i32.const 4						i32.mul						i32.add;; (ComputedMemberExpression) this.vm.specialSelectors[2 * offset + 1];; (StaticMemberExpression) this.vm.specialSelectors;; (JSIdentifier) specialSelectors						local.get $specialSelectors;; (BinaryExpression) 2 * offset + 1;; (BinaryExpression) 2 * offset;; (JSLiteral) 2						i32.const 2;; (JSIdentifier) offset						local.get $offset						i32.mul;; (JSLiteral) 1						i32.const 1						i32.add						i32.const 4						i32.mul						i32.add;; (JSLiteral) false						i32.const 0						call $send						return));; (IfStatement) if (type === 12) {return client.send(thi...;; (BinaryExpression) type === 12;; (JSIdentifier) type						local.get $type;; (JSLiteral) 12						i32.const 12						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.send(this.vm.specialSelect...;; (CallExpression) client.send(this.vm.specialSelectors[2 *...						local.get $client;; (ComputedMemberExpression) this.vm.specialSelectors[2 * offset + 16...;; (StaticMemberExpression) this.vm.specialSelectors;; (JSIdentifier) specialSelectors						local.get $specialSelectors;; (BinaryExpression) 2 * offset + 16;; (JSLiteral) 2						i32.const 2;; (BinaryExpression) offset + 16;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 16						i32.const 16						i32.add						i32.mul						i32.const 4						i32.mul						i32.add;; (ComputedMemberExpression) this.vm.specialSelectors[2 * offset + 16...;; (StaticMemberExpression) this.vm.specialSelectors;; (JSIdentifier) specialSelectors						local.get $specialSelectors;; (BinaryExpression) 2 * offset + 16 + 1;; (BinaryExpression) 2 * offset + 16;; (JSLiteral) 2						i32.const 2;; (BinaryExpression) offset + 16;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 16						i32.const 16						i32.add						i32.mul;; (JSLiteral) 1						i32.const 1						i32.add						i32.const 4						i32.mul						i32.add;; (JSLiteral) false						i32.const 0						call $send						return));; (IfStatement) if (type > 12) {return client.send(metho...;; (BinaryExpression) type > 12;; (JSIdentifier) type						local.get $type;; (JSLiteral) 12						i32.const 12						i32.gt_u						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.send(method.methodGetLiter...;; (CallExpression) client.send(method.methodGetLiteral(offs...						local.get $client;; (CallExpression) method.methodGetLiteral(offset)						local.get $method;; (JSIdentifier) offset						local.get $offset						call $methodGetLiteral;; (BinaryExpression) type - 13;; (JSIdentifier) type						local.get $type;; (JSLiteral) 13						i32.const 13						i32.sub;; (JSLiteral) false						i32.const 0						call $send						return)));; (JSProperty) property: interpretExtension -> function...;; (FunctionExpression) function(offset, method, client) { 	if (...(func $interpretExtension						(local $type i32)						(local $method i32)						(local $temp i32)						(local $byte4 i32)						(local $offset i32)						(local $client i32)						(local $byte3 i32)						(local $offset2 i32)						(local $byte2 i32)						;; (IfStatement) if (offset <= 6) {var byte2 = this.metho...;; (BinaryExpression) offset <= 6;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 6						i32.const 6						i32.le_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) var byte2 = this.method.bytes[this.pc++]...;; (VariableDeclaration) var byte2 = this.method.bytes[this.pc++];; (VariableDeclarator) byte2 = this.method.bytes[this.pc++];; (ComputedMemberExpression) this.method.bytes[this.pc++];; (StaticMemberExpression) this.method.bytes;; (JSIdentifier) bytes						local.get $bytes;; (UpdateExpression) this.pc++;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc						i32.const 1						i32.add						i32.const 4						i32.mul						i32.add						local.set $byte2;; (IfStatement) if (offset <= 2) {var type = byte2 / 64 ...;; (BinaryExpression) offset <= 2;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 2						i32.const 2						i32.le_u						i32.const 0						i32.ne						(if (then;; (BlockStatement) var type = byte2 / 64 | 0 var offset2 = ...;; (VariableDeclaration) var type = byte2 / 64 | 0;; (VariableDeclarator) type = byte2 / 64 | 0;; (BinaryExpression) byte2 / 64 | 0;; (BinaryExpression) byte2 / 64;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 64						i32.const 64						i32.div_s;; (JSLiteral) 0						i32.const 0						i32.or						local.set $type;; (VariableDeclaration) var offset2 = byte2 % 64;; (VariableDeclarator) offset2 = byte2 % 64;; (BinaryExpression) byte2 % 64;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 64						i32.const 64						i32.rem_s						local.set $offset2;; (IfStatement) if (offset === 0) {if (type === 0) {retu...;; (BinaryExpression) offset === 0;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (type === 0) {return client.pushRecei...;; (IfStatement) if (type === 0) {return client.pushRecei...;; (BinaryExpression) type === 0;; (JSIdentifier) type						local.get $type;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushReceiverVariable(offse...;; (CallExpression) client.pushReceiverVariable(offset2)						local.get $client;; (JSIdentifier) offset2						local.get $offset2						call $pushReceiverVariable						return));; (IfStatement) if (type === 1) {return client.pushTempo...;; (BinaryExpression) type === 1;; (JSIdentifier) type						local.get $type;; (JSLiteral) 1						i32.const 1						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushTemporaryVariable(offs...;; (CallExpression) client.pushTemporaryVariable(offset2)						local.get $client;; (JSIdentifier) offset2						local.get $offset2						call $pushTemporaryVariable						return));; (IfStatement) if (type === 2) {return client.pushConst...;; (BinaryExpression) type === 2;; (JSIdentifier) type						local.get $type;; (JSLiteral) 2						i32.const 2						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushConstant(this.method.m...;; (CallExpression) client.pushConstant(this.method.methodGe...						local.get $client;; (CallExpression) this.method.methodGetLiteral(offset2)						local.get $method;; (JSIdentifier) offset2						local.get $offset2						call $methodGetLiteral						call $pushConstant						return));; (IfStatement) if (type === 3) {return client.pushLiter...;; (BinaryExpression) type === 3;; (JSIdentifier) type						local.get $type;; (JSLiteral) 3						i32.const 3						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushLiteralVariable(this.m...;; (CallExpression) client.pushLiteralVariable(this.method.m...						local.get $client;; (CallExpression) this.method.methodGetLiteral(offset2)						local.get $method;; (JSIdentifier) offset2						local.get $offset2						call $methodGetLiteral						call $pushLiteralVariable						return))));; (IfStatement) if (offset === 1) {if (type === 0) {retu...;; (BinaryExpression) offset === 1;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 1						i32.const 1						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (type === 0) {return client.storeInto...;; (IfStatement) if (type === 0) {return client.storeInto...;; (BinaryExpression) type === 0;; (JSIdentifier) type						local.get $type;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.storeIntoReceiverVariable(...;; (CallExpression) client.storeIntoReceiverVariable(offset2...						local.get $client;; (JSIdentifier) offset2						local.get $offset2						call $storeIntoReceiverVariable						return));; (IfStatement) if (type === 1) {return client.storeInto...;; (BinaryExpression) type === 1;; (JSIdentifier) type						local.get $type;; (JSLiteral) 1						i32.const 1						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.storeIntoTemporaryVariable...;; (CallExpression) client.storeIntoTemporaryVariable(offset...						local.get $client;; (JSIdentifier) offset2						local.get $offset2						call $storeIntoTemporaryVariable						return));; (IfStatement) if (type === 2) {throw Error('illegalSto...;; (BinaryExpression) type === 2;; (JSIdentifier) type						local.get $type;; (JSLiteral) 2						i32.const 2						i32.eq						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('illegalStore')						unreachable));; (IfStatement) if (type === 3) {return client.storeInto...;; (BinaryExpression) type === 3;; (JSIdentifier) type						local.get $type;; (JSLiteral) 3						i32.const 3						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.storeIntoLiteralVariable(t...;; (CallExpression) client.storeIntoLiteralVariable(this.met...						local.get $client;; (CallExpression) this.method.methodGetLiteral(offset2)						local.get $method;; (JSIdentifier) offset2						local.get $offset2						call $methodGetLiteral						call $storeIntoLiteralVariable						return))));; (IfStatement) if (offset === 2) {if (type === 0) {retu...;; (BinaryExpression) offset === 2;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 2						i32.const 2						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) if (type === 0) {return client.popIntoRe...;; (IfStatement) if (type === 0) {return client.popIntoRe...;; (BinaryExpression) type === 0;; (JSIdentifier) type						local.get $type;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.popIntoReceiverVariable(of...;; (CallExpression) client.popIntoReceiverVariable(offset2)						local.get $client;; (JSIdentifier) offset2						local.get $offset2						call $popIntoReceiverVariable						return));; (IfStatement) if (type === 1) {return client.popIntoTe...;; (BinaryExpression) type === 1;; (JSIdentifier) type						local.get $type;; (JSLiteral) 1						i32.const 1						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.popIntoTemporaryVariable(o...;; (CallExpression) client.popIntoTemporaryVariable(offset2)						local.get $client;; (JSIdentifier) offset2						local.get $offset2						call $popIntoTemporaryVariable						return));; (IfStatement) if (type === 2) {throw Error('illegalSto...;; (BinaryExpression) type === 2;; (JSIdentifier) type						local.get $type;; (JSLiteral) 2						i32.const 2						i32.eq						i32.const 0						i32.ne						(if (then;; (ThrowStatement) throw Error('illegalStore')						unreachable));; (IfStatement) if (type === 3) {return client.popIntoLi...;; (BinaryExpression) type === 3;; (JSIdentifier) type						local.get $type;; (JSLiteral) 3						i32.const 3						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.popIntoLiteralVariable(thi...;; (CallExpression) client.popIntoLiteralVariable(this.metho...						local.get $client;; (CallExpression) this.method.methodGetLiteral(offset2)						local.get $method;; (JSIdentifier) offset2						local.get $offset2						call $methodGetLiteral						call $popIntoLiteralVariable						return))))));; (IfStatement) if (offset === 3) {return client.send(th...;; (BinaryExpression) offset === 3;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 3						i32.const 3						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.send(this.method.methodGet...;; (CallExpression) client.send(this.method.methodGetLiteral...						local.get $client;; (CallExpression) this.method.methodGetLiteral(byte2 % 32)						local.get $method;; (BinaryExpression) byte2 % 32;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 32						i32.const 32						i32.rem_s						call $methodGetLiteral;; (BinaryExpression) byte2 / 32 | 0;; (BinaryExpression) byte2 / 32;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 32						i32.const 32						i32.div_s;; (JSLiteral) 0						i32.const 0						i32.or;; (JSLiteral) false						i32.const 0						call $send						return));; (IfStatement) if (offset === 4) {var byte3 = this.meth...;; (BinaryExpression) offset === 4;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 4						i32.const 4						i32.eq						i32.const 0						i32.ne						(if (then;; (BlockStatement) var byte3 = this.method.bytes[this.pc++]...;; (VariableDeclaration) var byte3 = this.method.bytes[this.pc++];; (VariableDeclarator) byte3 = this.method.bytes[this.pc++];; (ComputedMemberExpression) this.method.bytes[this.pc++];; (StaticMemberExpression) this.method.bytes;; (JSIdentifier) bytes						local.get $bytes;; (UpdateExpression) this.pc++;; (StaticMemberExpression) this.pc;; (JSIdentifier) pc						local.get $pc						i32.const 1						i32.add						i32.const 4						i32.mul						i32.add						local.set $byte3;; (VariableDeclaration) var type = byte2 / 32 | 0;; (VariableDeclarator) type = byte2 / 32 | 0;; (BinaryExpression) byte2 / 32 | 0;; (BinaryExpression) byte2 / 32;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 32						i32.const 32						i32.div_s;; (JSLiteral) 0						i32.const 0						i32.or						local.set $type;; (IfStatement) if (type === 0) {return client.send(this...;; (BinaryExpression) type === 0;; (JSIdentifier) type						local.get $type;; (JSLiteral) 0						i32.const 0						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.send(this.method.methodGet...;; (CallExpression) client.send(this.method.methodGetLiteral...						local.get $client;; (CallExpression) this.method.methodGetLiteral(byte3)						local.get $method;; (JSIdentifier) byte3						local.get $byte3						call $methodGetLiteral;; (BinaryExpression) byte2 % 32;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 32						i32.const 32						i32.rem_s;; (JSLiteral) false						i32.const 0						call $send						return));; (IfStatement) if (type === 1) {return client.send(this...;; (BinaryExpression) type === 1;; (JSIdentifier) type						local.get $type;; (JSLiteral) 1						i32.const 1						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.send(this.method.methodGet...;; (CallExpression) client.send(this.method.methodGetLiteral...						local.get $client;; (CallExpression) this.method.methodGetLiteral(byte3)						local.get $method;; (JSIdentifier) byte3						local.get $byte3						call $methodGetLiteral;; (BinaryExpression) byte2 % 32;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 32						i32.const 32						i32.rem_s;; (JSLiteral) true						i32.const 1						call $send						return));; (IfStatement) if (type === 2) {return client.pushRecei...;; (BinaryExpression) type === 2;; (JSIdentifier) type						local.get $type;; (JSLiteral) 2						i32.const 2						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushReceiverVariable(byte3...;; (CallExpression) client.pushReceiverVariable(byte3)						local.get $client;; (JSIdentifier) byte3						local.get $byte3						call $pushReceiverVariable						return));; (IfStatement) if (type === 3) {return client.pushConst...;; (BinaryExpression) type === 3;; (JSIdentifier) type						local.get $type;; (JSLiteral) 3						i32.const 3						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushConstant(this.method.m...;; (CallExpression) client.pushConstant(this.method.methodGe...						local.get $client;; (CallExpression) this.method.methodGetLiteral(byte3)						local.get $method;; (JSIdentifier) byte3						local.get $byte3						call $methodGetLiteral						call $pushConstant						return));; (IfStatement) if (type === 4) {return client.pushLiter...;; (BinaryExpression) type === 4;; (JSIdentifier) type						local.get $type;; (JSLiteral) 4						i32.const 4						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushLiteralVariable(this.m...;; (CallExpression) client.pushLiteralVariable(this.method.m...						local.get $client;; (CallExpression) this.method.methodGetLiteral(byte3)						local.get $method;; (JSIdentifier) byte3						local.get $byte3						call $methodGetLiteral						call $pushLiteralVariable						return));; (IfStatement) if (type === 5) {return client.storeInto...;; (BinaryExpression) type === 5;; (JSIdentifier) type						local.get $type;; (JSLiteral) 5						i32.const 5						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.storeIntoReceiverVariable(...;; (CallExpression) client.storeIntoReceiverVariable(byte3)						local.get $client;; (JSIdentifier) byte3						local.get $byte3						call $storeIntoReceiverVariable						return));; (IfStatement) if (type === 6) {return client.popIntoRe...;; (BinaryExpression) type === 6;; (JSIdentifier) type						local.get $type;; (JSLiteral) 6						i32.const 6						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.popIntoReceiverVariable(by...;; (CallExpression) client.popIntoReceiverVariable(byte3)						local.get $client;; (JSIdentifier) byte3						local.get $byte3						call $popIntoReceiverVariable						return));; (IfStatement) if (type === 7) {return client.storeInto...;; (BinaryExpression) type === 7;; (JSIdentifier) type						local.get $type;; (JSLiteral) 7						i32.const 7						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.storeIntoLiteralVariable(t...;; (CallExpression) client.storeIntoLiteralVariable(this.met...						local.get $client;; (CallExpression) this.method.methodGetLiteral(byte3)						local.get $method;; (JSIdentifier) byte3						local.get $byte3						call $methodGetLiteral						call $storeIntoLiteralVariable						return))));; (IfStatement) if (offset === 5) {return client.send(th...;; (BinaryExpression) offset === 5;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 5						i32.const 5						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.send(this.method.methodGet...;; (CallExpression) client.send(this.method.methodGetLiteral...						local.get $client;; (CallExpression) this.method.methodGetLiteral(byte2 & 31)						local.get $method;; (BinaryExpression) byte2 & 31;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 31						i32.const 31						i32.and						call $methodGetLiteral;; (BinaryExpression) byte2 >> 5;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 5						i32.const 5						i32.shr_s;; (JSLiteral) true						i32.const 1						call $send						return));; (IfStatement) if (offset === 6) {return client.send(th...;; (BinaryExpression) offset === 6;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 6						i32.const 6						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.send(this.method.methodGet...;; (CallExpression) client.send(this.method.methodGetLiteral...						local.get $client;; (CallExpression) this.method.methodGetLiteral(byte2 & 63)						local.get $method;; (BinaryExpression) byte2 & 63;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 63						i32.const 63						i32.and						call $methodGetLiteral;; (BinaryExpression) byte2 >> 6;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 6						i32.const 6						i32.shr_s;; (JSLiteral) false						i32.const 0						call $send						return))));; (IfStatement) if (offset === 7) {return client.doPop()...;; (BinaryExpression) offset === 7;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 7						i32.const 7						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.doPop();; (CallExpression) client.doPop()						local.get $client						call $doPop						return));; (IfStatement) if (offset === 8) {return client.doDup()...;; (BinaryExpression) offset === 8;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 8						i32.const 8						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.doDup();; (CallExpression) client.doDup()						local.get $client						call $doDup						return));; (IfStatement) if (offset === 9) {return client.pushAct...;; (BinaryExpression) offset === 9;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 9						i32.const 9						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushActiveContext();; (CallExpression) client.pushActiveContext()						local.get $client						call $pushActiveContext						return));; (IfStatement) if (offset === 10) {return byte2 < 128 ?...;; (BinaryExpression) offset === 10;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 10						i32.const 10						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return byte2 < 128 ? client.pushNewArray...;; (ConditionalExpression) byte2 < 128 ? client.pushNewArray(byte2)...;; (BinaryExpression) byte2 < 128;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 128						i32.const 128						i32.lt_u						i32.const 1						i32.eq						(if (then;; (CallExpression) client.pushNewArray(byte2)						local.get $client;; (JSIdentifier) byte2						local.get $byte2						call $pushNewArray)						(else;; (CallExpression) client.popIntoNewArray(byte2 - 128)						local.get $client;; (BinaryExpression) byte2 - 128;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 128						i32.const 128						i32.sub						call $popIntoNewArray						))						return));; (IfStatement) if (offset === 11) {return client.callPr...;; (BinaryExpression) offset === 11;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 11						i32.const 11						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.callPrimitive(byte2 + 256 ...;; (CallExpression) client.callPrimitive(byte2 + 256 * byte3...						local.get $client;; (BinaryExpression) byte2 + 256 * byte3;; (JSIdentifier) byte2						local.get $byte2;; (BinaryExpression) 256 * byte3;; (JSLiteral) 256						i32.const 256;; (JSIdentifier) byte3						local.get $byte3						i32.mul						i32.add						call $callPrimitive						return));; (IfStatement) if (offset === 12) {return client.pushRe...;; (BinaryExpression) offset === 12;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 12						i32.const 12						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.pushRemoteTemp(byte2, byte...;; (CallExpression) client.pushRemoteTemp(byte2, byte3)						local.get $client;; (JSIdentifier) byte2						local.get $byte2;; (JSIdentifier) byte3						local.get $byte3						call $pushRemoteTemp						return));; (IfStatement) if (offset === 13) {return client.storeI...;; (BinaryExpression) offset === 13;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 13						i32.const 13						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.storeIntoRemoteTemp(byte2,...;; (CallExpression) client.storeIntoRemoteTemp(byte2, byte3)						local.get $client;; (JSIdentifier) byte2						local.get $byte2;; (JSIdentifier) byte3						local.get $byte3						call $storeIntoRemoteTemp						return));; (IfStatement) if (offset === 14) {return client.popInt...;; (BinaryExpression) offset === 14;; (JSIdentifier) offset						local.get $offset;; (JSLiteral) 14						i32.const 14						i32.eq						i32.const 0						i32.ne						(if (then;; (ReturnStatement) return client.popIntoRemoteTemp(byte2, b...;; (CallExpression) client.popIntoRemoteTemp(byte2, byte3)						local.get $client;; (JSIdentifier) byte2						local.get $byte2;; (JSIdentifier) byte3						local.get $byte3						call $popIntoRemoteTemp						return));; (ReturnStatement) return client.pushClosureCopy(byte2 >> 4...;; (CallExpression) client.pushClosureCopy(byte2 >> 4, byte2...						local.get $client;; (BinaryExpression) byte2 >> 4;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 4						i32.const 4						i32.shr_s;; (BinaryExpression) byte2 & 15;; (JSIdentifier) byte2						local.get $byte2;; (JSLiteral) 15						i32.const 15						i32.and;; (BinaryExpression) byte3 * 256 + byte4;; (BinaryExpression) byte3 * 256;; (JSIdentifier) byte3						local.get $byte3;; (JSLiteral) 256						i32.const 256						i32.mul;; (JSIdentifier) byte4						local.get $byte4						i32.add						call $pushClosureCopy						return))